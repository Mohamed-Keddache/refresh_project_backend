

=== package.json ===
{
  "name": "refresh_project",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server.js"
  },
  "engines": {
    "node": ">=18"
  },
  "dependencies": {
    "bcryptjs": "2.4.3",
    "cors": "2.8.5",
    "dotenv": "16.4.5",
    "express": "4.21.2",
    "jsonwebtoken": "9.0.2",
    "mongoose": "8.9.5",
    "morgan": "1.10.1",
    "multer": "1.4.5-lts.1",
    "nodemailer": "^6.9.9"
  }
}


=== server.js ===
import express from "express";
import dotenv from "dotenv";
import cors from "cors";
import morgan from "morgan";
import connectDB from "./config/db.js";
import setupFolders from "./startup/setupFolders.js";
import { seedAdmin } from "./startup/seedAdmin.js";

import authRoutes from "./routes/authRoutes.js";
import candidateRoutes from "./routes/candidateRoutes.js";
import recruiterRoutes from "./routes/recruiterRoutes.js";
import adminRoutes from "./routes/adminRoutes.js";
import offerRoutes from "./routes/offerRoutes.js";
import notificationRoutes from "./routes/notificationRoutes.js";
import skillRoutes from "./routes/skillRoutes.js";
import supportRoutes from "./routes/supportRoutes.js";
import announcementRoutes from "./routes/announcementRoutes.js";

dotenv.config();
const app = express();

app.use(
  cors({
    origin:
      process.env.NODE_ENV === "production" ? process.env.FRONTEND_URL : "*",
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: [
      "Content-Type",
      "Authorization",
      "ngrok-skip-browser-warning",
    ],
  }),
);
app.use(express.json());
app.use(morgan("dev"));
app.use("/uploads", express.static("uploads"));

async function startServer() {
  try {
    await connectDB();
    setupFolders();
    await seedAdmin();

    app.use("/api/skills", skillRoutes);
    app.use("/api/offers", offerRoutes);

    app.use("/api/auth", authRoutes);
    app.use("/api/candidates", candidateRoutes);
    app.use("/api/recruiters", recruiterRoutes);
    app.use("/api/admin", adminRoutes);
    app.use("/api/notifications", notificationRoutes);
    app.use("/api/support", supportRoutes);
    app.use("/api/announcements", announcementRoutes);

    app.get("/", (req, res) => res.send("âœ… API Recrutement opÃ©rationnelle !"));

    const PORT = process.env.PORT || 5000;
    app.listen(PORT, () => console.log(`ðŸš€ Serveur lancÃ© sur le port ${PORT}`));
  } catch (error) {
    console.error("âŒ Erreur lors du dÃ©marrage du serveur :", error);
    process.exit(1);
  }
}

startServer();


=== config\db.js ===
import mongoose from "mongoose";

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("ðŸŸ¢ ConnectÃ© Ã  MongoDB");
  } catch (err) {
    console.error("âŒ Erreur MongoDB :", err.message);
    process.exit(1);
  }
};

export default connectDB;


=== config\email.js ===
import nodemailer from "nodemailer";

export const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});


=== config\multer.js ===
import multer from "multer";
import path from "path";

const storageCV = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "uploads/cv");
  },
  filename: function (req, file, cb) {
    const unique = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, unique + path.extname(file.originalname));
  },
});

const fileFilterCV = (req, file, cb) => {
  const allowed = [".pdf", ".doc", ".docx"];
  const ext = path.extname(file.originalname).toLowerCase();

  if (!allowed.includes(ext)) {
    return cb(new Error("Seulement PDF, DOC ou DOCX"));
  }
  cb(null, true);
};

export const uploadCV = multer({
  storage: storageCV,
  fileFilter: fileFilterCV,
  limits: { fileSize: 5 * 1024 * 1024 },
});

const storageImage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "uploads/images");
  },
  filename: function (req, file, cb) {
    const unique = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, unique + path.extname(file.originalname));
  },
});

const fileFilterImage = (req, file, cb) => {
  const allowed = [".jpg", ".jpeg", ".png", ".webp"];
  const ext = path.extname(file.originalname).toLowerCase();

  if (!allowed.includes(ext)) {
    return cb(new Error("Seulement JPG, JPEG, PNG ou WEBP"));
  }
  cb(null, true);
};

export const uploadImage = multer({
  storage: storageImage,
  fileFilter: fileFilterImage,
  limits: { fileSize: 5 * 1024 * 1024 },
});

const storageAttachments = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "uploads/attachments");
  },
  filename: function (req, file, cb) {
    const unique = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, unique + path.extname(file.originalname));
  },
});

const fileFilterAttachments = (req, file, cb) => {
  const allowed = [".pdf", ".doc", ".docx", ".jpg", ".jpeg", ".png", ".webp"];

  const ext = path.extname(file.originalname).toLowerCase();

  if (!allowed.includes(ext)) {
    return cb(new Error("Type de fichier non autorisÃ©"));
  }
  cb(null, true);
};

export const uploadAttachments = multer({
  storage: storageAttachments,
  fileFilter: fileFilterAttachments,
  limits: { fileSize: 10 * 1024 * 1024 },
});


=== controllers\adminController.js ===
import User from "../models/User.js";
import Recruiter from "../models/Recruiter.js";
import Candidate from "../models/Candidate.js";
import Offer from "../models/Offer.js";
import Admin from "../models/Admin.js";
import Notification from "../models/Notification.js";
import Application from "../models/Application.js";
import Company from "../models/Company.js";
import bcrypt from "bcryptjs";
import SupportTicket from "../models/SupportTicket.js";
import AdminLog, { logAdminAction } from "../models/AdminLog.js";

export const getRecruiters = async (req, res) => {
  try {
    const { status, page = 1, limit = 20, search } = req.query;

    let query = {};

    if (status === "pending") {
      query.status = { $in: ["pending_validation", "pending_revalidation"] };
    } else if (status === "requests_sent") {
      query.status = {
        $in: [
          "pending_info",
          "pending_documents",
          "pending_info_and_documents",
        ],
      };
    } else if (status === "decision_made") {
      query.status = { $in: ["validated", "rejected"] };
    } else if (status) {
      query.status = status;
    }

    if (search) {
      const users = await User.find({
        $or: [
          { nom: { $regex: search, $options: "i" } },
          { email: { $regex: search, $options: "i" } },
        ],
      }).select("_id");

      const userIds = users.map((u) => u._id);

      const companies = await Company.find({
        name: { $regex: search, $options: "i" },
      }).select("_id");
      const companyIds = companies.map((c) => c._id);

      query.$or = [
        { userId: { $in: userIds } },
        { companyId: { $in: companyIds } },
      ];
    }

    const skip = (page - 1) * limit;

    const recruiters = await Recruiter.find(query)
      .populate({
        path: "userId",
        select: "nom email createdAt",
      })
      .populate("companyId", "name status logo")
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Recruiter.countDocuments(query);

    const enriched = recruiters
      .filter((r) => r.userId !== null)
      .map((r) => ({
        _id: r._id,
        userId: r.userId._id,
        nom: r.userId.nom,
        email: r.userId.email,
        createdAt: r.userId.createdAt,

        entrepriseId: r.companyId?._id,
        entreprise: r.companyId?.name || "Inconnue",
        entrepriseStatus: r.companyId?.status,
        entrepriseLogo: r.companyId?.logo,
        entrepriseDetails: r.companyId,

        position: r.position,
        telephone: r.telephone || "Non renseignÃ©",
        recruiterStatus: r.status,
        isAdmin: r.isAdmin,
        rejectionReason: r.rejectionReason,

        validationRequests: r.validationRequests,

        lastRequestDate:
          r.validationRequests.length > 0
            ? r.validationRequests[r.validationRequests.length - 1].createdAt
            : null,
      }));

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const cancelValidationRequest = async (req, res) => {
  try {
    const { id } = req.params;

    const recruiter = await Recruiter.findById(id);
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    recruiter.status = "pending_validation";

    recruiter.validationRequests = recruiter.validationRequests.filter(
      (req) => req.status !== "pending"
    );

    await recruiter.save();

    await logAdminAction(
      req.user.id,
      "recruiter_request_canceled",
      { type: "recruiter", id: recruiter._id },
      {},
      req
    );

    res.json({ msg: "Demande annulÃ©e, recruteur replacÃ© en attente âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanyDetailsAdmin = async (req, res) => {
  try {
    const { companyId } = req.params;
    const company = await Company.findById(companyId);

    if (!company)
      return res.status(404).json({ msg: "Entreprise introuvable" });

    const recruiterCount = await Recruiter.countDocuments({ companyId });
    const offerCount = await Offer.countDocuments({ companyId });

    res.json({
      ...company.toObject(),
      stats: {
        recruiters: recruiterCount,
        offers: offerCount,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const validateRecruiter = async (req, res) => {
  try {
    const { id } = req.params;

    let recruiter = await Recruiter.findById(id).populate("companyId");
    if (!recruiter) {
      recruiter = await Recruiter.findOne({ userId: id }).populate("companyId");
    }

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    const user = await User.findById(recruiter.userId);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable" });
    }

    recruiter.status = "validated";

    const existingAdmins = await Recruiter.countDocuments({
      companyId: recruiter.companyId._id,
      status: "validated",
      isAdmin: true,
    });

    if (existingAdmins === 0 && recruiter.companyId.status === "active") {
      recruiter.isAdmin = true;
      recruiter.permissions.editCompany = true;
      recruiter.permissions.manageTeam = true;

      await Notification.create({
        userId: user._id,
        message: `FÃ©licitations ! Vous Ãªtes le premier recruteur validÃ© de "${recruiter.companyId.name}" et devenez automatiquement administrateur de l'entreprise.`,
        type: "validation",
      });
    }

    await recruiter.save();

    await Notification.create({
      userId: user._id,
      message:
        "FÃ©licitations ! Votre compte recruteur a Ã©tÃ© validÃ©. Vous pouvez maintenant publier des offres.",
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_validated",
      { type: "recruiter", id: recruiter._id },
      { isFirstAdmin: recruiter.isAdmin },
      req
    );

    res.json({
      msg: "Recruteur validÃ© avec succÃ¨s âœ…",
      isCompanyAdmin: recruiter.isAdmin,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectRecruiter = async (req, res) => {
  try {
    const { id } = req.params;
    const { message } = req.body;

    let recruiter = await Recruiter.findById(id);
    if (!recruiter) {
      recruiter = await Recruiter.findOne({ userId: id });
    }

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    recruiter.status = "rejected";
    recruiter.rejectionReason = message || "Non spÃ©cifiÃ©e";
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId,
      message: `Votre compte recruteur a Ã©tÃ© rejetÃ©. Raison : ${
        message || "Non spÃ©cifiÃ©e"
      }`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_rejected",
      { type: "recruiter", id: recruiter._id },
      { reason: message },
      req
    );

    res.json({ msg: "Recruteur rejetÃ© âŒ" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllAdmins = async (req, res) => {
  try {
    const admins = await Admin.find()
      .populate("userId", "nom email createdAt")
      .populate("createdBy", "nom")
      .sort({ createdAt: -1 });

    res.json(admins);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const suspendAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason, until } = req.body;

    if (id === req.user.id) {
      return res
        .status(400)
        .json({ msg: "Vous ne pouvez pas vous suspendre vous-mÃªme." });
    }

    const targetAdmin = await Admin.findOne({ userId: id });
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin introuvable" });
    }

    if (targetAdmin.label === "super_admin") {
      return res
        .status(403)
        .json({ msg: "Impossible de suspendre un super admin" });
    }

    targetAdmin.status = "suspended";
    targetAdmin.suspensionReason = reason;
    targetAdmin.suspendedUntil = until ? new Date(until) : null;
    await targetAdmin.save();

    await logAdminAction(
      req.user.id,
      "admin_suspended",
      { type: "admin", id: targetAdmin._id },
      { reason, until },
      req
    );

    res.json({ msg: "Administrateur suspendu â›”" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getPendingCompanies = async (req, res) => {
  try {
    const companies = await Company.find({ status: "pending" }).sort({
      createdAt: -1,
    });
    res.json(companies);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const validateCompany = async (req, res) => {
  try {
    const { id } = req.params;
    const company = await Company.findByIdAndUpdate(
      id,
      { status: "active" },
      { new: true }
    );

    if (!company)
      return res.status(404).json({ msg: "Entreprise introuvable" });

    res.json({ msg: "Entreprise validÃ©e avec succÃ¨s âœ…", company });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectCompany = async (req, res) => {
  try {
    const { id } = req.params;
    const company = await Company.findByIdAndUpdate(
      id,
      { status: "rejected" },
      { new: true }
    );

    if (!company)
      return res.status(404).json({ msg: "Entreprise introuvable" });

    res.json({ msg: "Entreprise rejetÃ©e âŒ", company });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const createAdmin = async (req, res) => {
  try {
    const { nom, email, motDePasse, forceVerify } = req.body;

    const exist = await User.findOne({ email });
    if (exist) return res.status(400).json({ msg: "Email dÃ©jÃ  utilisÃ©" });

    const hash = await bcrypt.hash(motDePasse, 10);

    const emailVerified = forceVerify !== undefined ? forceVerify : true;

    const user = await User.create({
      nom,
      email,
      motDePasse: hash,
      role: "admin",
      statutValidation: "validÃ©",
      emailVerified: emailVerified,
    });

    await Admin.create({ userId: user._id });

    res.status(201).json({ msg: "Nouvel administrateur crÃ©Ã© âœ…", admin: user });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteAdmin = async (req, res) => {
  try {
    const { id } = req.params;

    if (id === req.user.id)
      return res
        .status(400)
        .json({ msg: "Vous ne pouvez pas vous supprimer vous-mÃªme." });

    const adminUser = await User.findById(id);
    if (!adminUser || adminUser.role !== "admin")
      return res.status(404).json({ msg: "Admin introuvable" });

    await User.findByIdAndDelete(id);
    await Admin.findOneAndDelete({ userId: id });

    res.json({ msg: "Administrateur supprimÃ© ðŸ—‘ï¸" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const banUser = async (req, res) => {
  try {
    const { id } = req.params;
    const { raison } = req.body;

    const user = await User.findById(id);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });
    if (user.role === "admin")
      return res.status(403).json({ msg: "Impossible de bannir un admin." });

    user.accountStatus = "banned";
    user.suspensionReason = raison || "Non respect des conditions.";
    await user.save();

    await Notification.create({
      userId: user._id,
      message: `Votre compte a Ã©tÃ© dÃ©sactivÃ©. Raison : ${
        raison || "Non respect des conditions."
      }`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "user_banned",
      { type: "user", id: user._id },
      { reason: raison },
      req
    );

    res.json({ msg: `Utilisateur ${user.nom} a Ã©tÃ© banni â›”` });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const unBanUser = async (req, res) => {
  try {
    const { id } = req.params;

    const user = await User.findById(id);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });

    if (user.role === "admin") {
      return res.status(400).json({ msg: "Action inutile sur un admin." });
    }

    if (user.accountStatus === "active") {
      return res.status(400).json({ msg: "Cet utilisateur n'est pas banni." });
    }

    user.accountStatus = "active";
    user.suspensionReason = undefined;
    user.suspendedUntil = undefined;
    await user.save();

    await Notification.create({
      userId: user._id,
      message:
        "Bonne nouvelle ! Votre compte a Ã©tÃ© rÃ©activÃ© par l'administration. Vous pouvez Ã  nouveau vous connecter.",
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "user_unbanned",
      { type: "user", id: user._id },
      {},
      req
    );

    res.json({ msg: `L'utilisateur ${user.nom} a Ã©tÃ© dÃ©banni et rÃ©activÃ© âœ…` });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllUsers = async (req, res) => {
  try {
    const {
      role,
      status,
      search,
      wilaya,
      proposable,
      emailVerified,
      page = 1,
      limit = 20,
    } = req.query;

    let query = {};
    if (role) query.role = role;
    if (status) query.accountStatus = status;
    if (emailVerified) query.emailVerified = emailVerified === "true";

    if (search) {
      query.$or = [
        { nom: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } },
      ];
    }

    const skip = (page - 1) * limit;

    const [users, total] = await Promise.all([
      User.find(query)
        .select("-motDePasse")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean(),
      User.countDocuments(query),
    ]);

    const userIds = users.map((u) => u._id);

    const [candidates, recruiters] = await Promise.all([
      Candidate.find({ userId: { $in: userIds } })
        .select(
          "userId telephone residence autoriserProposition desiredPosition"
        )
        .lean(),
      Recruiter.find({ userId: { $in: userIds } })
        .populate("companyId", "name")
        .select("userId status companyId")
        .lean(),
    ]);

    const candidateMap = new Map(
      candidates.map((c) => [c.userId.toString(), c])
    );
    const recruiterMap = new Map(
      recruiters.map((r) => [r.userId.toString(), r])
    );

    const recruiterIds = recruiters.map((r) => r._id);
    const offerCounts = await Offer.aggregate([
      { $match: { recruteurId: { $in: recruiterIds } } },
      { $group: { _id: "$recruteurId", count: { $sum: 1 } } },
    ]);

    const offerCountMap = new Map(
      offerCounts.map((o) => [o._id.toString(), o.count])
    );

    let enriched = users.map((u) => {
      const userId = u._id.toString();
      let details = {};

      if (u.role === "candidat") {
        const cand = candidateMap.get(userId);
        if (cand) {
          details = {
            telephone: cand.telephone,
            wilaya: cand.residence?.wilaya || null,
            autoriserProposition: cand.autoriserProposition,
            poste: cand.desiredPosition,
          };
        }
      }

      if (u.role === "recruteur") {
        const rec = recruiterMap.get(userId);
        if (rec) {
          details = {
            entreprise: rec.companyId?.name || "Inconnue",
            recruiterStatus: rec.status,
            offres: offerCountMap.get(rec._id.toString()) || 0,
          };
        }
      }

      return {
        ...u,
        accountStatus: u.accountStatus,
        details,
      };
    });

    if (wilaya) {
      enriched = enriched.filter(
        (u) =>
          u.details?.wilaya &&
          u.details.wilaya.toLowerCase() === wilaya.toLowerCase()
      );
    }

    if (proposable === "true") {
      enriched = enriched.filter(
        (u) => u.details?.autoriserProposition === true
      );
    }

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const sendMessageToUser = async (req, res) => {
  try {
    const { id } = req.params;
    const { message } = req.body;

    await Notification.create({
      userId: id,
      message: `Message de l'administration : ${message}`,
      type: "info",
    });

    res.json({ msg: "Notification envoyÃ©e âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteOfferAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const { motif } = req.body;

    const offer = await Offer.findById(id).populate("recruteurId");
    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    if (offer.recruteurId && offer.recruteurId.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Votre offre "${offer.titre}" a Ã©tÃ© supprimÃ©e. Motif : ${
          motif || "Non conforme"
        }`,
        type: "alerte",
      });
    }

    await Offer.findByIdAndDelete(id);

    res.json({ msg: "Offre supprimÃ©e et recruteur notifiÃ© ðŸ—‘ï¸" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getGlobalStats = async (req, res) => {
  try {
    const now = new Date();
    const fifteenMinutesAgo = new Date(now - 15 * 60 * 1000);
    const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);

    const [
      onlineUsers,
      totalUsers,
      newUsersThisMonth,
      usersByRole,
      totalOffres,
      offresActives,
      pendingOffers,
      newOffersThisMonth,
      applicationStats,
      pendingRecruiters,
      pendingCompanies,
      openTickets,
      recentAdminActions,
    ] = await Promise.all([
      User.countDocuments({ derniereConnexion: { $gt: fifteenMinutesAgo } }),
      User.countDocuments(),
      User.countDocuments({ createdAt: { $gte: thirtyDaysAgo } }),
      User.aggregate([{ $group: { _id: "$role", count: { $sum: 1 } } }]),
      Offer.countDocuments(),
      Offer.countDocuments({ actif: true, validationStatus: "approved" }),
      Offer.countDocuments({ validationStatus: "pending" }),
      Offer.countDocuments({ createdAt: { $gte: thirtyDaysAgo } }),
      Application.aggregate([
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),

      Recruiter.countDocuments({
        status: { $in: ["pending_validation", "pending_revalidation"] },
      }),
      Company.countDocuments({ status: "pending" }),
      SupportTicket.countDocuments({
        status: { $in: ["open", "in_progress"] },
      }),
      AdminLog.find()
        .populate("adminId", "nom")
        .sort({ createdAt: -1 })
        .limit(10),
    ]);

    const roleMap = {};
    usersByRole.forEach((r) => {
      roleMap[r._id] = r.count;
    });

    const statsCandidatures = {};
    applicationStats.forEach((s) => {
      statsCandidatures[s._id] = s.count;
    });

    const pendingTasks = {
      recruiters: pendingRecruiters,
      companies: 0,
      offers: pendingOffers,
      tickets: openTickets,
      total: pendingRecruiters + pendingOffers + openTickets,
    };

    res.json({
      users: {
        online: onlineUsers,
        total: totalUsers,
        newThisMonth: newUsersThisMonth,
        byRole: roleMap,
      },
      offres: {
        total: totalOffres,
        actives: offresActives,
        pending: pendingOffers,
        newThisMonth: newOffersThisMonth,
      },
      candidatures: statsCandidatures,
      pendingTasks,
      recentAdminActions,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getTrends = async (req, res) => {
  try {
    const { period = "30" } = req.query;
    const days = parseInt(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const [rawUsers, rawOffers, rawApplications] = await Promise.all([
      User.aggregate([
        { $match: { createdAt: { $gte: startDate } } },
        {
          $group: {
            _id: {
              date: {
                $dateToString: { format: "%Y-%m-%d", date: "$createdAt" },
              },
            },
            count: { $sum: 1 },
          },
        },
      ]),

      Offer.aggregate([
        { $match: { createdAt: { $gte: startDate } } },
        {
          $group: {
            _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
            count: { $sum: 1 },
          },
        },
      ]),

      Application.aggregate([
        { $match: { datePostulation: { $gte: startDate } } },
        {
          $group: {
            _id: {
              $dateToString: { format: "%Y-%m-%d", date: "$datePostulation" },
            },
            count: { $sum: 1 },
          },
        },
      ]),
    ]);

    const statsMap = new Map();
    for (let i = 0; i < days; i++) {
      const d = new Date();
      d.setDate(d.getDate() - i);
      const dateStr = d.toISOString().split("T")[0];

      statsMap.set(dateStr, {
        date: dateStr,
        users: 0,
        offers: 0,
        applications: 0,
      });
    }

    rawUsers.forEach((u) => {
      const date = u._id.date;
      if (statsMap.has(date)) {
        statsMap.get(date).users += u.count;
      }
    });

    rawOffers.forEach((o) => {
      const date = o._id;
      if (statsMap.has(date)) {
        statsMap.get(date).offers += o.count;
      }
    });

    rawApplications.forEach((a) => {
      const date = a._id;
      if (statsMap.has(date)) {
        statsMap.get(date).applications += a.count;
      }
    });

    const chartData = Array.from(statsMap.values()).sort(
      (a, b) => new Date(a.date) - new Date(b.date)
    );

    res.json({
      data: chartData,
      period: days,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getManualSelectionOffers = async (req, res) => {
  try {
    const {
      minProposals,
      maxProposals,
      startDate,
      endDate,
      sortBy = "datePublication",
    } = req.query;

    const pipeline = [
      {
        $match: {
          actif: true,
          candidateSearchMode: "manual",
          validationStatus: "approved",
        },
      },
    ];

    if (startDate || endDate) {
      const dateFilter = {};
      if (startDate) dateFilter.$gte = new Date(startDate);
      if (endDate) dateFilter.$lte = new Date(endDate);
      pipeline[0].$match.datePublication = dateFilter;
    }

    pipeline.push({
      $lookup: {
        from: "applications",
        let: { offerId: "$_id" },
        pipeline: [
          {
            $match: {
              $expr: {
                $and: [
                  { $eq: ["$offerId", "$$offerId"] },
                  { $eq: ["$recommandeParAdmin", true] },
                ],
              },
            },
          },
          { $count: "count" },
        ],
        as: "adminProposals",
      },
    });

    pipeline.push({
      $addFields: {
        proposalCount: {
          $ifNull: [{ $arrayElemAt: ["$adminProposals.count", 0] }, 0],
        },
      },
    });

    if (minProposals !== undefined || maxProposals !== undefined) {
      const countMatch = {};
      if (minProposals !== undefined) countMatch.$gte = parseInt(minProposals);
      if (maxProposals !== undefined) countMatch.$lte = parseInt(maxProposals);
      pipeline.push({ $match: { proposalCount: countMatch } });
    }

    pipeline.push(
      {
        $lookup: {
          from: "recruiters",
          localField: "recruteurId",
          foreignField: "_id",
          as: "recruteur",
        },
      },
      { $unwind: "$recruteur" },
      {
        $lookup: {
          from: "companies",
          localField: "companyId",
          foreignField: "_id",
          as: "company",
        },
      },
      { $unwind: "$company" }
    );

    let sortStage = {};
    if (sortBy === "lastModified") {
      sortStage = { updatedAt: -1 };
    } else {
      sortStage = { datePublication: -1 };
    }
    pipeline.push({ $sort: sortStage });

    const offers = await Offer.aggregate(pipeline);

    res.json(offers);
  } catch (err) {
    console.error("Erreur Manual Matching:", err);
    res.status(500).json({ msg: err.message });
  }
};

export const proposeCandidateToOffer = async (req, res) => {
  try {
    const { candidatId, offreId } = req.body;

    const offer = await Offer.findById(offreId).populate("recruteurId");
    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    let candidate = await Candidate.findById(candidatId).populate("userId");

    if (!candidate) {
      candidate = await Candidate.findOne({ userId: candidatId }).populate(
        "userId"
      );
    }

    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    if (!candidate.userId?.emailVerified) {
      return res.status(400).json({ msg: "Email candidat non vÃ©rifiÃ©." });
    }

    if (!candidate.autoriserProposition) {
      return res
        .status(403)
        .json({ msg: "Ce candidat refuse les propositions." });
    }

    if (!candidate.cvs || candidate.cvs.length === 0) {
      return res.status(400).json({
        msg: "Impossible de proposer ce candidat : il n'a pas de CV.",
      });
    }

    const existingApp = await Application.findOne({
      offerId: offreId,
      candidateId: candidate._id,
    });

    if (existingApp) {
      return res.status(400).json({ msg: "Candidat dÃ©jÃ  positionnÃ©." });
    }
    const lastCv = candidate.cvs[candidate.cvs.length - 1].url;

    await Application.create({
      offerId: offreId,
      candidateId: candidate._id,
      cvUrl: lastCv,

      candidateStatus: "envoyee",
      recruiterStatus: "nouvelle",

      source: "admin_proposal",
      proposedBy: req.user.id,
      proposedAt: new Date(),

      coverLetter:
        "Recommandation Admin : Ce profil correspond parfaitement aux critÃ¨res de lâ€™offre.",

      offerSnapshot: {
        titre: offer.titre,
        companyId: offer.companyId,
        type: offer.type,
      },
    });

    offer.nombreCandidatures += 1;
    await offer.save();

    if (offer.recruteurId?.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Un administrateur vous a proposÃ© un candidat recommandÃ© (${candidate.userId.nom}) pour votre offre "${offer.titre}".`,
        type: "validation",
      });
    }

    await Notification.create({
      userId: candidate.userId._id,
      message: `Bonne nouvelle ! Votre profil a Ã©tÃ© recommandÃ© par un administrateur pour l'offre "${offer.titre}".`,
      type: "info",
    });

    return res.json({ msg: "Candidat proposÃ© avec succÃ¨s âœ…" });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ msg: err.message });
  }
};

export const getAdminLogs = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      adminId,
      action,
      startDate,
      endDate,
    } = req.query;

    let query = {};
    if (adminId) query.adminId = adminId;
    if (action) query.action = action;
    if (startDate || endDate) {
      query.createdAt = {};
      if (startDate) query.createdAt.$gte = new Date(startDate);
      if (endDate) query.createdAt.$lte = new Date(endDate);
    }

    const logs = await AdminLog.find(query)
      .populate("adminId", "nom email")
      .sort({ createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await AdminLog.countDocuments(query);

    res.json({
      data: logs,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getPendingOffers = async (req, res) => {
  try {
    const { page = 1, limit = 20, sortBy = "createdAt" } = req.query;

    const offers = await Offer.find({ validationStatus: "pending" })
      .populate("companyId", "name logo")
      .populate({
        path: "recruteurId",
        select: "userId position",
        populate: { path: "userId", select: "nom email" },
      })
      .sort({ [sortBy]: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await Offer.countDocuments({ validationStatus: "pending" });

    res.json({
      data: offers,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const approveOffer = async (req, res) => {
  try {
    const { id } = req.params;

    const offer = await Offer.findById(id).populate("recruteurId");
    if (!offer) return res.status(404).json({ msg: "Offre introuvable." });

    offer.validationStatus = "approved";
    offer.actif = true;
    offer.datePublication = new Date();
    offer.validationHistory.push({
      status: "approved",
      adminId: req.user.id,
    });
    await offer.save();

    if (offer.recruteurId && offer.recruteurId.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Votre offre "${offer.titre}" a Ã©tÃ© approuvÃ©e et est maintenant visible.`,
        type: "validation",
      });
    }

    await logAdminAction(
      req.user.id,
      "offer_approved",
      { type: "offer", id: offer._id },
      {},
      req
    );

    res.json({ msg: "Offre approuvÃ©e âœ…", offer });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectOffer = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason, requestChanges } = req.body;

    const offer = await Offer.findById(id).populate("recruteurId");
    if (!offer) return res.status(404).json({ msg: "Offre introuvable." });

    offer.validationStatus = requestChanges ? "changes_requested" : "rejected";
    offer.rejectionReason = reason;
    offer.validationHistory.push({
      status: offer.validationStatus,
      message: reason,
      adminId: req.user.id,
    });
    await offer.save();

    const msgType = requestChanges
      ? `Des modifications sont demandÃ©es pour votre offre "${offer.titre}": ${reason}`
      : `Votre offre "${offer.titre}" a Ã©tÃ© refusÃ©e: ${reason}`;

    if (offer.recruteurId && offer.recruteurId.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: msgType,
        type: "alerte",
      });
    }

    await logAdminAction(
      req.user.id,
      requestChanges ? "offer_changes_requested" : "offer_rejected",
      { type: "offer", id: offer._id },
      { reason },
      req
    );

    res.json({
      msg: requestChanges ? "Modifications demandÃ©es." : "Offre refusÃ©e.",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const requestRecruiterDocuments = async (req, res) => {
  try {
    const { recruiterId } = req.params;
    const { type, message, requiredDocuments, requiredFields } = req.body;

    const recruiter = await Recruiter.findById(recruiterId).populate("userId");
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    recruiter.status =
      type === "document" ? "pending_documents" : "pending_info";
    recruiter.validationRequests.push({
      type,
      message,
      requiredDocuments,
      requiredFields,
      status: "pending",
    });
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Action requise : ${message}`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_documents_requested",
      { type: "recruiter", id: recruiter._id },
      { requestType: type, message },
      req
    );

    res.json({ msg: "Demande envoyÃ©e au recruteur âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAdminPermissions = async (req, res) => {
  try {
    const { id } = req.params;
    const { permissions } = req.body;

    const targetAdmin = await Admin.findOne({ userId: id });
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin introuvable" });
    }

    if (targetAdmin.label === "super_admin") {
      return res.status(403).json({
        msg: "Impossible de modifier les permissions d'un super admin",
      });
    }

    targetAdmin.permissions = { ...targetAdmin.permissions, ...permissions };
    await targetAdmin.save();

    await logAdminAction(
      req.user.id,
      "admin_permissions_updated",
      { type: "admin", id: targetAdmin._id },
      { newPermissions: permissions },
      req
    );

    res.json({ msg: "Permissions mises Ã  jour âœ…", admin: targetAdmin });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAdminLabel = async (req, res) => {
  try {
    const { id } = req.params;
    const { label } = req.body;

    const validLabels = [
      "super_admin",
      "support",
      "technical",
      "operational",
      "recruitment",
      "moderation",
      "product",
    ];

    if (!validLabels.includes(label)) {
      return res.status(400).json({ msg: "Label invalide" });
    }

    const targetAdmin = await Admin.findOne({ userId: id });
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin introuvable" });
    }

    const oldLabel = targetAdmin.label;
    targetAdmin.label = label;
    await targetAdmin.save();

    await logAdminAction(
      req.user.id,
      "admin_label_changed",
      { type: "admin", id: targetAdmin._id },
      { oldLabel, newLabel: label },
      req
    );

    res.json({ msg: "Label mis Ã  jour âœ…", admin: targetAdmin });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const createCompanyByAdmin = async (req, res) => {
  try {
    const { name, website, description, industry, location, size, logo } =
      req.body;

    if (!name) {
      return res
        .status(400)
        .json({ msg: "Le nom de l'entreprise est obligatoire." });
    }

    const existingCompany = await Company.findOne({
      name: { $regex: new RegExp(`^${name}$`, "i") },
    });

    if (existingCompany) {
      return res
        .status(400)
        .json({ msg: "Une entreprise avec ce nom existe dÃ©jÃ ." });
    }

    const company = await Company.create({
      name,
      website,
      description,
      industry,
      location,
      size,
      logo,
      status: "active",
    });

    await logAdminAction(
      req.user.id,
      "company_created_by_admin",
      { type: "company", id: company._id },
      { name },
      req
    );

    res.status(201).json({
      msg: "Entreprise crÃ©Ã©e avec succÃ¨s âœ…",
      company,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanyRecruiters = async (req, res) => {
  try {
    const { companyId } = req.params;

    const company = await Company.findById(companyId);
    if (!company) {
      return res.status(404).json({ msg: "Entreprise introuvable." });
    }

    const recruiters = await Recruiter.find({ companyId })
      .populate("userId", "nom email createdAt")
      .sort({ isAdmin: -1, createdAt: 1 });

    res.json({
      company: {
        _id: company._id,
        name: company.name,
        status: company.status,
      },
      recruiters,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const assignCompanyAdmin = async (req, res) => {
  try {
    const { companyId, recruiterId } = req.body;

    const company = await Company.findById(companyId);
    if (!company) {
      return res.status(404).json({ msg: "Entreprise introuvable." });
    }

    const recruiter = await Recruiter.findById(recruiterId).populate("userId");
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    if (recruiter.companyId.toString() !== companyId) {
      return res.status(400).json({
        msg: "Ce recruteur n'appartient pas Ã  cette entreprise.",
      });
    }

    if (recruiter.status !== "validated") {
      return res.status(400).json({
        msg: "Le recruteur doit Ãªtre validÃ© avant de devenir administrateur.",
      });
    }

    recruiter.isAdmin = true;
    recruiter.permissions.editCompany = true;
    recruiter.permissions.manageTeam = true;
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Vous Ãªtes maintenant administrateur de l'entreprise "${company.name}".`,
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "company_admin_assigned",
      { type: "recruiter", id: recruiter._id },
      { companyId, companyName: company.name },
      req
    );

    res.json({
      msg: `${recruiter.userId.nom} est maintenant administrateur de ${company.name} âœ…`,
      recruiter,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const removeCompanyAdmin = async (req, res) => {
  try {
    const { recruiterId } = req.params;

    const recruiter = await Recruiter.findById(recruiterId)
      .populate("userId")
      .populate("companyId");

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    if (!recruiter.isAdmin) {
      return res.status(400).json({
        msg: "Ce recruteur n'est pas administrateur d'entreprise.",
      });
    }

    recruiter.isAdmin = false;
    recruiter.permissions.editCompany = false;
    recruiter.permissions.manageTeam = false;
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Vous n'Ãªtes plus administrateur de l'entreprise "${recruiter.companyId.name}".`,
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "company_admin_removed",
      { type: "recruiter", id: recruiter._id },
      {
        companyId: recruiter.companyId._id,
        companyName: recruiter.companyId.name,
      },
      req
    );

    res.json({
      msg: `${recruiter.userId.nom} n'est plus administrateur âš ï¸`,
      recruiter,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateCompanyByAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, website, description, industry, location, size, logo } =
      req.body;

    const company = await Company.findByIdAndUpdate(
      id,
      { name, website, description, industry, location, size, logo },
      { new: true }
    );

    if (!company) {
      return res.status(404).json({ msg: "Entreprise introuvable." });
    }

    await logAdminAction(
      req.user.id,
      "company_updated_by_admin",
      { type: "company", id: company._id },
      { updates: req.body },
      req
    );

    res.json({ msg: "Entreprise mise Ã  jour âœ…", company });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const requestMultipleValidationItems = async (req, res) => {
  try {
    const { recruiterId } = req.params;
    const { requests } = req.body;

    const recruiter = await Recruiter.findById(recruiterId).populate("userId");
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    requests.forEach((request) => {
      recruiter.validationRequests.push({
        type: request.type,
        message: request.message,
        requiredDocuments: request.requiredDocuments || 0,
        requiredFields: request.requiredFields || [],
        status: "pending",
      });
    });

    const hasDocRequest = requests.some((r) => r.type === "document");
    const hasInfoRequest = requests.some((r) => r.type === "information");

    if (hasDocRequest && hasInfoRequest) {
      recruiter.status = "pending_info_and_documents";
    } else if (hasDocRequest) {
      recruiter.status = "pending_documents";
    } else if (hasInfoRequest) {
      recruiter.status = "pending_info";
    } else {
      return res.status(400).json({ msg: "Aucune demande valide reÃ§ue." });
    }

    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Action requise : Des informations ou documents vous sont demandÃ©s.`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_multiple_requests",
      { type: "recruiter", id: recruiter._id },
      { requestCount: requests.length, newStatus: recruiter.status },
      req
    );

    res.json({
      msg: `Demandes envoyÃ©es. Statut mis Ã  jour vers : ${recruiter.status} âœ…`,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllCompanies = async (req, res) => {
  try {
    const { page = 1, limit = 20, search, status } = req.query;

    let query = {};

    if (status) {
      query.status = status;
    }

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { industry: { $regex: search, $options: "i" } },
      ];
    }

    const skip = (page - 1) * limit;

    const companies = await Company.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Company.countDocuments(query);

    const enrichedCompanies = await Promise.all(
      companies.map(async (company) => {
        const recruitersCount = await Recruiter.countDocuments({
          companyId: company._id,
        });
        return {
          ...company.toObject(),
          recruitersCount,
        };
      })
    );

    res.json({
      data: enrichedCompanies,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const getOfferDetailsAdmin = async (req, res) => {
  try {
    const { id } = req.params;

    const offer = await Offer.findById(id)
      .populate("companyId", "name logo status website location")
      .populate({
        path: "recruteurId",
        select: "userId position status telephone",
        populate: { path: "userId", select: "nom email" },
      });

    if (!offer) return res.status(404).json({ msg: "Offre introuvable." });

    res.json(offer);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const updateOfferByAdmin = async (req, res) => {
  try {
    const { id } = req.params;

    const offer = await Offer.findByIdAndUpdate(
      id,
      { $set: req.body },
      { new: true }
    );

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    await logAdminAction(
      req.user.id,
      "offer_updated_by_admin",
      { type: "offer", id: offer._id },
      { updates: req.body },
      req
    );

    res.json({ msg: "Offre modifiÃ©e par l'admin âœ…", offer });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const toggleOfferVisibility = async (req, res) => {
  try {
    const { id } = req.params;
    const { actif } = req.body;

    const offer = await Offer.findByIdAndUpdate(
      id,
      { actif: actif },
      { new: true }
    );

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    await logAdminAction(
      req.user.id,
      actif ? "offer_activated_admin" : "offer_deactivated_admin",
      { type: "offer", id: offer._id },
      {},
      req
    );

    res.json({
      msg: `Offre ${actif ? "activÃ©e" : "dÃ©sactivÃ©e"} avec succÃ¨s`,
      offer,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateDetailsAdmin = async (req, res) => {
  const candidate = await Candidate.findById(req.params.id).populate("userId");
  res.json(candidate);
};


=== controllers\adminSupportController.js ===
import SupportTicket from "../models/SupportTicket.js";
import Admin from "../models/Admin.js";
import Notification from "../models/Notification.js";
import { logAdminAction } from "../models/AdminLog.js";

export const getTicketsByLabel = async (req, res) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin) {
      return res.status(403).json({ msg: "Admin introuvable." });
    }

    const { status, priority, page = 1, limit = 20 } = req.query;

    let query = {};

    if (admin.label !== "super_admin") {
      query.assignedToLabel = admin.label;
    }

    if (status) query.status = status;
    if (priority) query.priority = priority;

    const tickets = await SupportTicket.find(query)
      .populate("userId", "nom email role")
      .populate("assignedTo", "label")
      .sort({ priority: -1, createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await SupportTicket.countDocuments(query);

    res.json({
      data: tickets,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getTicketById = async (req, res) => {
  try {
    const { ticketId } = req.params;

    const ticket = await SupportTicket.findById(ticketId)
      .populate("userId", "nom email role")
      .populate("messages.adminId", "nom");

    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    res.json(ticket);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const respondToTicket = async (req, res) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });
    const { ticketId } = req.params;
    const { content, newStatus } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    if (!content) {
      return res.status(400).json({ msg: "Le contenu est obligatoire." });
    }

    const ticket = await SupportTicket.findById(ticketId);
    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    if (!ticket.assignedTo) {
      ticket.assignedTo = admin._id;
    }

    ticket.messages.push({
      from: "admin",
      content,
      adminId: req.user.id,
      attachments,
    });

    if (newStatus) {
      ticket.status = newStatus;
      if (newStatus === "resolved") ticket.resolvedAt = new Date();
      if (newStatus === "closed") ticket.closedAt = new Date();
    }

    await ticket.save();

    await Notification.create({
      userId: ticket.userId,
      message: `RÃ©ponse de l'administration sur votre ticket: "${ticket.subject}"`,
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "ticket_responded",
      { type: "ticket", id: ticket._id },
      { newStatus },
      req
    );

    res.json({ msg: "RÃ©ponse envoyÃ©e.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const reassignTicket = async (req, res) => {
  try {
    const { ticketId } = req.params;
    const { newLabel, newAdminId } = req.body;

    const ticket = await SupportTicket.findById(ticketId);
    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    if (newLabel) ticket.assignedToLabel = newLabel;
    if (newAdminId) {
      const targetAdmin = await Admin.findById(newAdminId);
      if (!targetAdmin) {
        return res.status(404).json({ msg: "Admin cible introuvable." });
      }
      ticket.assignedTo = newAdminId;
    }

    await ticket.save();

    await logAdminAction(
      req.user.id,
      "ticket_reassigned",
      { type: "ticket", id: ticket._id },
      { newLabel, newAdminId },
      req
    );

    res.json({ msg: "Ticket rÃ©assignÃ©.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const closeTicket = async (req, res) => {
  try {
    const { ticketId } = req.params;
    const { resolution } = req.body;

    const ticket = await SupportTicket.findById(ticketId);
    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    ticket.status = "closed";
    ticket.closedAt = new Date();

    if (resolution) {
      ticket.messages.push({
        from: "admin",
        content: `Ticket fermÃ©. RÃ©solution: ${resolution}`,
        adminId: req.user.id,
      });
    }

    await ticket.save();

    await Notification.create({
      userId: ticket.userId,
      message: `Votre ticket "${ticket.subject}" a Ã©tÃ© fermÃ©.`,
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "ticket_closed",
      { type: "ticket", id: ticket._id },
      { resolution },
      req
    );

    res.json({ msg: "Ticket fermÃ©.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\announcementController.js ===
import Announcement from "../models/Announcement.js";
import User from "../models/User.js";
import Admin from "../models/Admin.js";
import { logAdminAction } from "../models/AdminLog.js";

export const createAnnouncement = async (req, res) => {
  try {
    const {
      title,
      content,
      targetAudience,
      status,
      publishAt,
      expiresAt,
      priority,
      displayType,
    } = req.body;

    let finalStatus = status || "draft";
    if (
      status === "published" &&
      publishAt &&
      new Date(publishAt) > new Date()
    ) {
      finalStatus = "scheduled";
    }

    const announcement = await Announcement.create({
      title,
      content,
      targetAudience: targetAudience || "all",
      status: finalStatus,
      publishAt: publishAt ? new Date(publishAt) : null,
      expiresAt: expiresAt ? new Date(expiresAt) : null,
      priority: priority || "normal",
      displayType: displayType || "inline",
      createdBy: req.user.id,
    });

    await logAdminAction(
      req.user.id,
      "announcement_created",
      { type: "announcement", id: announcement._id },
      { title },
      req
    );

    res.status(201).json({ msg: "Annonce crÃ©Ã©e âœ…", announcement });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllAnnouncements = async (req, res) => {
  try {
    const { status, targetAudience, page = 1, limit = 20 } = req.query;

    let query = {};
    if (status) query.status = status;
    if (targetAudience) query.targetAudience = targetAudience;

    const announcements = await Announcement.find(query)
      .populate("createdBy", "nom email")
      .sort({ createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await Announcement.countDocuments(query);

    res.json({
      data: announcements,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getActiveAnnouncements = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    const now = new Date();

    let audienceFilter = ["all"];
    if (user.role === "admin") audienceFilter.push("admins");
    if (user.role === "recruteur") audienceFilter.push("recruiters");
    if (user.role === "candidat") audienceFilter.push("candidates");

    const announcements = await Announcement.find({
      status: "published",
      targetAudience: { $in: audienceFilter },
      $or: [{ publishAt: null }, { publishAt: { $lte: now } }],
      dismissedBy: { $ne: req.user.id },
    })
      .and([
        {
          $or: [{ expiresAt: null }, { expiresAt: { $gt: now } }],
        },
      ])
      .sort({ priority: -1, createdAt: -1 });

    res.json(announcements);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAnnouncement = async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;

    const announcement = await Announcement.findByIdAndUpdate(
      id,
      {
        ...updates,
        updatedBy: req.user.id,
      },
      { new: true }
    );

    if (!announcement) {
      return res.status(404).json({ msg: "Annonce introuvable" });
    }

    await logAdminAction(
      req.user.id,
      "announcement_updated",
      { type: "announcement", id: announcement._id },
      { updates },
      req
    );

    res.json({ msg: "Annonce mise Ã  jour âœ…", announcement });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteAnnouncement = async (req, res) => {
  try {
    const { id } = req.params;

    const announcement = await Announcement.findByIdAndDelete(id);
    if (!announcement) {
      return res.status(404).json({ msg: "Annonce introuvable" });
    }

    await logAdminAction(
      req.user.id,
      "announcement_deleted",
      { type: "announcement", id },
      { title: announcement.title },
      req
    );

    res.json({ msg: "Annonce supprimÃ©e ðŸ—‘ï¸" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const dismissAnnouncement = async (req, res) => {
  try {
    const { announcementId } = req.params;

    await Announcement.findByIdAndUpdate(announcementId, {
      $addToSet: { dismissedBy: req.user.id },
    });

    res.json({ msg: "Annonce masquÃ©e." });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const publishScheduledAnnouncements = async () => {
  const now = new Date();

  const publishedResult = await Announcement.updateMany(
    { status: "scheduled", publishAt: { $lte: now } },
    { $set: { status: "published" } }
  );

  const expiredResult = await Announcement.updateMany(
    { status: "published", expiresAt: { $lte: now } },
    { $set: { status: "expired" } }
  );

  console.log(
    `ðŸ“¢ Annonces publiÃ©es: ${publishedResult.modifiedCount}, expirÃ©es: ${expiredResult.modifiedCount}`
  );
};


=== controllers\authController.js ===
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import User from "../models/User.js";
import Candidate from "../models/Candidate.js";
import Recruiter from "../models/Recruiter.js";
import Company from "../models/Company.js";

const generateToken = (user) => {
  return jwt.sign(
    {
      id: user._id,
      role: user.role,
      emailVerified: user.emailVerified,
    },
    process.env.JWT_SECRET,
    { expiresIn: "1d" }
  );
};

export const register = async (req, res) => {
  try {
    const {
      nom,
      email,
      motDePasse,
      role,
      companyId,
      nouveauNomEntreprise,
      nouveauSiteWeb,
    } = req.body;

    const exist = await User.findOne({ email });
    if (exist) return res.status(400).json({ msg: "Email dÃ©jÃ  utilisÃ©" });

    const hash = await bcrypt.hash(motDePasse, 10);

    const user = await User.create({
      nom,
      email,
      motDePasse: hash,
      role,
      emailVerified: false,
      accountStatus: "active",
    });

    if (role === "recruteur") {
      let finalCompanyId;

      if (companyId) {
        const comp = await Company.findById(companyId);
        if (!comp) {
          await User.findByIdAndDelete(user._id);
          return res.status(400).json({ msg: "Entreprise introuvable" });
        }
        finalCompanyId = comp._id;
      } else if (nouveauNomEntreprise) {
        const newComp = await Company.create({
          name: nouveauNomEntreprise,
          website: nouveauSiteWeb,
          status: "pending",
        });
        finalCompanyId = newComp._id;
      } else {
        await User.findByIdAndDelete(user._id);
        return res
          .status(400)
          .json({ msg: "Vous devez sÃ©lectionner ou crÃ©er une entreprise." });
      }

      await Recruiter.create({
        userId: user._id,
        companyId: finalCompanyId,
        position: "Recruteur",
        status: "pending_validation",
        isAdmin: !companyId,
      });
    } else if (role === "candidat") {
      await Candidate.create({ userId: user._id });
    }

    const token = generateToken(user);
    res.status(201).json({ msg: "Inscription rÃ©ussie", token, user });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const login = async (req, res) => {
  try {
    const { email, motDePasse } = req.body;

    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur non trouvÃ©" });
    }

    const ok = await bcrypt.compare(motDePasse, user.motDePasse);
    if (!ok) {
      return res.status(401).json({ msg: "Mot de passe incorrect" });
    }

    if (!user.canLogin()) {
      if (user.accountStatus === "banned") {
        return res.status(403).json({
          msg: "Votre compte a Ã©tÃ© banni. Veuillez contacter l'administrateur.",
          code: "ACCOUNT_BANNED",
        });
      }
      if (user.accountStatus === "suspended") {
        return res.status(403).json({
          msg: `Votre compte est suspendu${
            user.suspendedUntil
              ? ` jusqu'au ${user.suspendedUntil.toLocaleDateString()}`
              : ""
          }.`,
          code: "ACCOUNT_SUSPENDED",
          reason: user.suspensionReason,
        });
      }
    }

    if (user.role === "recruteur") {
      if (!user.emailVerified) {
        return res.status(403).json({
          msg: "Veuillez confirmer votre email avant de vous connecter.",
          code: "EMAIL_NOT_VERIFIED",
          needEmailVerification: true,
        });
      }

      const recruiter = await Recruiter.findOne({ userId: user._id });
      if (recruiter) {
        if (recruiter.status === "rejected") {
          return res.status(403).json({
            msg: "Votre compte recruteur a Ã©tÃ© refusÃ©.",
            code: "RECRUITER_REJECTED",
            reason: recruiter.rejectionReason,
          });
        }

        if (recruiter.status !== "validated") {
          const token = generateToken(user);
          user.derniereConnexion = new Date();
          await user.save();

          return res.json({
            msg: "Connexion rÃ©ussie (accÃ¨s limitÃ©)",
            token,
            user: {
              id: user._id,
              email: user.email,
              role: user.role,
              emailVerified: user.emailVerified,
            },
            recruiterStatus: recruiter.status,
            limitedAccess: true,
            statusMessage: getRecruiterStatusMessage(recruiter.status),
          });
        }
      }
    }

    const token = generateToken(user);
    user.derniereConnexion = new Date();
    await user.save();

    res.json({
      msg: "Connexion rÃ©ussie âœ…",
      token,
      user: {
        id: user._id,
        email: user.email,
        role: user.role,
        emailVerified: user.emailVerified,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

function getRecruiterStatusMessage(status) {
  const messages = {
    pending_validation:
      "Votre compte est en attente de validation par un administrateur.",
    pending_documents:
      "Des documents vous ont Ã©tÃ© demandÃ©s. Veuillez les fournir.",
    pending_info: "Des informations complÃ©mentaires vous ont Ã©tÃ© demandÃ©es.",
    pending_info_and_documents:
      "Des informations et des documents vous ont Ã©tÃ© demandÃ©s.",
    pending_revalidation: "Vos rÃ©ponses sont en cours d'examen.",
  };
  return messages[status] || "Statut en attente.";
}

export const resendConfirmationCode = async (req, res) => {
  try {
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });

    if (user.emailVerified)
      return res.status(400).json({ msg: "Email dÃ©jÃ  vÃ©rifiÃ©" });

    console.log(
      `ðŸ“¨ [FAKE API] Code de confirmation envoyÃ© Ã  ${user.email} : 123456`
    );

    res.json({
      msg: "Code de confirmation envoyÃ© (Regardez la console serveur pour le code Fake) ðŸ“¨",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const verifyEmail = async (req, res) => {
  try {
    const { code } = req.body;
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });

    if (user.emailVerified)
      return res.status(400).json({ msg: "Email dÃ©jÃ  vÃ©rifiÃ©" });

    if (code === "123456") {
      user.emailVerified = true;
      await user.save();

      const newToken = generateToken(user);

      return res.json({
        msg: "E-mail confirmÃ© avec succÃ¨s ! ðŸŽ‰",
        token: newToken,
        user: {
          id: user._id,
          email: user.email,
          role: user.role,
          emailVerified: true,
        },
      });
    } else {
      return res.status(400).json({ msg: "Code incorrect. Essayez 123456." });
    }
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const changeEmail = async (req, res) => {
  try {
    const { newEmail } = req.body;
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });

    if (user.emailVerified) {
      return res.status(400).json({
        msg: "Impossible de changer l'email car il est dÃ©jÃ  vÃ©rifiÃ©.",
      });
    }

    const exist = await User.findOne({ email: newEmail });
    if (exist)
      return res.status(400).json({ msg: "Cet email est dÃ©jÃ  utilisÃ©." });

    user.email = newEmail;
    await user.save();

    res.json({
      msg: `Email mis Ã  jour vers ${newEmail}. Veuillez confirmer ce nouvel email.`,
      email: newEmail,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanies = async (req, res) => {
  try {
    const companies = await Company.find({ status: "active" }).select(
      "_id name"
    );
    res.json(companies);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\candidateApplicationController.js ===
import Application from "../models/Application.js";
import Interview from "../models/Interview.js";
import Conversation from "../models/Conversation.js";
import Candidate from "../models/Candidate.js";
import Notification from "../models/Notification.js";
import Offer from "../models/Offer.js";


export const getMyApplications = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable" });
    }

    const { status, page = 1, limit = 20 } = req.query;
    const skip = (page - 1) * limit;

    let query = { candidateId: candidate._id };

    if (status && status !== "all") {
      query.candidateStatus = status;
    }

    const [applications, total] = await Promise.all([
      Application.find(query)
        .sort({ datePostulation: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .populate({
          path: "offerId",
          select: "titre actif companyId type wilaya",
          populate: { path: "companyId", select: "name logo" },
        })
        .lean(),
      Application.countDocuments(query),
    ]);

    
    const enriched = await Promise.all(
      applications.map(async (app) => {
        const [conversation, upcomingInterview, interviewCount] =
          await Promise.all([
            Conversation.findOne({ applicationId: app._id })
              .select("unreadByCandidate lastMessageAt status")
              .lean(),
            Interview.findOne({
              applicationId: app._id,
              status: {
                $in: ["proposed", "confirmed", "rescheduled_by_recruiter"],
              },
              scheduledAt: { $gte: new Date() },
            })
              .sort({ scheduledAt: 1 })
              .lean(),
            Interview.countDocuments({ applicationId: app._id }),
          ]);

        return {
          _id: app._id,
          status: app.candidateStatus,
          source: app.source,
          datePostulation: app.datePostulation,
          offer: app.offerId
            ? {
                _id: app.offerId._id,
                titre: app.offerId.titre,
                entreprise: app.offerId.companyId?.name,
                logo: app.offerId.companyId?.logo,
                type: app.offerId.type,
                wilaya: app.offerId.wilaya,
                actif: app.offerId.actif,
              }
            : {
                titre: app.offerSnapshot?.titre,
                entreprise: app.offerSnapshot?.entrepriseNom,
                actif: false,
                deleted: true,
              },
          hasConversation: !!conversation,
          unreadMessages: conversation?.unreadByCandidate || 0,
          upcomingInterview: upcomingInterview
            ? {
                _id: upcomingInterview._id,
                scheduledAt: upcomingInterview.scheduledAt,
                type: upcomingInterview.type,
                status: upcomingInterview.status,
                needsResponse: upcomingInterview.status === "proposed",
              }
            : null,
          totalInterviews: interviewCount,
        };
      }),
    );

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getApplicationDetail = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { applicationId } = req.params;

    const application = await Application.findOne({
      _id: applicationId,
      candidateId: candidate._id,
    })
      .populate({
        path: "offerId",
        select: "titre description type wilaya companyId requirements",
        populate: { path: "companyId", select: "name logo website location" },
      })
      .lean();

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    
    const [conversation, interviews] = await Promise.all([
      Conversation.findOne({ applicationId })
        .select("messages unreadByCandidate status")
        .lean(),
      Interview.find({ applicationId }).sort({ scheduledAt: -1 }).lean(),
    ]);

    res.json({
      application: {
        _id: application._id,
        status: application.candidateStatus,
        source: application.source,
        cvUrl: application.cvUrl,
        coverLetter: application.coverLetter,
        datePostulation: application.datePostulation,
        dateDecision: application.dateDecision,
      },
      offer: application.offerId || application.offerSnapshot,
      conversation: conversation
        ? {
            hasConversation: true,
            unreadCount: conversation.unreadByCandidate,
            messageCount: conversation.messages?.length || 0,
            status: conversation.status,
          }
        : { hasConversation: false },
      interviews: interviews.map((i) => ({
        _id: i._id,
        type: i.type,
        scheduledAt: i.scheduledAt,
        duration: i.duration,
        location: i.location,
        meetingLink: i.meetingLink,
        status: i.status,
        proposedAlternative: i.proposedAlternative,
        preparationNotes: i.preparationNotes,
      })),
      statusHistory: application.statusHistory?.map((h) => ({
        status: h.candidateStatus,
        date: h.changedAt,
      })),
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const withdrawApplication = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { applicationId } = req.params;
    const { reason } = req.body;

    const application = await Application.findOne({
      _id: applicationId,
      candidateId: candidate._id,
    });

    if (!application)
      return res.status(404).json({ msg: "Candidature introuvable" });

    
    const terminalStatuses = ["retiree", "cancelled", "refusee"]; 
    if (terminalStatuses.includes(application.candidateStatus)) {
      return res
        .status(400)
        .json({ msg: "Action impossible pour le statut actuel." });
    }

    application.candidateStatus = "retiree";
    application.recruiterStatus = "retiree_par_candidat";
    application.withdrawnAt = new Date();
    application.withdrawReason = reason;

    application.statusHistory.push({
      candidateStatus: "retiree",
      recruiterStatus: "retiree_par_candidat",
      changedBy: req.user.id,
      note: "Retrait volontaire par le candidat",
    });

    await application.save();

    
    await Interview.updateMany(
      { applicationId, status: { $in: ["proposed", "confirmed"] } },
      { status: "cancelled_by_candidate" },
    );

    
    
    
    await Offer.findByIdAndUpdate(application.offerId, {
      $inc: { nombreCandidatures: -1 },
    });

    
    const offer = await Offer.findById(application.offerId).populate(
      "recruteurId",
    );
    if (offer?.recruteurId?.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Le candidat a retirÃ© sa candidature pour "${offer.titre}"`,
        type: "info",
      });
    }

    res.json({ msg: "Candidature retirÃ©e avec succÃ¨s" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const cancelApplication = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { applicationId } = req.params;

    const application = await Application.findOne({
      _id: applicationId,
      candidateId: candidate._id,
    });

    if (!application)
      return res.status(404).json({ msg: "Candidature introuvable" });

    
    if (
      application.candidateStatus !== "envoyee" ||
      application.seenByRecruiter
    ) {
      return res.status(403).json({
        msg: "Trop tard pour annuler. Utilisez l'option 'Retirer' si disponible.",
      });
    }

    application.candidateStatus = "cancelled";
    application.recruiterStatus = "annulee_par_candidat"; 

    application.statusHistory.push({
      candidateStatus: "cancelled",
      recruiterStatus: "annulee_par_candidat",
      changedBy: req.user.id,
      note: "Annulation par le candidat (avant lecture)",
    });

    await application.save();

    
    await Offer.findByIdAndUpdate(application.offerId, {
      $inc: { nombreCandidatures: -1 },
    });

    res.json({ msg: "Candidature annulÃ©e." });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const checkApplicationStatus = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable" });

    const { offerId } = req.params;

    const application = await Application.findOne({
      offerId: offerId,
      candidateId: candidate._id,
    }).populate("offerId", "allowRepostulation"); 

    
    if (!application) {
      return res.json({
        hasApplied: false,
        status: null,
        canCancel: false,
        canWithdraw: false,
        canRepostulate: false, 
        action: "apply", 
      });
    }

    const { candidateStatus, seenByRecruiter, recruiterStatus } = application;

    
    let canCancel = false;
    let canWithdraw = false;
    let canRepostulate = false;
    let action = "none"; 

    
    if (
      candidateStatus === "envoyee" &&
      !seenByRecruiter &&
      recruiterStatus === "nouvelle"
    ) {
      canCancel = true;
      action = "cancel";
    }

    
    
    const isEnCours =
      ["en_cours"].includes(candidateStatus) ||
      (candidateStatus === "envoyee" && seenByRecruiter);
    if (isEnCours) {
      canWithdraw = true;
      action = "withdraw";
    }

    
    
    if (["retiree", "cancelled"].includes(candidateStatus)) {
      if (application.offerId.allowRepostulation !== false) {
        
        canRepostulate = true;
        action = candidateStatus === "cancelled" ? "apply" : "repostulate"; 
      } else {
        action = "disabled"; 
      }
    }

    
    if (["retenue", "non_retenue"].includes(candidateStatus)) {
      action = "finished";
    }

    res.json({
      hasApplied: true,
      applicationId: application._id,
      status: candidateStatus,
      recruiterStatus: recruiterStatus,
      seenByRecruiter: seenByRecruiter,
      canCancel,
      canWithdraw,
      canRepostulate,
      action, 
      allowRepostulation: application.offerId.allowRepostulation,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\candidateController.js ===
import Candidate from "../models/Candidate.js";
import Offer from "../models/Offer.js";
import User from "../models/User.js";
import { uploadCV } from "../config/multer.js";
import Recruiter from "../models/Recruiter.js";
import Notification from "../models/Notification.js";
import Application from "../models/Application.js";
import Company from "../models/Company.js";
import fs from "fs";
import path from "path";
import mongoose from "mongoose";
import { calculateProfileCompletion } from "../utils/profileCompletion.js";

export const updateProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const {
      telephone,
      residence,
      searchPreferences,
      desiredPosition,
      desiredJobTypes,
      dateOfBirth,
      bio,
      gender,
      skills,
      experiences,
      education,
      autoriserProposition,
      links,
    } = req.body;

    let candidate = await Candidate.findOne({ userId });
    if (!candidate) candidate = new Candidate({ userId });

    if (telephone) candidate.telephone = telephone;
    if (residence) candidate.residence = residence;
    if (searchPreferences) candidate.searchPreferences = searchPreferences;
    if (desiredPosition) candidate.desiredPosition = desiredPosition;
    if (desiredJobTypes) candidate.desiredJobTypes = desiredJobTypes;

    if (dateOfBirth) candidate.dateOfBirth = dateOfBirth;
    if (bio) candidate.bio = bio;
    if (links) candidate.links = links;
    if (gender) candidate.gender = gender;
    if (autoriserProposition !== undefined)
      candidate.autoriserProposition = autoriserProposition;

    if (skills) candidate.skills = skills;
    if (experiences) candidate.experiences = experiences;
    if (education) candidate.education = education;

    await candidate.save();
    res.json({ msg: "Profil mis Ã  jour âœ…", candidate });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const uploadProfilePicture = async (req, res) => {
  try {
    const userId = req.user.id;
    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    if (!req.file)
      return res.status(400).json({ msg: "Aucune image fournie." });

    if (candidate.profilePicture) {
      const oldPath = path.join(process.cwd(), candidate.profilePicture);
      if (fs.existsSync(oldPath)) {
        fs.unlinkSync(oldPath);
      }
    }

    const imagePath = req.file.path.replace(/\\/g, "/");

    candidate.profilePicture = imagePath;
    await candidate.save();

    res.json({
      msg: "Photo de profil mise Ã  jour ðŸ“¸",
      profilePicture: candidate.profilePicture,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const uploadCandidateCV = async (req, res) => {
  try {
    const userId = req.user.id;
    const candidate = await Candidate.findOne({ userId });

    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });
    if (candidate.cvs.length >= 3)
      return res
        .status(400)
        .json({ msg: "Vous ne pouvez pas ajouter plus de 3 CV." });

    const fileSize = req.file.size;
    let score = 100;
    if (fileSize < 20 * 1024) score = 0;
    else if (fileSize > 5 * 1024 * 1024) score = 50;

    const cvPath = req.file.path.replace(/\\/g, "/");
    candidate.cvs.push({ url: cvPath, score });
    await candidate.save();

    res.json({
      msg: "CV ajoutÃ© avec succÃ¨s âœ…",
      cv: { url: cvPath, score },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteCV = async (req, res) => {
  try {
    const userId = req.user.id;
    const { cvId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    const cv = candidate.cvs.id(cvId);
    if (!cv) return res.status(404).json({ msg: "CV introuvable." });

    const filePath = path.join(process.cwd(), cv.url);
    if (fs.existsSync(filePath)) fs.unlinkSync(filePath);

    candidate.cvs.pull(cvId);
    await candidate.save();

    res.json({
      msg: "CV supprimÃ© avec succÃ¨s ðŸ—‘ï¸",
      cvs: candidate.cvs,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: err.message });
  }
};

export const applyToOffer = async (req, res) => {
  try {
    const userId = req.user.id;
    const { offreId, cvUrl, coverLetter } = req.body;

    const candidate = await Candidate.findOne({ userId });
    const user = await User.findById(userId);

    
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    if (!user.emailVerified) {
      return res.status(403).json({ msg: "Email non vÃ©rifiÃ©." });
    }

    const completion = calculateProfileCompletion(candidate, user);
    if (!completion.canApply) {
      return res.status(400).json({ msg: "Profil incomplet." });
    }

    const cvExists = candidate.cvs.some((cv) => cv.url === cvUrl);
    if (!cvExists) {
      return res.status(400).json({ msg: "CV invalide." });
    }

    
    const offer = await Offer.findById(offreId).populate("recruteurId");
    if (!offer || !offer.actif || offer.validationStatus !== "approved") {
      return res
        .status(400)
        .json({ msg: "Cette offre n'est plus disponible." });
    }

    
    const existingApp = await Application.findOne({
      offerId: offreId,
      candidateId: candidate._id,
    });

    if (existingApp) {
      const activeStatuses = ["envoyee", "en_cours", "retenue", "non_retenue"];

      
      if (activeStatuses.includes(existingApp.candidateStatus)) {
        return res.status(400).json({
          msg: "Vous avez dÃ©jÃ  une candidature active pour cette offre.",
        });
      }

      
      if (["cancelled", "retiree"].includes(existingApp.candidateStatus)) {
        if (offer.allowRepostulation === false) {
          return res.status(403).json({
            msg: "L'employeur n'accepte pas les repostulations pour cette offre.",
          });
        }

        const wasWithdrawn = existingApp.candidateStatus === "retiree";

        
        existingApp.candidateStatus = "envoyee";
        existingApp.recruiterStatus = "nouvelle";
        existingApp.cvUrl = cvUrl;
        existingApp.coverLetter = coverLetter || "";
        existingApp.seenByRecruiter = false;
        existingApp.seenAt = null;
        existingApp.datePostulation = new Date();
        existingApp.isRepostulation = true;

        
        existingApp.withdrawReason = undefined;
        existingApp.withdrawnAt = undefined;

        existingApp.statusHistory.push({
          candidateStatus: "envoyee",
          recruiterStatus: "nouvelle",
          changedBy: userId,
          note: wasWithdrawn
            ? "Repostulation aprÃ¨s retrait"
            : "Nouvelle postulation aprÃ¨s annulation",
        });

        await existingApp.save();

        
        await Offer.findByIdAndUpdate(offreId, {
          $inc: { nombreCandidatures: 1 },
        });

        
        if (offer.recruteurId?.userId) {
          await Notification.create({
            userId: offer.recruteurId.userId,
            message: wasWithdrawn
              ? `Le candidat a repostulÃ© pour "${offer.titre}"`
              : `Nouvelle candidature pour "${offer.titre}"`,
            type: "info",
          });
        }

        return res.json({
          msg: "Candidature envoyÃ©e avec succÃ¨s âœ…",
          reactivated: true,
        });
      }
    }

    
    const company = await Company.findById(offer.companyId);

    await Application.create({
      offerId: offreId,
      candidateId: candidate._id,
      cvUrl,
      coverLetter: coverLetter || "",
      candidateStatus: "envoyee",
      recruiterStatus: "nouvelle",
      source: "direct",
      isRepostulation: false,
      offerSnapshot: {
        titre: offer.titre,
        entrepriseNom: company?.name || "Entreprise",
        companyId: offer.companyId,
        location: offer.wilaya,
        salaryMin: offer.salaryMin,
        salaryMax: offer.salaryMax,
        type: offer.type,
      },
    });

    await Offer.findByIdAndUpdate(offreId, {
      $inc: { nombreCandidatures: 1 },
    });

    if (offer.recruteurId?.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Nouvelle candidature pour "${offer.titre}"`,
        type: "info",
      });
    }

    res.json({ msg: "Candidature envoyÃ©e avec succÃ¨s âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getProfile = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id }).populate(
      "userId",
      "nom email emailVerified",
    );

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const user = await User.findById(req.user.id);
    const completion = calculateProfileCompletion(candidate, user);

    res.json({
      profil: candidate,
      completion,
      emailVerified: user.emailVerified,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAccount = async (req, res) => {
  try {
    const userId = req.user.id;
    const { nom, email, motDePasse } = req.body;

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable." });

    if (nom) user.nom = nom;
    if (email) user.email = email;
    if (motDePasse) {
      const bcrypt = await import("bcryptjs");
      user.motDePasse = await bcrypt.default.hash(motDePasse, 10);
    }

    await user.save();
    res.json({ msg: "Compte mis Ã  jour âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const addToFavorites = async (req, res) => {
  try {
    const { offerId } = req.params;
    const userId = req.user.id;

    const offerExists = await Offer.exists({ _id: offerId });
    if (!offerExists) {
      return res.status(404).json({ msg: "Offre introuvable." });
    }

    const candidateCheck = await Candidate.findOne({
      userId,
      "favoris.offerId": offerId,
    });

    if (candidateCheck) {
      return res
        .status(400)
        .json({ msg: "Cette offre est dÃ©jÃ  dans vos favoris." });
    }

    const updatedCandidate = await Candidate.findOneAndUpdate(
      { userId },
      {
        $push: {
          favoris: {
            offerId: offerId,
            savedAt: new Date(),
          },
        },
      },
      { new: true },
    );

    if (!updatedCandidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable." });
    }

    res.json({
      msg: "Offre ajoutÃ©e aux favoris â¤ï¸",
      favoris: updatedCandidate.favoris,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const removeFromFavorites = async (req, res) => {
  try {
    const { offerId } = req.params;
    const userId = req.user.id;

    const updatedCandidate = await Candidate.findOneAndUpdate(
      { userId },
      {
        $pull: {
          favoris: { offerId: offerId },
        },
      },
      { new: true },
    );

    if (!updatedCandidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable." });
    }

    res.json({
      msg: "Offre retirÃ©e des favoris ðŸ’”",
      favoris: updatedCandidate.favoris,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getFavorites = async (req, res) => {
  try {
    const userId = req.user.id;

    const candidate = await Candidate.findOne({ userId }).populate({
      path: "favoris.offerId",
      select: "titre companyId type wilaya salaryMin salaryMax datePublication",
      populate: {
        path: "companyId",
        select: "name logo location",
      },
    });

    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    const validFavorites = candidate.favoris.filter((f) => f.offerId !== null);

    res.json(validFavorites);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const addSkill = async (req, res) => {
  try {
    const userId = req.user.id;
    const { name, level } = req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    candidate.skills.push({ name, level });
    await candidate.save();

    res.json({ msg: "CompÃ©tence ajoutÃ©e", skills: candidate.skills });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateSkill = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;
    const { name, level } = req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    const skill = candidate.skills.id(skillId);
    if (!skill) return res.status(404).json({ msg: "CompÃ©tence introuvable." });

    if (name) skill.name = name;
    if (level) skill.level = level;

    await candidate.save();
    res.json({ msg: "CompÃ©tence mise Ã  jour", skills: candidate.skills });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteSkill = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    candidate.skills.pull(skillId);
    await candidate.save();

    res.json({ msg: "CompÃ©tence supprimÃ©e", skills: candidate.skills });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const addExperience = async (req, res) => {
  try {
    const userId = req.user.id;

    const { jobTitle, company, startDate, endDate, description } = req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    candidate.experiences.push({
      jobTitle,
      company,
      startDate,
      endDate,
      description,
    });
    await candidate.save();

    res.json({ msg: "ExpÃ©rience ajoutÃ©e", experiences: candidate.experiences });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const { experienceId } = req.params;
    const { jobTitle, company, startDate, endDate, description } = req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    const experience = candidate.experiences.id(experienceId);
    if (!experience)
      return res.status(404).json({ msg: "ExpÃ©rience introuvable." });

    if (jobTitle) experience.jobTitle = jobTitle;
    if (company) experience.company = company;
    if (startDate) experience.startDate = startDate;

    if (endDate !== undefined) experience.endDate = endDate;
    if (description) experience.description = description;

    await candidate.save();

    res.json({
      msg: "ExpÃ©rience mise Ã  jour",
      experiences: candidate.experiences,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const { experienceId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    candidate.experiences.pull(experienceId);
    await candidate.save();

    res.json({
      msg: "ExpÃ©rience supprimÃ©e",
      experiences: candidate.experiences,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const addEducation = async (req, res) => {
  try {
    const userId = req.user.id;

    const { institut, degree, fieldOfStudy, startDate, endDate, description } =
      req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    candidate.education.push({
      institut,
      degree,
      fieldOfStudy,
      startDate,
      endDate,
      description,
    });

    await candidate.save();

    res.json({
      msg: "Formation ajoutÃ©e avec succÃ¨s ðŸŽ“",
      education: candidate.education,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { educationId } = req.params;
    const { institut, degree, fieldOfStudy, startDate, endDate, description } =
      req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    const edu = candidate.education.id(educationId);
    if (!edu) return res.status(404).json({ msg: "Formation introuvable." });

    if (institut) edu.institut = institut;
    if (degree) edu.degree = degree;
    if (fieldOfStudy) edu.fieldOfStudy = fieldOfStudy;
    if (startDate) edu.startDate = startDate;
    if (endDate !== undefined) edu.endDate = endDate;
    if (description) edu.description = description;

    await candidate.save();

    res.json({
      msg: "Formation mise Ã  jour âœ…",
      education: candidate.education,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { educationId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable." });

    candidate.education.pull(educationId);
    await candidate.save();

    res.json({ msg: "Formation supprimÃ©e ðŸ—‘ï¸", education: candidate.education });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateStats = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const [
      totalApplications,
      applicationsByStatus,
      recentApplications,
      weeklyApplications,
      viewedApplications,
    ] = await Promise.all([
      Application.countDocuments({ candidateId: candidate._id }),
      Application.aggregate([
        { $match: { candidateId: candidate._id } },
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),
      Application.countDocuments({
        candidateId: candidate._id,
        datePostulation: { $gte: thirtyDaysAgo },
      }),
      Application.countDocuments({
        candidateId: candidate._id,
        datePostulation: { $gte: sevenDaysAgo },
      }),
      Application.countDocuments({
        candidateId: candidate._id,
        status: {
          $in: ["en_cours", "retenue", "non_retenue"],
        },
      }),
    ]);

    const statusMap = {};
    applicationsByStatus.forEach((item) => {
      statusMap[item._id] = item.count;
    });

    const responded =
      (statusMap["retenue"] || 0) +
      (statusMap["non_retenue"] || 0) +
      (statusMap["en_cours"] || 0);

    const responseRate =
      totalApplications > 0
        ? Math.round((responded / totalApplications) * 100)
        : 0;

    const viewRate =
      totalApplications > 0
        ? Math.round((viewedApplications / totalApplications) * 100)
        : 0;

    const user = await User.findById(req.user.id);
    const profileCompletion = calculateProfileCompletion(candidate, user);

    const suggestions = [];
    if (!user.emailVerified) {
      suggestions.push({
        type: "critical",
        message: "Confirmez votre email pour postuler aux offres",
        action: "verify_email",
      });
    }
    if (profileCompletion.percentage < 100) {
      suggestions.push({
        type: "important",
        message: `ComplÃ©tez votre profil (${profileCompletion.percentage}%)`,
        action: "complete_profile",
        missing: profileCompletion.missing,
      });
    }
    if (candidate.cvs.length === 0) {
      suggestions.push({
        type: "important",
        message: "Ajoutez votre CV pour augmenter vos chances",
        action: "upload_cv",
      });
    }

    res.json({
      applications: {
        total: totalApplications,
        thisMonth: recentApplications,
        thisWeek: weeklyApplications,
        byStatus: statusMap,
      },
      favorites: candidate.favoris.length,
      rates: {
        response: responseRate + "%",
        view: viewRate + "%",
      },
      completion: profileCompletion,
      suggestions,
      cvCount: candidate.cvs.length,
      skillCount: candidate.skills.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getActivityTimeline = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    const recentApplications = await Application.find({
      candidateId: candidate._id,
    })
      .sort({ updatedAt: -1 })
      .limit(10)
      .populate({
        path: "offerId",
        select: "titre",
        populate: { path: "companyId", select: "name logo" },
      });

    const activities = recentApplications.map((app) => ({
      type: "application_update",
      date: app.updatedAt,
      title:
        app.offerId?.titre || app.offerSnapshot?.titre || "Offre supprimÃ©e",
      company: app.offerId?.companyId?.name || app.offerSnapshot?.entrepriseNom,
      status: app.status,
      applicationId: app._id,
    }));

    res.json(activities);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getRecommendedOffers = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    const skillNames = (candidate.skills || [])
      .map((s) => s.name?.trim().toLowerCase())
      .filter(Boolean);

    if (skillNames.length === 0) {
      return res.json([]);
    }

    const appliedOfferIds = await Application.find({
      candidateId: candidate._id,
    }).distinct("offerId");

    const offerFilter = {
      actif: true,
      validationStatus: "approved",
      _id: { $nin: appliedOfferIds },
      skills: {
        $in: skillNames.map((s) => new RegExp(`^${s}$`, "i")),
      },
    };

    const candidateWilaya = candidate.residence?.wilaya;

    if (candidateWilaya) {
      offerFilter.wilaya = candidateWilaya;
    }

    const offers = await Offer.find(offerFilter)
      .populate("companyId", "name logo")
      .sort({ nombreCandidatures: -1 })
      .limit(20);

    const scoredOffers = offers.map((offer) => {
      const offerSkills = (offer.skills || []).map((s) =>
        s.trim().toLowerCase(),
      );
      const matchingSkills = offerSkills.filter((skill) =>
        skillNames.includes(skill),
      );
      const totalSkills = offerSkills.length || 1;
      const matchScore = Math.round(
        (matchingSkills.length / totalSkills) * 100,
      );

      return {
        ...offer.toObject(),
        matchScore,
        matchingSkills,
      };
    });

    scoredOffers.sort((a, b) => {
      if (b.matchScore !== a.matchScore) {
        return b.matchScore - a.matchScore;
      }
      return b.nombreCandidatures - a.nombreCandidatures;
    });

    res.json(scoredOffers.slice(0, 10));
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\conversationController.js ===
import Conversation from "../models/Conversation.js";
import Application from "../models/Application.js";
import Offer from "../models/Offer.js";
import Candidate from "../models/Candidate.js";
import Recruiter from "../models/Recruiter.js";
import Notification from "../models/Notification.js";
import { mapRecruiterToCandidate } from "../utils/statusMapping.js";




export const openConversation = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { applicationId } = req.params;
    const { initialMessage } = req.body;

    const application =
      await Application.findById(applicationId).populate("offerId");

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    if (
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(403).json({ msg: "Non autorisÃ©" });
    }

    
    let conversation = await Conversation.findOne({ applicationId });

    if (conversation) {
      return res.status(400).json({
        msg: "Une conversation existe dÃ©jÃ  pour cette candidature",
        conversationId: conversation._id,
      });
    }

    
    conversation = await Conversation.create({
      applicationId,
      offerId: application.offerId._id,
      candidateId: application.candidateId,
      recruiterId: recruiter._id,
      openedBy: req.user.id,
      messages: initialMessage
        ? [
            {
              senderId: req.user.id,
              senderType: "recruiter",
              content: initialMessage,
            },
          ]
        : [],
      unreadByCandidate: initialMessage ? 1 : 0,
      lastMessageAt: initialMessage ? new Date() : null,
    });

    
    if (
      application.recruiterStatus !== "en_discussion" &&
      ![
        "entretien_planifie",
        "entretien_termine",
        "retenue",
        "refusee",
      ].includes(application.recruiterStatus)
    ) {
      application.recruiterStatus = "en_discussion";
      application.candidateStatus = mapRecruiterToCandidate("en_discussion");
      application.statusHistory.push({
        candidateStatus: application.candidateStatus,
        recruiterStatus: "en_discussion",
        changedBy: req.user.id,
        note: "Conversation ouverte",
      });
      await application.save();
    }

    
    if (initialMessage) {
      const candidate = await Candidate.findById(application.candidateId);
      await Notification.create({
        userId: candidate.userId,
        message: `Nouveau message du recruteur pour "${application.offerId.titre}"`,
        type: "info",
      });
    }

    res.status(201).json({ msg: "Conversation ouverte", conversation });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const sendMessageAsRecruiter = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { conversationId } = req.params;
    const { content } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    const conversation = await Conversation.findOne({
      _id: conversationId,
      recruiterId: recruiter._id,
      status: "active",
    });

    if (!conversation) {
      return res
        .status(404)
        .json({ msg: "Conversation introuvable ou fermÃ©e" });
    }

    conversation.messages.push({
      senderId: req.user.id,
      senderType: "recruiter",
      content,
      attachments,
    });
    conversation.unreadByCandidate += 1;
    conversation.lastMessageAt = new Date();
    await conversation.save();

    
    const candidate = await Candidate.findById(conversation.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `Nouveau message du recruteur`,
      type: "info",
    });

    res.json({
      msg: "Message envoyÃ©",
      message: conversation.messages.slice(-1)[0],
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getRecruiterConversations = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { offerId, hasUnread } = req.query;

    let query = { recruiterId: recruiter._id, status: "active" };

    if (offerId) query.offerId = offerId;
    if (hasUnread === "true") query.unreadByRecruiter = { $gt: 0 };

    const conversations = await Conversation.find(query)
      .sort({ lastMessageAt: -1 })
      .populate({
        path: "candidateId",
        select: "profilePicture userId",
        populate: { path: "userId", select: "nom" },
      })
      .populate("offerId", "titre")
      .lean();

    const enriched = conversations.map((c) => ({
      _id: c._id,
      offer: { _id: c.offerId?._id, titre: c.offerId?.titre },
      candidate: {
        nom: c.candidateId?.userId?.nom,
        profilePicture: c.candidateId?.profilePicture,
      },
      lastMessage: c.messages?.slice(-1)[0],
      unreadCount: c.unreadByRecruiter,
      lastMessageAt: c.lastMessageAt,
    }));

    res.json(enriched);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getCandidateConversations = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });

    const conversations = await Conversation.find({
      candidateId: candidate._id,
      status: "active",
    })
      .sort({ lastMessageAt: -1 })
      .populate("offerId", "titre companyId")
      .populate({
        path: "offerId",
        populate: { path: "companyId", select: "name logo" },
      })
      .lean();

    const enriched = conversations.map((c) => ({
      _id: c._id,
      applicationId: c.applicationId,
      offer: {
        titre: c.offerId?.titre,
        entreprise: c.offerId?.companyId?.name,
        logo: c.offerId?.companyId?.logo,
      },
      lastMessage: c.messages?.slice(-1)[0],
      unreadCount: c.unreadByCandidate,
      lastMessageAt: c.lastMessageAt,
    }));

    res.json(enriched);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getConversationMessages = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { conversationId } = req.params;

    const conversation = await Conversation.findOne({
      _id: conversationId,
      candidateId: candidate._id,
    })
      .populate("offerId", "titre")
      .lean();

    if (!conversation) {
      return res.status(404).json({ msg: "Conversation introuvable" });
    }

    
    await Conversation.findByIdAndUpdate(conversationId, {
      unreadByCandidate: 0,
    });

    
    await Conversation.updateOne(
      { _id: conversationId },
      { $set: { "messages.$[elem].readAt": new Date() } },
      {
        arrayFilters: [
          { "elem.readAt": { $exists: false }, "elem.senderType": "recruiter" },
        ],
      },
    );

    res.json({
      _id: conversation._id,
      offer: { titre: conversation.offerId?.titre },
      messages: conversation.messages,
      status: conversation.status,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const sendMessageAsCandidate = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { conversationId } = req.params;
    const { content } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    const conversation = await Conversation.findOne({
      _id: conversationId,
      candidateId: candidate._id,
      status: "active",
    });

    if (!conversation) {
      return res
        .status(404)
        .json({ msg: "Conversation introuvable ou fermÃ©e" });
    }

    conversation.messages.push({
      senderId: req.user.id,
      senderType: "candidate",
      content,
      attachments,
    });
    conversation.unreadByRecruiter += 1;
    conversation.lastMessageAt = new Date();
    await conversation.save();

    
    const recruiter = await Recruiter.findById(conversation.recruiterId);
    await Notification.create({
      userId: recruiter.userId,
      message: `Nouvelle rÃ©ponse d'un candidat`,
      type: "info",
    });

    res.json({
      msg: "Message envoyÃ©",
      message: conversation.messages.slice(-1)[0],
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\interviewController.js ===
import Interview from "../models/Interview.js";
import Application from "../models/Application.js";
import Offer from "../models/Offer.js";
import Candidate from "../models/Candidate.js";
import Recruiter from "../models/Recruiter.js";
import Notification from "../models/Notification.js";
import { mapRecruiterToCandidate } from "../utils/statusMapping.js";




export const proposeInterview = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { applicationId } = req.params;
    const {
      type,
      scheduledAt,
      duration,
      location,
      meetingLink,
      phoneNumber,
      preparationNotes,
    } = req.body;

    const application = await Application.findById(applicationId).populate(
      "offerId"
    );

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    if (
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(403).json({ msg: "Non autorisÃ©" });
    }

    
    const allowedStatuses = [
      "consultee",
      "preselection",
      "en_discussion",
      "entretien_termine",
    ];
    if (!allowedStatuses.includes(application.recruiterStatus)) {
      return res.status(400).json({
        msg: "Cette candidature ne peut pas recevoir d'entretien dans son Ã©tat actuel",
      });
    }

    const interview = await Interview.create({
      applicationId,
      offerId: application.offerId._id,
      candidateId: application.candidateId,
      recruiterId: recruiter._id,
      type,
      scheduledAt: new Date(scheduledAt),
      duration: duration || 30,
      location,
      meetingLink,
      phoneNumber,
      preparationNotes,
      status: "proposed",
    });

    
    if (application.recruiterStatus !== "entretien_planifie") {
      application.recruiterStatus = "entretien_planifie";
      application.candidateStatus =
        mapRecruiterToCandidate("entretien_planifie");
      application.statusHistory.push({
        candidateStatus: application.candidateStatus,
        recruiterStatus: "entretien_planifie",
        changedBy: req.user.id,
        note: "Entretien proposÃ©",
      });
      await application.save();
    }

    
    const candidate = await Candidate.findById(application.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `Un entretien vous est proposÃ© pour "${
        application.offerId.titre
      }" le ${new Date(scheduledAt).toLocaleDateString("fr-FR")}`,
      type: "validation",
    });

    res.status(201).json({ msg: "Entretien proposÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getRecruiterInterviews = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { status, upcoming, page = 1, limit = 20 } = req.query;

    let query = { recruiterId: recruiter._id };

    if (status) {
      query.status = status;
    }

    if (upcoming === "true") {
      query.scheduledAt = { $gte: new Date() };
      query.status = {
        $in: ["proposed", "confirmed", "rescheduled_by_candidate"],
      };
    }

    const skip = (page - 1) * limit;

    const [interviews, total] = await Promise.all([
      Interview.find(query)
        .sort({ scheduledAt: 1 })
        .skip(skip)
        .limit(parseInt(limit))
        .populate({
          path: "candidateId",
          select: "profilePicture userId",
          populate: { path: "userId", select: "nom email" },
        })
        .populate("offerId", "titre")
        .lean(),
      Interview.countDocuments(query),
    ]);

    
    const enriched = interviews.map((i) => ({
      ...i,
      needsAction: i.status === "rescheduled_by_candidate",
      isToday:
        new Date(i.scheduledAt).toDateString() === new Date().toDateString(),
      isPast: new Date(i.scheduledAt) < new Date(),
    }));

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const acceptAlternativeDate = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { interviewId } = req.params;

    const interview = await Interview.findOne({
      _id: interviewId,
      recruiterId: recruiter._id,
      status: "rescheduled_by_candidate",
    });

    if (!interview) {
      return res
        .status(404)
        .json({ msg: "Entretien introuvable ou pas de proposition" });
    }

    interview.scheduledAt = interview.proposedAlternative.date;
    interview.status = "confirmed";
    interview.proposedAlternative = undefined;
    await interview.save();

    
    const candidate = await Candidate.findById(interview.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `Votre nouvelle date d'entretien a Ã©tÃ© confirmÃ©e`,
      type: "validation",
    });

    res.json({ msg: "Nouvelle date acceptÃ©e", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const rescheduleByRecruiter = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { interviewId } = req.params;
    const { newDate, message } = req.body;

    const interview = await Interview.findOne({
      _id: interviewId,
      recruiterId: recruiter._id,
    });

    if (!interview) {
      return res.status(404).json({ msg: "Entretien introuvable" });
    }

    interview.scheduledAt = new Date(newDate);
    interview.status = "rescheduled_by_recruiter";
    interview.proposedAlternative = {
      date: new Date(newDate),
      proposedBy: "recruiter",
      message,
      proposedAt: new Date(),
    };
    await interview.save();

    const candidate = await Candidate.findById(interview.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `L'entretien a Ã©tÃ© reprogrammÃ©, veuillez confirmer la nouvelle date`,
      type: "validation",
    });

    res.json({ msg: "Entretien reprogrammÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const cancelInterviewByRecruiter = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { interviewId } = req.params;
    const { reason } = req.body;

    const interview = await Interview.findOneAndUpdate(
      {
        _id: interviewId,
        recruiterId: recruiter._id,
        status: {
          $in: [
            "proposed",
            "confirmed",
            "rescheduled_by_candidate",
            "rescheduled_by_recruiter",
          ],
        },
      },
      {
        status: "cancelled_by_recruiter",
        recruiterNotes: reason,
      },
      { new: true }
    );

    if (!interview) {
      return res
        .status(404)
        .json({ msg: "Entretien introuvable ou dÃ©jÃ  terminÃ©" });
    }

    const candidate = await Candidate.findById(interview.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `L'entretien prÃ©vu a Ã©tÃ© annulÃ© par le recruteur`,
      type: "info",
    });

    res.json({ msg: "Entretien annulÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const completeInterview = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { interviewId } = req.params;
    const { rating, notes, strengths, concerns, recommendation } = req.body;

    const interview = await Interview.findOne({
      _id: interviewId,
      recruiterId: recruiter._id,
    });

    if (!interview) {
      return res.status(404).json({ msg: "Entretien introuvable" });
    }

    interview.status = "completed";
    interview.feedback = {
      rating,
      notes,
      strengths,
      concerns,
      recommendation,
      completedAt: new Date(),
    };
    await interview.save();

    
    const pendingInterviews = await Interview.countDocuments({
      applicationId: interview.applicationId,
      status: { $in: ["proposed", "confirmed"] },
    });

    if (pendingInterviews === 0) {
      const application = await Application.findById(interview.applicationId);
      application.recruiterStatus = "entretien_termine";
      application.candidateStatus =
        mapRecruiterToCandidate("entretien_termine");
      application.statusHistory.push({
        candidateStatus: application.candidateStatus,
        recruiterStatus: "entretien_termine",
        changedBy: req.user.id,
        note: "Tous les entretiens terminÃ©s",
      });
      await application.save();
    }

    res.json({ msg: "Entretien terminÃ© et feedback enregistrÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getCandidateInterviews = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { upcoming } = req.query;

    let query = { candidateId: candidate._id };

    if (upcoming === "true") {
      query.scheduledAt = { $gte: new Date() };
      query.status = {
        $nin: [
          "cancelled_by_candidate",
          "cancelled_by_recruiter",
          "completed",
          "no_show_candidate",
          "no_show_recruiter",
        ],
      };
    }

    const interviews = await Interview.find(query)
      .sort({ scheduledAt: 1 })
      .populate("offerId", "titre companyId")
      .populate({
        path: "offerId",
        populate: { path: "companyId", select: "name logo" },
      })
      .lean();

    const enriched = interviews.map((i) => ({
      _id: i._id,
      type: i.type,
      scheduledAt: i.scheduledAt,
      duration: i.duration,
      location: i.location,
      meetingLink: i.meetingLink,
      phoneNumber: i.phoneNumber,
      status: i.status,
      preparationNotes: i.preparationNotes,
      proposedAlternative: i.proposedAlternative,
      offer: {
        titre: i.offerId?.titre,
        entreprise: i.offerId?.companyId?.name,
        logo: i.offerId?.companyId?.logo,
      },
      needsResponse:
        i.status === "proposed" || i.status === "rescheduled_by_recruiter",
      isToday:
        new Date(i.scheduledAt).toDateString() === new Date().toDateString(),
    }));

    res.json(enriched);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const acceptInterview = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { interviewId } = req.params;

    const interview = await Interview.findOneAndUpdate(
      {
        _id: interviewId,
        candidateId: candidate._id,
        status: { $in: ["proposed", "rescheduled_by_recruiter"] },
      },
      { status: "confirmed" },
      { new: true }
    );

    if (!interview) {
      return res
        .status(404)
        .json({ msg: "Entretien introuvable ou dÃ©jÃ  traitÃ©" });
    }

    
    const recruiter = await Recruiter.findById(interview.recruiterId);
    await Notification.create({
      userId: recruiter.userId,
      message: `Le candidat a confirmÃ© l'entretien`,
      type: "validation",
    });

    res.json({ msg: "Entretien confirmÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const declineInterview = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { interviewId } = req.params;
    const { reason } = req.body;

    const interview = await Interview.findOneAndUpdate(
      {
        _id: interviewId,
        candidateId: candidate._id,
        status: { $in: ["proposed", "rescheduled_by_recruiter"] },
      },
      { status: "cancelled_by_candidate" },
      { new: true }
    );

    if (!interview) {
      return res.status(404).json({ msg: "Entretien introuvable" });
    }

    const recruiter = await Recruiter.findById(interview.recruiterId);
    await Notification.create({
      userId: recruiter.userId,
      message: `Le candidat a dÃ©clinÃ© l'entretien${
        reason ? `: ${reason}` : ""
      }`,
      type: "info",
    });

    res.json({ msg: "Entretien dÃ©clinÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const proposeAlternativeDate = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { interviewId } = req.params;
    const { newDate, message } = req.body;

    const interview = await Interview.findOne({
      _id: interviewId,
      candidateId: candidate._id,
      status: { $in: ["proposed", "rescheduled_by_recruiter"] },
    });

    if (!interview) {
      return res.status(404).json({ msg: "Entretien introuvable" });
    }

    interview.status = "rescheduled_by_candidate";
    interview.proposedAlternative = {
      date: new Date(newDate),
      proposedBy: "candidate",
      message,
      proposedAt: new Date(),
    };
    await interview.save();

    const recruiter = await Recruiter.findById(interview.recruiterId);
    await Notification.create({
      userId: recruiter.userId,
      message: `Le candidat propose une nouvelle date pour l'entretien`,
      type: "validation",
    });

    res.json({ msg: "Proposition envoyÃ©e", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\notificationController.js ===
import Notification from "../models/Notification.js";

export const getMyNotifications = async (req, res) => {
  try {
    const notifications = await Notification.find({ userId: req.user.id }).sort(
      {
        date: -1,
      }
    );
    res.json(notifications);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getUnreadCount = async (req, res) => {
  try {
    const count = await Notification.countDocuments({
      userId: req.user.id,
      lu: false,
    });
    res.json({ count });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const markAsRead = async (req, res) => {
  try {
    const notification = await Notification.findOneAndUpdate(
      { _id: req.params.id, userId: req.user.id },
      { lu: true },
      { new: true }
    );

    if (!notification)
      return res.status(404).json({ msg: "Notification introuvable" });

    res.json(notification);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\offerController.js ===
import Offer from "../models/Offer.js";
import Company from "../models/Company.js";

const toCursor = (payload) => {
  return Buffer.from(JSON.stringify(payload)).toString("base64");
};

const fromCursor = (cursor) => {
  try {
    return JSON.parse(Buffer.from(cursor, "base64").toString("utf8"));
  } catch (e) {
    return null;
  }
};

export const getAllActiveOffers = async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    const {
      cursor,
      wilaya,
      sort,
      search,
      type,
      domaine,
      experienceLevel,
      minSalary,
      maxSalary,
    } = req.query;

    let query = { actif: true, validationStatus: "approved" };

    if (wilaya) {
      query.wilaya = { $regex: new RegExp(`^${wilaya}$`, "i") };
    }

    if (type) {
      query.type = type;
    }

    if (domaine) {
      query.domaine = domaine;
    }

    if (experienceLevel) {
      query.experienceLevel = experienceLevel;
    }

    if (minSalary) {
      query.salaryMax = { $gte: parseInt(minSalary) };
    }

    if (maxSalary) {
      query.salaryMin = { $lte: parseInt(maxSalary) };
    }

    if (search) {
      const matchingCompanies = await Company.find({
        name: { $regex: search, $options: "i" },
      }).select("_id");

      const companyIds = matchingCompanies.map((c) => c._id);

      query.$or = [
        { titre: { $regex: search, $options: "i" } },
        { description: { $regex: search, $options: "i" } },
        { skills: { $in: [new RegExp(search, "i")] } },
        { companyId: { $in: companyIds } },
      ];
    }

    if (cursor) {
      const decrypted = fromCursor(cursor);

      if (decrypted) {
        const { id, value } = decrypted;

        if (sort === "popular") {
          query.$and = [
            ...(query.$and || []),
            {
              $or: [
                { nombreCandidatures: { $lt: value } },
                { nombreCandidatures: value, _id: { $lt: id } },
              ],
            },
          ];
        } else {
          query.$and = [
            ...(query.$and || []),
            {
              $or: [
                { datePublication: { $lt: new Date(value) } },
                { datePublication: new Date(value), _id: { $lt: id } },
              ],
            },
          ];
        }
      }
    }

    let sortQuery = {};
    if (sort === "popular") {
      sortQuery = { nombreCandidatures: -1, _id: -1 };
    } else {
      sortQuery = { datePublication: -1, _id: -1 };
    }

    const offers = await Offer.find(query)
      .populate("companyId", "name logo location industry")
      .populate("recruteurId", "position")
      .sort(sortQuery)
      .limit(limit + 1);

    const hasNextPage = offers.length > limit;
    const data = hasNextPage ? offers.slice(0, limit) : offers;

    const enrichedData = data.map((offer) => {
      const isNew =
        new Date() - new Date(offer.datePublication) < 2 * 24 * 60 * 60 * 1000;
      return { ...offer.toObject(), isNew };
    });

    let nextCursor = null;
    if (hasNextPage && data.length > 0) {
      const lastItem = data[data.length - 1];

      const cursorValue =
        sort === "popular"
          ? lastItem.nombreCandidatures
          : lastItem.datePublication;

      nextCursor = toCursor({
        id: lastItem._id,
        value: cursorValue,
      });
    }

    res.json({
      data: enrichedData,
      meta: {
        nextCursor,
        hasNextPage,
        limit,
      },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: err.message });
  }
};

export const getOfferDetails = async (req, res) => {
  try {
    const offer = await Offer.findOne({ _id: req.params.id, actif: true })
      .populate("companyId", "name logo website description location size")
      .populate("recruteurId", "position");

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    const isNew =
      new Date() - new Date(offer.datePublication) < 2 * 24 * 60 * 60 * 1000;

    res.json({ ...offer.toObject(), isNew });
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\recruiterApplicationController.js ===
import Application from "../models/Application.js";
import Interview from "../models/Interview.js";
import Conversation from "../models/Conversation.js";
import Offer from "../models/Offer.js";
import Candidate from "../models/Candidate.js";
import Recruiter from "../models/Recruiter.js";
import Notification from "../models/Notification.js";
import {
  mapRecruiterToCandidate,
  NOTIFY_CANDIDATE_STATUSES,
} from "../utils/statusMapping.js";


const getRecruiterProfile = async (userId) => {
  const recruiter = await Recruiter.findOne({ userId }).populate("companyId");
  if (!recruiter) throw new Error("Profil recruteur non trouvÃ©");
  return recruiter;
};


export const getOfferApplications = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { offerId } = req.params;
    const {
      status,
      starred,
      search,
      page = 1,
      limit = 20,
      sortBy = "datePostulation",
      sortOrder = "desc",
    } = req.query;

    
    const offer = await Offer.findOne({
      _id: offerId,
      recruteurId: recruiter._id,
    });

    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    let query = { offerId };

    if (status && status !== "all") {
      query.recruiterStatus = status;
    }

    if (starred === "true") {
      query.isStarred = true;
    }

    const skip = (page - 1) * limit;
    const sort = { [sortBy]: sortOrder === "desc" ? -1 : 1 };

    const [applications, total, statusCounts] = await Promise.all([
      Application.find(query)
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit))
        .populate({
          path: "candidateId",
          select: "profilePicture residence skills experiences userId",
          populate: { path: "userId", select: "nom email" },
        })
        .lean(),
      Application.countDocuments(query),
      Application.aggregate([
        { $match: { offerId: offer._id } },
        { $group: { _id: "$recruiterStatus", count: { $sum: 1 } } },
      ]),
    ]);

    
    const enriched = await Promise.all(
      applications
        .filter((app) => app.candidateId !== null)
        .map(async (app) => {
          const [conversation, upcomingInterview] = await Promise.all([
            Conversation.findOne({ applicationId: app._id })
              .select("unreadByRecruiter lastMessageAt")
              .lean(),
            Interview.findOne({
              applicationId: app._id,
              status: {
                $in: ["proposed", "confirmed", "rescheduled_by_candidate"],
              },
              scheduledAt: { $gte: new Date() },
            })
              .sort({ scheduledAt: 1 })
              .lean(),
          ]);

          return {
            _id: app._id,
            status: app.recruiterStatus,
            candidateStatus: app.candidateStatus,
            source: app.source,
            isStarred: app.isStarred,
            seenByRecruiter: app.seenByRecruiter,
            datePostulation: app.datePostulation,
            recruiterNotes: app.recruiterNotes,
            candidate: {
              _id: app.candidateId._id,
              nom: app.candidateId.userId?.nom,
              email: app.candidateId.userId?.email,
              profilePicture: app.candidateId.profilePicture,
              residence: app.candidateId.residence,
              skillsCount: app.candidateId.skills?.length || 0,
              experiencesCount: app.candidateId.experiences?.length || 0,
            },
            cvUrl: app.cvUrl,
            hasConversation: !!conversation,
            unreadMessages: conversation?.unreadByRecruiter || 0,
            upcomingInterview: upcomingInterview
              ? {
                  _id: upcomingInterview._id,
                  scheduledAt: upcomingInterview.scheduledAt,
                  status: upcomingInterview.status,
                  needsAction:
                    upcomingInterview.status === "rescheduled_by_candidate",
                }
              : null,
          };
        })
    );

    
    const countsMap = {};
    statusCounts.forEach((s) => {
      countsMap[s._id] = s.count;
    });

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
      statusCounts: countsMap,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const markAsSeen = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { applicationId } = req.params;

    const application = await Application.findById(applicationId).populate(
      "offerId"
    );

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    if (
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(403).json({ msg: "Non autorisÃ©" });
    }

    if (!application.seenByRecruiter) {
      application.seenByRecruiter = true;
      application.seenAt = new Date();

      if (application.recruiterStatus === "nouvelle") {
        application.recruiterStatus = "consultee";
        application.candidateStatus = mapRecruiterToCandidate("consultee");
        application.statusHistory.push({
          candidateStatus: application.candidateStatus,
          recruiterStatus: "consultee",
          changedBy: req.user.id,
        });
      }

      await application.save();
    }

    res.json({ msg: "MarquÃ©e comme vue", application });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateRecruiterStatus = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { applicationId } = req.params;
    const { status, notes } = req.body;

    const application = await Application.findById(applicationId).populate(
      "offerId"
    );

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    if (
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(403).json({ msg: "Non autorisÃ©" });
    }

    
    const validTransitions = {
      nouvelle: ["consultee", "preselection", "refusee"],
      consultee: ["preselection", "en_discussion", "refusee"],
      preselection: ["en_discussion", "entretien_planifie", "refusee"],
      en_discussion: ["preselection", "entretien_planifie", "refusee"],
      entretien_planifie: ["entretien_termine", "refusee"],
      entretien_termine: ["retenue", "refusee", "entretien_planifie"], 
    };

    const allowed = validTransitions[application.recruiterStatus] || [];
    if (!allowed.includes(status)) {
      return res.status(400).json({
        msg: `Transition non autorisÃ©e de "${application.recruiterStatus}" vers "${status}"`,
      });
    }

    const previousRecruiterStatus = application.recruiterStatus;
    application.recruiterStatus = status;
    application.candidateStatus = mapRecruiterToCandidate(status);

    if (notes) {
      application.recruiterNotes = notes;
    }

    if (status === "retenue" || status === "refusee") {
      application.dateDecision = new Date();
    }

    application.statusHistory.push({
      candidateStatus: application.candidateStatus,
      recruiterStatus: status,
      changedBy: req.user.id,
      note: notes,
    });

    await application.save();

    
    if (NOTIFY_CANDIDATE_STATUSES.includes(status)) {
      const candidate = await Candidate.findById(application.candidateId);
      const statusMessages = {
        retenue: `Bonne nouvelle ! Votre candidature pour "${application.offerId.titre}" a Ã©tÃ© retenue.`,
        refusee: `Votre candidature pour "${application.offerId.titre}" n'a pas Ã©tÃ© retenue.`,
      };

      await Notification.create({
        userId: candidate.userId,
        message: statusMessages[status],
        type: status === "retenue" ? "validation" : "info",
      });
    }

    res.json({
      msg: "Statut mis Ã  jour",
      application: {
        _id: application._id,
        recruiterStatus: application.recruiterStatus,
        candidateStatus: application.candidateStatus,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const toggleStarred = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { applicationId } = req.params;

    const application = await Application.findById(applicationId).populate(
      "offerId"
    );

    if (
      !application ||
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    application.isStarred = !application.isStarred;
    await application.save();

    res.json({
      msg: application.isStarred
        ? "AjoutÃ©e aux favoris"
        : "RetirÃ©e des favoris",
      isStarred: application.isStarred,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateNotes = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { applicationId } = req.params;
    const { notes } = req.body;

    const application = await Application.findOneAndUpdate(
      {
        _id: applicationId,
        offerId: {
          $in: await Offer.find({ recruteurId: recruiter._id }).distinct("_id"),
        },
      },
      { recruiterNotes: notes },
      { new: true }
    );

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    res.json({ msg: "Notes mises Ã  jour", notes: application.recruiterNotes });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getAllApplications = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { status, offerId, page = 1, limit = 20 } = req.query;

    const myOfferIds = await Offer.find({
      recruteurId: recruiter._id,
    }).distinct("_id");

    let query = { offerId: { $in: myOfferIds } };

    if (status) query.recruiterStatus = status;
    if (offerId) query.offerId = offerId;

    const skip = (page - 1) * limit;

    const [applications, total] = await Promise.all([
      Application.find(query)
        .sort({ datePostulation: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .populate("offerId", "titre")
        .populate({
          path: "candidateId",
          select: "profilePicture userId",
          populate: { path: "userId", select: "nom" },
        })
        .lean(),
      Application.countDocuments(query),
    ]);

    res.json({
      data: applications.filter((a) => a.candidateId),
      meta: {
        total,
        page: parseInt(page),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\recruiterController.js ===
import Offer from "../models/Offer.js";
import Recruiter from "../models/Recruiter.js";
import User from "../models/User.js";
import Candidate from "../models/Candidate.js";
import Company from "../models/Company.js";
import Notification from "../models/Notification.js";
import Application from "../models/Application.js";
import Admin from "../models/Admin.js";
import bcrypt from "bcryptjs";

const getRecruiterProfile = async (userId) => {
  const recruiter = await Recruiter.findOne({ userId }).populate("companyId");
  if (!recruiter) throw new Error("Profil recruteur non trouvÃ©");
  return recruiter;
};

export const createOffer = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    const recruiter = await getRecruiterProfile(req.user.id);

    if (!user.emailVerified) {
      return res.status(403).json({
        msg: "Veuillez confirmer votre email.",
        code: "EMAIL_NOT_VERIFIED",
      });
    }

    if (recruiter.status !== "validated") {
      return res.status(403).json({
        msg: "Votre compte recruteur n'est pas validÃ©.",
        code: "RECRUITER_NOT_VALIDATED",
        recruiterStatus: recruiter.status,
      });
    }

    if (recruiter.companyId.status !== "active") {
      return res.status(403).json({
        msg: "Votre entreprise n'est pas encore validÃ©e.",
        code: "COMPANY_NOT_VALIDATED",
      });
    }

    if (!recruiter.permissions.postJobs) {
      return res.status(403).json({
        msg: "Vous n'avez pas la permission de publier des offres.",
        code: "PERMISSION_DENIED",
      });
    }

    const {
      titre,
      description,
      requirements,
      domaine,
      type,
      salaryMin,
      salaryMax,
      experienceLevel,
      skills,
      wilaya,
      visibility,
      candidateSearchMode,
      allowRepostulation,
    } = req.body;

    if (!titre || !description || !requirements) {
      return res.status(400).json({
        msg: "Titre, description et requirements sont obligatoires.",
      });
    }

    const newOffer = new Offer({
      recruteurId: recruiter._id,
      companyId: recruiter.companyId._id,
      titre,
      description,
      requirements,
      domaine,
      type: type || "full-time",
      salaryMin,
      salaryMax,
      allowRepostulation:
        allowRepostulation !== undefined ? allowRepostulation : true,
      experienceLevel,
      skills: skills || [],
      wilaya,
      visibility: visibility || {
        isPublic: true,
        acceptsDirectApplications: true,
      },
      candidateSearchMode: candidateSearchMode || "disabled",
      validationStatus: "pending",
      actif: false,
      datePublication: null,
    });

    const savedOffer = await newOffer.save();

    const admins = await User.find({ role: "admin" });
    const notificationPromises = admins.map((admin) =>
      Notification.create({
        userId: admin._id,
        message: `Nouvelle offre Ã  valider : "${savedOffer.titre}" de ${recruiter.companyId.name}`,
        type: "info",
      }),
    );
    await Promise.all(notificationPromises);

    res.status(201).json({
      msg: "Offre crÃ©Ã©e et en attente de validation âœ…",
      offer: savedOffer,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getMyOffers = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);

    const offers = await Offer.find({ recruteurId: recruiter._id }).sort({
      createdAt: -1,
    });
    res.json(offers);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateOffer = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const offer = await Offer.findById(req.params.id);

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    if (offer.recruteurId.toString() !== recruiter._id.toString()) {
      return res.status(403).json({ msg: "Action non autorisÃ©e" });
    }

    const updatedOffer = await Offer.findByIdAndUpdate(
      req.params.id,
      { $set: req.body },
      { new: true },
    );

    res.json({ msg: "Offre mise Ã  jour âœ…", offer: updatedOffer });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deactivateOffer = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const offer = await Offer.findById(req.params.id);

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });
    if (offer.recruteurId.toString() !== recruiter._id.toString()) {
      return res.status(403).json({ msg: "Action non autorisÃ©e" });
    }

    offer.actif = false;
    await offer.save();

    res.json({ msg: "Offre dÃ©sactivÃ©e â›”", offer });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateRecruiterProfile = async (req, res) => {
  try {
    const userId = req.user.id;

    const { nom, motDePasse, telephone } = req.body;

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });

    if (nom) user.nom = nom;
    if (motDePasse) {
      const hash = await bcrypt.hash(motDePasse, 10);
      user.motDePasse = hash;
    }
    await user.save();

    const recruiter = await Recruiter.findOne({ userId });
    if (!recruiter)
      return res.status(404).json({ msg: "Profil recruteur introuvable" });

    if (telephone) recruiter.telephone = telephone;

    await recruiter.save();

    res.json({
      msg: "Profil mis Ã  jour avec succÃ¨s âœ…",
      user: { nom: user.nom, email: user.email },
      recruiter: {
        telephone: recruiter.telephone,
        position: recruiter.position,
        isAdmin: recruiter.isAdmin,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

function getStatusMessage(status) {
  const messages = {
    pending_validation: "En attente de validation initiale",
    pending_documents: "Documents demandÃ©s par l'administration",
    pending_info: "Informations complÃ©mentaires demandÃ©es",
    pending_revalidation: "RÃ©ponse en cours d'examen",
    rejected: "Compte refusÃ©",
  };
  return messages[status] || status;
}

export const updateCompanyDetails = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);

    if (!recruiter.isAdmin) {
      return res.status(403).json({
        msg: "AccÃ¨s refusÃ©. Seul l'administrateur de l'entreprise peut modifier ces informations.",
      });
    }

    const { website, description, industry, location, size, logo } = req.body;

    const updatedCompany = await Company.findByIdAndUpdate(
      recruiter.companyId._id,
      {
        $set: {
          website,
          description,
          industry,
          location,
          size,
          logo,
        },
      },
      { new: true },
    );

    res.json({
      msg: "Informations de l'entreprise mises Ã  jour âœ…",
      company: updatedCompany,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getRecruiterDashboard = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);

    const now = new Date();
    const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);

    const myOfferIds = await Offer.find({
      recruteurId: recruiter._id,
    }).distinct("_id");

    const [
      activeOffers,
      pendingOffers,
      rejectedOffers,
      totalApplications,
      newApplicationsThisWeek,
      applicationsByStatus,
      topOffers,
      recentApplications,
    ] = await Promise.all([
      Offer.countDocuments({
        recruteurId: recruiter._id,
        actif: true,
        validationStatus: "approved",
      }),
      Offer.countDocuments({
        recruteurId: recruiter._id,
        validationStatus: "pending",
      }),
      Offer.countDocuments({
        recruteurId: recruiter._id,
        validationStatus: { $in: ["rejected", "changes_requested"] },
      }),
      Application.countDocuments({ offerId: { $in: myOfferIds } }),
      Application.countDocuments({
        offerId: { $in: myOfferIds },
        datePostulation: { $gte: sevenDaysAgo },
      }),
      Application.aggregate([
        { $match: { offerId: { $in: myOfferIds } } },
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),
      Offer.find({ recruteurId: recruiter._id, actif: true })
        .sort({ nombreCandidatures: -1 })
        .limit(5)
        .select("titre nombreCandidatures datePublication"),
      Application.find({ offerId: { $in: myOfferIds } })
        .populate({
          path: "candidateId",
          select: "profilePicture",
          populate: { path: "userId", select: "nom" },
        })
        .populate("offerId", "titre")
        .sort({ datePostulation: -1 })
        .limit(10),
    ]);

    const statusMap = {};
    applicationsByStatus.forEach((s) => {
      statusMap[s._id] = s.count;
    });

    const alerts = [];
    if (recruiter.companyId.status !== "active") {
      alerts.push({
        type: "warning",
        message: "Votre entreprise est en attente de validation",
      });
    }
    if (recruiter.status !== "validated") {
      alerts.push({
        type: "warning",
        message: `Statut du compte : ${recruiter.status}`,
        statusMessage: getStatusMessage(recruiter.status),
      });
    }
    if (pendingOffers > 0) {
      alerts.push({
        type: "info",
        message: `${pendingOffers} offre(s) en attente de validation`,
      });
    }
    if (rejectedOffers > 0) {
      alerts.push({
        type: "error",
        message: `${rejectedOffers} offre(s) nÃ©cessitent des modifications`,
      });
    }

    const pendingRequests = recruiter.validationRequests.filter(
      (r) => r.status === "pending",
    );
    if (pendingRequests.length > 0) {
      alerts.push({
        type: "action_required",
        message: "Des documents ou informations sont demandÃ©s",
        requests: pendingRequests,
      });
    }

    res.json({
      overview: {
        activeOffers,
        pendingOffers,
        rejectedOffers,
        totalApplications,
        newApplicationsThisWeek,
      },
      applicationsByStatus: statusMap,
      topOffers,
      recentApplications,
      company: {
        name: recruiter.companyId.name,
        status: recruiter.companyId.status,
        logo: recruiter.companyId.logo,
      },
      recruiterStatus: recruiter.status,
      alerts,
      permissions: recruiter.permissions,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getOfferStats = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { offerId } = req.params;

    const offer = await Offer.findOne({
      _id: offerId,
      recruteurId: recruiter._id,
    });

    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    const [applicationsByStatus, applicationsByDay] = await Promise.all([
      Application.aggregate([
        { $match: { offerId: offer._id } },
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),
      Application.aggregate([
        { $match: { offerId: offer._id } },
        {
          $group: {
            _id: {
              $dateToString: { format: "%Y-%m-%d", date: "$datePostulation" },
            },
            count: { $sum: 1 },
          },
        },
        { $sort: { _id: 1 } },
        { $limit: 30 },
      ]),
    ]);

    const statusMap = {};
    applicationsByStatus.forEach((s) => {
      statusMap[s._id] = s.count;
    });

    res.json({
      offer: {
        _id: offer._id,
        titre: offer.titre,
        actif: offer.actif,
        validationStatus: offer.validationStatus,
        datePublication: offer.datePublication,
        nombreCandidatures: offer.nombreCandidatures,
      },
      applicationsByStatus: statusMap,
      applicationsByDay,
      conversionRate:
        offer.nombreCandidatures > 0
          ? Math.round(
              ((statusMap["retenue"] || 0) / offer.nombreCandidatures) * 100,
            )
          : 0,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getRecruiterProfileEndpoint = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id })
      .populate("userId", "nom email emailVerified")
      .populate("companyId");

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    const alerts = [];
    const user = await User.findById(req.user.id);

    if (!user.emailVerified) {
      alerts.push({
        type: "critical",
        message: "Email non vÃ©rifiÃ©",
        action: "verify_email",
      });
    }

    if (recruiter.status === "pending_validation") {
      alerts.push({
        type: "warning",
        message: "Compte en attente de validation par un administrateur",
      });
    }

    if (recruiter.status === "rejected") {
      alerts.push({
        type: "error",
        message: "Compte rejetÃ©",
        reason: recruiter.rejectionReason,
      });
    }

    if (recruiter.companyId?.status === "pending") {
      alerts.push({
        type: "warning",
        message: "Entreprise en attente de validation",
      });
    }

    const pendingRequests = recruiter.validationRequests?.filter(
      (r) => r.status === "pending",
    );

    if (pendingRequests?.length > 0) {
      alerts.push({
        type: "action_required",
        message:
          "Des documents ou informations sont demandÃ©s par l'administration",
        requests: pendingRequests,
      });
    }

    res.json({
      recruiter,
      alerts,
      canPostOffers:
        user.emailVerified &&
        recruiter.status === "validated" &&
        recruiter.companyId?.status === "active" &&
        recruiter.permissions.postJobs,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanyTeam = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil introuvable" });
    }

    const team = await Recruiter.find({ companyId: recruiter.companyId })
      .populate("userId", "nom email")
      .select("position permissions isAdmin status createdAt");

    res.json(team);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const submitValidationResponse = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const { requestId, text } = req.body;
    const documents = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    const request = recruiter.validationRequests.id(requestId);

    if (!request) {
      return res.status(404).json({ msg: "Demande introuvable." });
    }

    if (request.status !== "pending") {
      return res.status(400).json({ msg: "Cette demande a dÃ©jÃ  Ã©tÃ© traitÃ©e." });
    }

    request.response = {
      text,
      documents,
      submittedAt: new Date(),
    };
    request.status = "submitted";

    recruiter.status = "pending_revalidation";

    await recruiter.save();

    const admins = await Admin.find({
      "permissions.validateRecruiters": true,
      status: "active",
    }).populate("userId", "_id");

    const notifPromises = admins.map((admin) =>
      Notification.create({
        userId: admin.userId._id,
        message: `Le recruteur a rÃ©pondu Ã  une demande de validation.`,
        type: "info",
      }),
    );
    await Promise.all(notifPromises);

    res.json({ msg: "RÃ©ponse soumise. Vous serez notifiÃ© du rÃ©sultat." });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const getRecruiterById = async (req, res) => {
  try {
    const { id } = req.params;

    const recruiter = await Recruiter.findById(id)
      .populate("userId", "nom email role accountStatus createdAt")
      .populate("companyId", "name logo website location description status");

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    const isAdmin = req.user && req.user.role === "admin";

    if (!isAdmin) {
      if (recruiter.status !== "validated") {
        return res.status(404).json({ msg: "Ce profil n'est pas accessible." });
      }

      if (recruiter.companyId?.status !== "active") {
        return res
          .status(404)
          .json({ msg: "L'entreprise de ce recruteur n'est pas active." });
      }
    }

    let responseData = {
      _id: recruiter._id,
      nom: recruiter.userId.nom,
      position: recruiter.position,
      entreprise: {
        _id: recruiter.companyId._id,
        nom: recruiter.companyId.name,
        logo: recruiter.companyId.logo,
        location: recruiter.companyId.location,
        website: recruiter.companyId.website,
        description: recruiter.companyId.description,
      },
      dateCreation: recruiter.createdAt,
    };

    if (isAdmin) {
      responseData.adminDetails = {
        email: recruiter.userId.email,
        telephone: recruiter.telephone,
        status: recruiter.status,
        userStatus: recruiter.userId.accountStatus,
        isAdminOfCompany: recruiter.isAdmin,
        permissions: recruiter.permissions,
        validationRequests: recruiter.validationRequests,
        rejectionReason: recruiter.rejectionReason,
        userId: recruiter.userId._id,
      };
    }

    res.json(responseData);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const getCandidateFullProfile = async (req, res) => {
  try {
    const { candidateId } = req.params;

    const candidate = await Candidate.findById(candidateId)
      .populate("userId", "nom email")
      .select("-favoris");

    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    res.json(candidate);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\skillController.js ===
import Skill from "../models/Skills.js";

export const createSkill = async (req, res) => {
  try {
    const { name, category } = req.body;

    const normalizedName = name.trim();

    const exist = await Skill.findOne({
      name: { $regex: new RegExp(`^${normalizedName}$`, "i") },
    });
    if (exist) return res.status(400).json({ msg: "Ce skill existe dÃ©jÃ ." });

    const newSkill = await Skill.create({ name: normalizedName, category });
    res.status(201).json(newSkill);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getSkills = async (req, res) => {
  try {
    const { search } = req.query;
    let query = {};

    if (search) {
      query.name = { $regex: search, $options: "i" };
    }

    const skills = await Skill.find(query).sort({ name: 1 }).limit(50);
    res.json(skills);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteSkill = async (req, res) => {
  try {
    await Skill.findByIdAndDelete(req.params.id);
    res.json({ msg: "Skill supprimÃ©" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\supportController.js ===
import SupportTicket from "../models/SupportTicket.js";
import Admin from "../models/Admin.js";
import Notification from "../models/Notification.js";
import { logAdminAction } from "../models/AdminLog.js";

export const createTicket = async (req, res) => {
  try {
    const { subject, description, category } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    if (!subject || !description || !category) {
      return res.status(400).json({
        msg: "Sujet, description et catÃ©gorie sont obligatoires.",
      });
    }

    const ticket = await SupportTicket.create({
      userId: req.user.id,
      subject,
      description,
      category,
      attachments,
    });

    const admins = await Admin.find({
      label: ticket.assignedToLabel,
      status: "active",
      "permissions.handleSupportTickets": true,
    }).populate("userId", "_id");

    const notifPromises = admins.map((admin) =>
      Notification.create({
        userId: admin.userId._id,
        message: `Nouveau ticket support: "${subject}"`,
        type: "info",
      })
    );
    await Promise.all(notifPromises);

    res.status(201).json({ msg: "Ticket crÃ©Ã© avec succÃ¨s.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getMyTickets = async (req, res) => {
  try {
    const tickets = await SupportTicket.find({ userId: req.user.id })
      .sort({ createdAt: -1 })
      .select("-messages.adminId");

    res.json(tickets);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getTicketDetails = async (req, res) => {
  try {
    const { ticketId } = req.params;

    const ticket = await SupportTicket.findOne({
      _id: ticketId,
      userId: req.user.id,
    });

    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    res.json(ticket);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const replyToTicket = async (req, res) => {
  try {
    const { ticketId } = req.params;
    const { content } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    if (!content) {
      return res.status(400).json({ msg: "Le contenu est obligatoire." });
    }

    const ticket = await SupportTicket.findOne({
      _id: ticketId,
      userId: req.user.id,
      status: { $nin: ["closed"] },
    });

    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable ou fermÃ©." });
    }

    ticket.messages.push({
      from: "user",
      content,
      attachments,
    });

    if (ticket.status === "awaiting_user") {
      ticket.status = "in_progress";
    }

    await ticket.save();

    if (ticket.assignedTo) {
      const admin = await Admin.findById(ticket.assignedTo).populate("userId");
      if (admin) {
        await Notification.create({
          userId: admin.userId._id,
          message: `Nouvelle rÃ©ponse sur le ticket: "${ticket.subject}"`,
          type: "info",
        });
      }
    }

    res.json({ msg: "RÃ©ponse envoyÃ©e.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== middleware\adminPermissions.js ===
import Admin from "../models/Admin.js";

export const requireAdminPermission = (permission) => {
  return async (req, res, next) => {
    try {
      const admin = await Admin.findOne({ userId: req.user.id });

      if (!admin) {
        return res.status(403).json({ msg: "AccÃ¨s administrateur requis." });
      }

      if (admin.status !== "active") {
        return res
          .status(403)
          .json({ msg: "Votre compte administrateur est suspendu." });
      }

      if (!admin.hasPermission(permission)) {
        return res.status(403).json({
          msg: `Permission "${permission}" requise.`,
          code: "PERMISSION_DENIED",
        });
      }

      req.admin = admin;
      next();
    } catch (err) {
      res.status(500).json({ msg: err.message });
    }
  };
};

export const requireActiveAdmin = async (req, res, next) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin || admin.status !== "active") {
      return res
        .status(403)
        .json({ msg: "AccÃ¨s administrateur actif requis." });
    }

    req.admin = admin;
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== middleware\auth.js ===
import jwt from "jsonwebtoken";

export default function auth(req, res, next) {
  const token = req.header("Authorization");
  if (!token) return res.status(401).json({ msg: "Pas de token fourni" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch {
    res.status(401).json({ msg: "Token invalide" });
  }
}


=== middleware\optionalAuth.js ===
import jwt from "jsonwebtoken";

export const optionalAuth = (req, res, next) => {
  const token = req.header("Authorization");

  if (!token) {
    req.user = null;
    return next();
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
  } catch (err) {
    req.user = null;
  }
  next();
};


=== middleware\requireEmailVerification.js ===
import User from "../models/User.js";

export const requireEmailVerification = async (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({ msg: "Utilisateur non authentifiÃ©." });
  }

  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable." });
    }

    if (!user.emailVerified) {
      return res.status(403).json({
        msg: "Veuillez confirmer votre adresse e-mail pour effectuer cette action.",
        code: "EMAIL_NOT_VERIFIED",
      });
    }
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== middleware\roles.js ===
export const authRole = (roles = []) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ msg: "AccÃ¨s refusÃ© : rÃ´le non autorisÃ©" });
    }
    next();
  };
};


=== models\Admin.js ===
import mongoose from "mongoose";

const adminSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true,
    },

    label: {
      type: String,
      enum: [
        "super_admin",
        "support",
        "technical",
        "operational",
        "recruitment",
        "moderation",
        "product",
      ],
      default: "support",
    },

    permissions: {
      createAdmin: { type: Boolean, default: false },
      deleteAdmin: { type: Boolean, default: false },
      editAdminPermissions: { type: Boolean, default: false },
      assignAdminLabels: { type: Boolean, default: false },

      validateOffers: { type: Boolean, default: false },
      validateRecruiters: { type: Boolean, default: false },
      validateCompanies: { type: Boolean, default: false },

      banUsers: { type: Boolean, default: false },
      suspendUsers: { type: Boolean, default: false },

      proposeCandidates: { type: Boolean, default: false },

      manageAnnouncements: { type: Boolean, default: false },
      sendNotifications: { type: Boolean, default: false },

      handleSupportTickets: { type: Boolean, default: false },

      viewStats: { type: Boolean, default: true },
      viewLogs: { type: Boolean, default: false },
    },

    status: {
      type: String,
      enum: ["active", "suspended", "revoked"],
      default: "active",
    },
    suspensionReason: String,
    suspendedUntil: Date,

    createdBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
  },
  { timestamps: true }
);

adminSchema.methods.hasPermission = function (permission) {
  if (this.label === "super_admin") return true;
  return this.permissions[permission] === true;
};

export default mongoose.model("Admin", adminSchema);


=== models\AdminLog.js ===
import mongoose from "mongoose";

const adminLogSchema = new mongoose.Schema(
  {
    adminId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    action: {
      type: String,
      enum: [
        "admin_created",
        "admin_deleted",
        "admin_suspended",
        "admin_reactivated",
        "admin_permissions_updated",
        "admin_label_changed",
        "recruiter_validated",
        "recruiter_rejected",
        "recruiter_suspended",
        "recruiter_documents_requested",
        "recruiter_revalidated",
        "company_validated",
        "company_rejected",
        "company_suspended",
        "offer_approved",
        "offer_rejected",
        "offer_changes_requested",
        "offer_deleted",
        "user_banned",
        "user_unbanned",
        "user_message_sent",
        "candidate_proposed",
        "announcement_created",
        "announcement_updated",
        "announcement_deleted",
        "ticket_responded",
        "ticket_closed",
        "ticket_reassigned",
        "company_created_by_admin",
        "company_updated_by_admin",
        "company_admin_assigned",
        "company_admin_removed",
      ],
      required: true,
      index: true,
    },
    targetType: {
      type: String,
      enum: [
        "user",
        "recruiter",
        "company",
        "offer",
        "application",
        "announcement",
        "ticket",
        "admin",
      ],
    },
    targetId: { type: mongoose.Schema.Types.ObjectId },
    details: { type: mongoose.Schema.Types.Mixed },
    ip: { type: String },
    userAgent: { type: String },
  },
  { timestamps: true }
);

adminLogSchema.index({ createdAt: -1 });
adminLogSchema.index({ action: 1, createdAt: -1 });

const AdminLog = mongoose.model("AdminLog", adminLogSchema);

export const logAdminAction = async (
  adminId,
  action,
  target = {},
  details = {},
  req = null
) => {
  try {
    await AdminLog.create({
      adminId,
      action,
      targetType: target.type,
      targetId: target.id,
      details,
      ip: req?.ip,
      userAgent: req?.get("User-Agent"),
    });
  } catch (err) {
    console.error("Erreur lors du logging admin:", err);
  }
};

export default AdminLog;


=== models\Announcement.js ===
import mongoose from "mongoose";

const announcementSchema = new mongoose.Schema(
  {
    title: { type: String, required: true },
    content: { type: String, required: true },
    targetAudience: {
      type: String,
      enum: ["all", "admins", "recruiters", "candidates"],
      default: "all",
    },
    status: {
      type: String,
      enum: ["draft", "scheduled", "published", "expired", "archived"],
      default: "draft",
    },
    publishAt: { type: Date },
    expiresAt: { type: Date },
    priority: {
      type: String,
      enum: ["low", "normal", "high", "critical"],
      default: "normal",
    },
    displayType: {
      type: String,
      enum: ["banner", "modal", "inline"],
      default: "inline",
    },
    viewCount: { type: Number, default: 0 },
    dismissedBy: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }],
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    updatedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
  },
  { timestamps: true }
);

announcementSchema.index({ status: 1, publishAt: 1, expiresAt: 1 });

export default mongoose.model("Announcement", announcementSchema);


=== models\Application.js ===
import mongoose from "mongoose";

const applicationSchema = new mongoose.Schema(
  {
    offerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Offer",
      required: true,
    },
    candidateId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Candidate",
      required: true,
    },

    
    source: {
      type: String,
      enum: ["direct", "admin_proposal"],
      default: "direct",
    },
    proposedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User", 
    },
    proposedAt: Date,

    
    candidateStatus: {
      type: String,
      enum: [
        "envoyee",
        "en_cours",
        "retenue",
        "non_retenue",
        "retiree",
        "cancelled",
      ],
      default: "envoyee",
    },

    recruiterStatus: {
      type: String,
      enum: [
        "nouvelle",
        "consultee",
        "preselection",
        "en_discussion",
        "entretien_planifie",
        "entretien_termine",
        "retenue",
        "refusee",
        "retiree_par_candidat",
        "annulee_par_candidat",
      ],
      default: "nouvelle",
    },

    
    cvUrl: { type: String, required: true },
    coverLetter: { type: String },

    isRepostulation: { type: Boolean, default: false },

    
    offerSnapshot: {
      titre: String,
      entrepriseNom: String,
      companyId: { type: mongoose.Schema.Types.ObjectId, ref: "Company" },
      location: String,
      type: { type: String },
    },

    
    recruiterNotes: {
      type: String,
      maxLength: 2000,
    },

    
    isStarred: { type: Boolean, default: false }, 
    seenByRecruiter: { type: Boolean, default: false },
    seenAt: Date,

    
    datePostulation: { type: Date, default: Date.now },
    dateDecision: Date, 
    withdrawnAt: Date, 
    withdrawReason: String,

    
    statusHistory: [
      {
        candidateStatus: String,
        recruiterStatus: String,
        changedBy: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
        },
        changedAt: { type: Date, default: Date.now },
        note: String,
      },
    ],
  },
  { timestamps: true },
);


applicationSchema.index({ offerId: 1, candidateId: 1 }, { unique: true });


applicationSchema.index({ offerId: 1, recruiterStatus: 1 });
applicationSchema.index({ candidateId: 1, candidateStatus: 1 });
applicationSchema.index({ offerId: 1, datePostulation: -1 });
applicationSchema.index({ recruiterStatus: 1, isStarred: 1 });

export default mongoose.model("Application", applicationSchema);


=== models\Candidate.js ===
import mongoose from "mongoose";

const educationSchema = new mongoose.Schema({
  institut: { type: String, required: true },
  degree: { type: String, required: true },
  fieldOfStudy: { type: String },
  startDate: { type: Date },
  endDate: { type: Date },
  description: { type: String },
});

const experienceSchema = new mongoose.Schema({
  jobTitle: { type: String, required: true },
  company: { type: String, required: true },
  startDate: { type: Date },
  endDate: { type: Date },
  description: { type: String },
});

const skillSchema = new mongoose.Schema({
  name: { type: String, required: true },
  level: {
    type: String,
    enum: ["beginner", "intermediate", "expert"],
    default: "beginner",
  },
});

const candidateSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true,
    },

    dateOfBirth: { type: Date },
    bio: { type: String, maxLength: 1000 },
    gender: {
      type: String,
      enum: ["homme", "femme"],
    },

    residence: {
      wilaya: { type: String },
      commune: { type: String },
      address: { type: String },
    },

    searchPreferences: {
      wilayas: [{ type: String }],
      remoteOnly: { type: Boolean, default: false },
      willingToRelocate: { type: Boolean, default: false },
    },

    desiredPosition: { type: String },

    desiredJobTypes: [
      {
        type: String,
        enum: [
          "full-time",
          "part-time",
          "remote",
          "internship",
          "freelance",
          "CDI",
          "CDD",
        ],
      },
    ],

    profilePicture: { type: String },
    telephone: { type: String },
    links: {
      website: { type: String },
      linkedin: { type: String },
      github: { type: String },
      portfolio: { type: String },
    },

    autoriserProposition: { type: Boolean, default: true },

    favoris: [
      {
        offerId: { type: mongoose.Schema.Types.ObjectId, ref: "Offer" },
        savedAt: { type: Date, default: Date.now },
      },
    ],

    cvs: [
      {
        url: { type: String, required: true },
        dateDepot: { type: Date, default: Date.now },
        score: { type: Number, default: 0 },
      },
    ],

    skills: [skillSchema],
    experiences: [experienceSchema],
    education: [educationSchema],
  },
  { timestamps: true }
);
candidateSchema.index({ userId: 1 });
candidateSchema.index({ "residence.wilaya": 1 });
candidateSchema.index({ autoriserProposition: 1 });
export default mongoose.model("Candidate", candidateSchema);


=== models\Company.js ===
import mongoose from "mongoose";

const companySchema = new mongoose.Schema(
  {
    name: { type: String, required: true, unique: true },
    logo: { type: String },
    website: { type: String },
    description: { type: String },
    industry: { type: String },
    location: { type: String },
    size: { type: String },

    status: {
      type: String,
      enum: ["pending", "active", "rejected"],
      default: "pending",
    },
  },
  { timestamps: true }
);
companySchema.index({ status: 1 });
companySchema.index({ name: "text" });
export default mongoose.model("Company", companySchema);


=== models\Conversation.js ===
import mongoose from "mongoose";

const messageSchema = new mongoose.Schema({
  senderId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
  },
  senderType: {
    type: String,
    enum: ["candidate", "recruiter"],
    required: true,
  },
  content: { type: String, required: true, maxLength: 5000 },
  attachments: [String],
  readAt: Date,
  createdAt: { type: Date, default: Date.now },
});

const conversationSchema = new mongoose.Schema(
  {
    applicationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Application",
      required: true,
      unique: true, 
    },
    offerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Offer",
      required: true,
    },
    candidateId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Candidate",
      required: true,
    },
    recruiterId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Recruiter",
      required: true,
    },

    
    openedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    openedAt: { type: Date, default: Date.now },

    messages: [messageSchema],

    
    unreadByCandidate: { type: Number, default: 0 },
    unreadByRecruiter: { type: Number, default: 0 },

    lastMessageAt: Date,

    
    status: {
      type: String,
      enum: ["active", "archived", "closed"],
      default: "active",
    },
  },
  { timestamps: true }
);


conversationSchema.index({ candidateId: 1, lastMessageAt: -1 });
conversationSchema.index({ recruiterId: 1, lastMessageAt: -1 });
conversationSchema.index({ applicationId: 1 });

export default mongoose.model("Conversation", conversationSchema);


=== models\Interview.js ===
import mongoose from "mongoose";

const interviewSchema = new mongoose.Schema(
  {
    applicationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Application",
      required: true,
    },
    offerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Offer",
      required: true,
    },
    candidateId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Candidate",
      required: true,
    },
    recruiterId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Recruiter",
      required: true,
    },

    
    type: {
      type: String,
      enum: ["phone", "video", "in_person"],
      default: "video",
    },
    scheduledAt: { type: Date, required: true },
    duration: { type: Number, default: 30 }, 
    location: String, 
    meetingLink: String, 
    phoneNumber: String, 

    
    status: {
      type: String,
      enum: [
        "proposed", 
        "confirmed", 
        "rescheduled_by_candidate", 
        "rescheduled_by_recruiter", 
        "cancelled_by_candidate",
        "cancelled_by_recruiter",
        "completed", 
        "no_show_candidate", 
        "no_show_recruiter", 
      ],
      default: "proposed",
    },

    
    proposedAlternative: {
      date: Date,
      proposedBy: {
        type: String,
        enum: ["candidate", "recruiter"],
      },
      message: String,
      proposedAt: Date,
    },

    
    recruiterNotes: String, 
    preparationNotes: String, 

    
    feedback: {
      rating: { type: Number, min: 1, max: 5 },
      notes: String,
      strengths: [String],
      concerns: [String],
      recommendation: {
        type: String,
        enum: ["strong_yes", "yes", "maybe", "no", "strong_no"],
      },
      completedAt: Date,
    },

    
    reminderSentToCandidate: { type: Boolean, default: false },
    reminderSentToRecruiter: { type: Boolean, default: false },
  },
  { timestamps: true }
);


interviewSchema.index({ applicationId: 1 });
interviewSchema.index({ candidateId: 1, status: 1 });
interviewSchema.index({ recruiterId: 1, scheduledAt: 1 });
interviewSchema.index({ status: 1, scheduledAt: 1 });
interviewSchema.index({ scheduledAt: 1 }); 

export default mongoose.model("Interview", interviewSchema);


=== models\Notification.js ===
import mongoose from "mongoose";

const notificationSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    message: { type: String, required: true },
    type: {
      type: String,
      enum: ["info", "alerte", "validation"],
      default: "info",
    },
    lu: { type: Boolean, default: false },
    date: { type: Date, default: Date.now },
  },
  { timestamps: true }
);

notificationSchema.index({ userId: 1, lu: 1 });
notificationSchema.index({ userId: 1, date: -1 });

export default mongoose.model("Notification", notificationSchema);


=== models\Offer.js ===
import mongoose from "mongoose";

const offerSchema = new mongoose.Schema(
  {
    recruteurId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Recruiter",
      required: true,
    },
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
    },

    titre: { type: String, required: true },
    description: { type: String, required: true },
    requirements: { type: String, required: true },

    domaine: { type: String },
    type: {
      type: String,
      enum: [
        "full-time",
        "part-time",
        "remote",
        "internship",
        "freelance",
        "CDI",
        "CDD",
      ],
      default: "full-time",
    },
    salaryMin: { type: Number },
    salaryMax: { type: Number },
    experienceLevel: { type: String, enum: ["junior", "mid", "senior"] },
    skills: [{ type: String, index: true }],
    wilaya: { type: String },

    allowRepostulation: { type: Boolean, default: true },

    validationStatus: {
      type: String,
      enum: ["draft", "pending", "approved", "rejected", "changes_requested"],
      default: "pending",
    },
    validationHistory: [
      {
        status: String,
        message: String,
        adminId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        date: { type: Date, default: Date.now },
      },
    ],
    rejectionReason: String,

    visibility: {
      isPublic: { type: Boolean, default: true },
      acceptsDirectApplications: { type: Boolean, default: true },
    },

    candidateSearchMode: {
      type: String,
      enum: ["disabled", "manual", "automatic"],
      default: "disabled",
    },

    actif: { type: Boolean, default: false },
    datePublication: { type: Date },
    nombreCandidatures: { type: Number, default: 0 },
  },
  { timestamps: true },
);

offerSchema.methods.isVisible = function () {
  return this.validationStatus === "approved" && this.actif;
};

offerSchema.index({ titre: "text", description: "text", skills: "text" });

export default mongoose.model("Offer", offerSchema);


=== models\Recruiter.js ===
import mongoose from "mongoose";

const recruiterSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true,
    },
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
    },

    telephone: { type: String },
    position: { type: String },

    status: {
      type: String,
      enum: [
        "pending_validation",
        "pending_documents",
        "pending_info",
        "pending_info_and_documents",
        "pending_revalidation",
        "validated",
        "rejected",
      ],
      default: "pending_validation",
    },

    rejectionReason: String,

    validationRequests: [
      {
        type: {
          type: String,
          enum: ["document", "information", "clarification"],
        },
        message: String,
        requiredFields: [String],
        requiredDocuments: Number,
        response: {
          text: String,
          documents: [String],
          submittedAt: Date,
        },
        status: {
          type: String,
          enum: ["pending", "submitted", "approved", "rejected"],
          default: "pending",
        },
        createdAt: { type: Date, default: Date.now },
        reviewedAt: Date,
        reviewedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
      },
    ],

    permissions: {
      postJobs: { type: Boolean, default: true },
      reviewCandidates: { type: Boolean, default: true },
      scheduleInterviews: { type: Boolean, default: true },
      manageTeam: { type: Boolean, default: false },
      editCompany: { type: Boolean, default: false },
    },

    isAdmin: { type: Boolean, default: false },

    favoriteCandidates: [
      {
        candidateId: { type: mongoose.Schema.Types.ObjectId, ref: "Candidate" },
        savedAt: { type: Date, default: Date.now },
        notes: String,
      },
    ],

    invitedBy: { type: mongoose.Schema.Types.ObjectId, ref: "Recruiter" },
    invitedAt: Date,
  },
  { timestamps: true }
);

recruiterSchema.index({ userId: 1 });
recruiterSchema.index({ companyId: 1 });
recruiterSchema.index({ status: 1 });

recruiterSchema.methods.canPerformActions = function () {
  return this.status === "validated";
};

recruiterSchema.methods.hasPendingRequests = function () {
  return this.validationRequests.some((r) => r.status === "pending");
};

export default mongoose.model("Recruiter", recruiterSchema);


=== models\Skills.js ===
import mongoose from "mongoose";

const skillSchema = new mongoose.Schema({
  name: { type: String, required: true, unique: true },
  category: { type: String },
});

export default mongoose.model("Skill", skillSchema);


=== models\SupportTicket.js ===
import mongoose from "mongoose";

const supportTicketSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    subject: { type: String, required: true },
    description: { type: String, required: true },
    category: {
      type: String,
      enum: [
        "support_understanding",
        "technical_issue",
        "account_profile",
        "company_recruitment",
        "documents_verification",
        "special_request",
        "feedback_suggestion",
      ],
      required: true,
    },
    assignedToLabel: {
      type: String,
      enum: [
        "support",
        "technical",
        "operational",
        "recruitment",
        "moderation",
        "super_admin",
        "product",
      ],
    },
    assignedTo: { type: mongoose.Schema.Types.ObjectId, ref: "Admin" },
    status: {
      type: String,
      enum: ["open", "in_progress", "awaiting_user", "resolved", "closed"],
      default: "open",
    },
    priority: {
      type: String,
      enum: ["low", "medium", "high", "urgent"],
      default: "medium",
    },
    attachments: [{ type: String }],
    messages: [
      {
        from: { type: String, enum: ["user", "admin"], required: true },
        content: { type: String, required: true },
        adminId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        attachments: [String],
        createdAt: { type: Date, default: Date.now },
      },
    ],
    chatEnabled: { type: Boolean, default: false },
    resolvedAt: Date,
    closedAt: Date,
  },
  { timestamps: true }
);

supportTicketSchema.pre("save", function (next) {
  if (this.isNew && !this.assignedToLabel) {
    const categoryToLabel = {
      support_understanding: "support",
      technical_issue: "technical",
      account_profile: "operational",
      company_recruitment: "recruitment",
      documents_verification: "moderation",
      special_request: "super_admin",
      feedback_suggestion: "product",
    };
    this.assignedToLabel = categoryToLabel[this.category] || "support";
  }
  next();
});

supportTicketSchema.index({ status: 1, createdAt: -1 });
supportTicketSchema.index({ assignedToLabel: 1, status: 1 });

export default mongoose.model("SupportTicket", supportTicketSchema);


=== models\User.js ===
import mongoose from "mongoose";

const userSchema = new mongoose.Schema(
  {
    nom: { type: String },
    email: { type: String, required: true, unique: true },
    motDePasse: { type: String, required: true },
    role: {
      type: String,
      enum: ["candidat", "recruteur", "admin"],
      required: true,
    },

    emailVerified: {
      type: Boolean,
      default: false,
    },

    accountStatus: {
      type: String,
      enum: ["active", "suspended", "banned"],
      default: "active",
    },
    suspensionReason: String,
    suspendedUntil: Date,

    derniereConnexion: Date,
  },
  { timestamps: true }
);

userSchema.index({ email: 1 });
userSchema.index({ role: 1 });
userSchema.index({ createdAt: -1 });
userSchema.index({ accountStatus: 1 });

userSchema.methods.canLogin = function () {
  if (this.accountStatus === "banned") return false;
  if (this.accountStatus === "suspended") {
    if (this.suspendedUntil && new Date() > this.suspendedUntil) {
      return true;
    }
    return false;
  }
  return true;
};

export default mongoose.model("User", userSchema);


=== routes\adminRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { authRole } from "../middleware/roles.js";
import Admin from "../models/Admin.js";
import {
  getRecruiters,
  validateRecruiter,
  rejectRecruiter,
  requestRecruiterDocuments,
  requestMultipleValidationItems,
  cancelValidationRequest,
  getAllUsers,
  banUser,
  unBanUser,
  sendMessageToUser,
  getCandidateDetailsAdmin,
  createAdmin,
  deleteAdmin,
  getAllAdmins,
  suspendAdmin,
  updateAdminPermissions,
  updateAdminLabel,
  getPendingCompanies,
  validateCompany,
  rejectCompany,
  getCompanyDetailsAdmin,
  getAllCompanies,
  getPendingOffers,
  approveOffer,
  rejectOffer,
  deleteOfferAdmin,
  getManualSelectionOffers,
  proposeCandidateToOffer,
  toggleOfferVisibility,
  getGlobalStats,
  getTrends,
  getAdminLogs,
  createCompanyByAdmin,
  getCompanyRecruiters,
  assignCompanyAdmin,
  removeCompanyAdmin,
  updateCompanyByAdmin,
  getOfferDetailsAdmin,
  updateOfferByAdmin,
} from "../controllers/adminController.js";

import { createSkill, deleteSkill } from "../controllers/skillController.js";

import {
  createAnnouncement,
  getAllAnnouncements,
  updateAnnouncement,
  deleteAnnouncement,
} from "../controllers/announcementController.js";

import {
  getTicketsByLabel,
  getTicketById,
  respondToTicket,
  reassignTicket,
  closeTicket,
} from "../controllers/adminSupportController.js";

import { uploadAttachments } from "../config/multer.js";

const router = express.Router();

router.use(auth, authRole(["admin"]));

const requirePermission = (permission) => async (req, res, next) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin) {
      return res.status(403).json({ msg: "Admin introuvable" });
    }

    if (admin.status !== "active") {
      return res.status(403).json({ msg: "Compte admin suspendu" });
    }

    if (!admin.hasPermission(permission)) {
      return res.status(403).json({
        msg: `Permission "${permission}" requise`,
        code: "PERMISSION_DENIED",
      });
    }

    req.admin = admin;
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

router.get("/stats/global", requirePermission("viewStats"), getGlobalStats);
router.get("/stats/trends", requirePermission("viewStats"), getTrends);

router.get(
  "/recruteurs",
  requirePermission("validateRecruiters"),
  getRecruiters
);
router.put(
  "/recruteurs/valider/:id",
  requirePermission("validateRecruiters"),
  validateRecruiter
);
router.put(
  "/recruteurs/rejeter/:id",
  requirePermission("validateRecruiters"),
  rejectRecruiter
);
router.post(
  "/recruteurs/:recruiterId/request-documents",
  requirePermission("validateRecruiters"),
  requestRecruiterDocuments
);
router.post(
  "/recruteurs/:recruiterId/request-multiple",
  requirePermission("validateRecruiters"),
  requestMultipleValidationItems
);

router.put(
  "/recruteurs/:id/cancel-request",
  requirePermission("validateRecruiters"),
  cancelValidationRequest
);

router.get("/users", getAllUsers);
router.put("/users/ban/:id", requirePermission("banUsers"), banUser);
router.put("/users/unban/:id", requirePermission("banUsers"), unBanUser);
router.post(
  "/users/message/:id",
  requirePermission("sendNotifications"),
  sendMessageToUser
);

router.get("/admins", requirePermission("viewStats"), getAllAdmins);
router.post("/admins", requirePermission("createAdmin"), createAdmin);
router.delete("/admins/:id", requirePermission("deleteAdmin"), deleteAdmin);
router.put(
  "/admins/:id/suspend",
  requirePermission("deleteAdmin"),
  suspendAdmin
);
router.put(
  "/admins/:id/permissions",
  requirePermission("editAdminPermissions"),
  updateAdminPermissions
);
router.put(
  "/admins/:id/label",
  requirePermission("assignAdminLabels"),
  updateAdminLabel
);

router.get(
  "/entreprises/all",
  requirePermission("validateCompanies"),
  getAllCompanies
);

router.get(
  "/entreprises/en-attente",
  requirePermission("validateCompanies"),
  getPendingCompanies
);
router.put(
  "/entreprises/valider/:id",
  requirePermission("validateCompanies"),
  validateCompany
);
router.put(
  "/entreprises/rejeter/:id",
  requirePermission("validateCompanies"),
  rejectCompany
);

router.get(
  "/entreprises/:companyId",
  requirePermission("validateCompanies"),
  getCompanyDetailsAdmin
);

router.put(
  "/entreprises/:id",
  requirePermission("validateCompanies"),
  updateCompanyByAdmin
);

router.get(
  "/offres/en-attente",
  requirePermission("validateOffers"),
  getPendingOffers
);
router.put(
  "/offres/:id/approve",
  requirePermission("validateOffers"),
  approveOffer
);
router.put(
  "/offres/:id/reject",
  requirePermission("validateOffers"),
  rejectOffer
);
router.delete(
  "/offres/:id",
  requirePermission("validateOffers"),
  deleteOfferAdmin
);
router.get(
  "/offres/manuelles",
  requirePermission("proposeCandidates"),
  getManualSelectionOffers
);
router.post(
  "/offres/proposer",
  requirePermission("proposeCandidates"),
  proposeCandidateToOffer
);

router.get(
  "/offres/:id/details",
  requirePermission("validateOffers"),
  getOfferDetailsAdmin
);
router.put(
  "/offres/:id/update",
  requirePermission("validateOffers"),
  updateOfferByAdmin
);
router.put(
  "/offres/:id/visibility",
  requirePermission("validateOffers"),
  toggleOfferVisibility
);

router.get(
  "/candidates/:id",
  requirePermission("viewStats"),
  getCandidateDetailsAdmin
);

router.get(
  "/announcements",
  requirePermission("manageAnnouncements"),
  getAllAnnouncements
);
router.post(
  "/announcements",
  requirePermission("manageAnnouncements"),
  createAnnouncement
);
router.put(
  "/announcements/:id",
  requirePermission("manageAnnouncements"),
  updateAnnouncement
);
router.delete(
  "/announcements/:id",
  requirePermission("manageAnnouncements"),
  deleteAnnouncement
);

router.get(
  "/tickets",
  requirePermission("handleSupportTickets"),
  getTicketsByLabel
);
router.get(
  "/tickets/:ticketId",
  requirePermission("handleSupportTickets"),
  getTicketById
);
router.post(
  "/tickets/:ticketId/respond",
  requirePermission("handleSupportTickets"),
  uploadAttachments.array("attachments", 3),
  respondToTicket
);
router.put(
  "/tickets/:ticketId/reassign",
  requirePermission("handleSupportTickets"),
  reassignTicket
);
router.put(
  "/tickets/:ticketId/close",
  requirePermission("handleSupportTickets"),
  closeTicket
);

router.get("/logs", requirePermission("viewLogs"), getAdminLogs);

router.post("/skills", createSkill);
router.delete("/skills/:id", deleteSkill);

router.post(
  "/entreprises/create",
  requirePermission("validateCompanies"),
  createCompanyByAdmin
);

router.get(
  "/entreprises/:companyId/recruiters",
  requirePermission("validateCompanies"),
  getCompanyRecruiters
);

router.post(
  "/entreprises/assign-admin",
  requirePermission("validateCompanies"),
  assignCompanyAdmin
);

router.delete(
  "/entreprises/remove-admin/:recruiterId",
  requirePermission("validateCompanies"),
  removeCompanyAdmin
);

export default router;


=== routes\announcementRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import {
  getActiveAnnouncements,
  dismissAnnouncement,
} from "../controllers/announcementController.js";

const router = express.Router();

router.use(auth);

router.get("/active", getActiveAnnouncements);

router.post("/:announcementId/dismiss", dismissAnnouncement);

export default router;


=== routes\authRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import {
  register,
  login,
  verifyEmail,
  resendConfirmationCode,
  changeEmail,
  getCompanies,
} from "../controllers/authController.js";

const router = express.Router();

router.post("/register", register);
router.post("/login", login);

router.post("/verify-email", auth, verifyEmail);
router.post("/resend-code", auth, resendConfirmationCode);
router.put("/change-email", auth, changeEmail);

router.get("/companies", getCompanies);

export default router;


=== routes\candidateRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { authRole } from "../middleware/roles.js";
import { requireEmailVerification } from "../middleware/requireEmailVerification.js";

import { uploadCV, uploadImage, uploadAttachments } from "../config/multer.js";


import {
  updateProfile,
  uploadProfilePicture,
  uploadCandidateCV,
  deleteCV,
  applyToOffer, 
  updateAccount,
  getProfile,
  addToFavorites,
  removeFromFavorites,
  getFavorites,
  addSkill,
  updateSkill,
  deleteSkill,
  addExperience,
  updateExperience,
  deleteExperience,
  addEducation,
  updateEducation,
  deleteEducation,
  getCandidateStats,
  getRecommendedOffers,
} from "../controllers/candidateController.js";


import {
  getMyApplications,
  getApplicationDetail,
  withdrawApplication,
  cancelApplication,
  checkApplicationStatus,
} from "../controllers/candidateApplicationController.js";

import {
  getCandidateInterviews,
  acceptInterview,
  declineInterview,
  proposeAlternativeDate,
} from "../controllers/interviewController.js";

import {
  getCandidateConversations,
  getConversationMessages,
  sendMessageAsCandidate,
} from "../controllers/conversationController.js";

const router = express.Router();

router.use(auth, authRole(["candidat"]));


router.get("/profil", getProfile);
router.put("/profil", updateProfile);
router.put("/compte", updateAccount);
router.get("/stats", getCandidateStats);

router.post("/upload-photo", uploadImage.single("photo"), uploadProfilePicture);
router.post("/upload-cv", uploadCV.single("cv"), uploadCandidateCV);
router.delete("/delete-cv/:cvId", deleteCV);

router.post("/profil/skills", addSkill);
router.put("/profil/skills/:skillId", updateSkill);
router.delete("/profil/skills/:skillId", deleteSkill);

router.post("/profil/experiences", addExperience);
router.put("/profil/experiences/:experienceId", updateExperience);
router.delete("/profil/experiences/:experienceId", deleteExperience);

router.post("/profil/education", addEducation);
router.put("/profil/education/:educationId", updateEducation);
router.delete("/profil/education/:educationId", deleteEducation);

router.get("/favorites", getFavorites);
router.post("/favorites/:offerId", addToFavorites);
router.delete("/favorites/:offerId", removeFromFavorites);
router.get("/recommended-offers", getRecommendedOffers);


router.post("/postuler", requireEmailVerification, applyToOffer);




router.get("/applications/check/:offerId", checkApplicationStatus);
router.get("/applications", getMyApplications);
router.get("/applications/:applicationId", getApplicationDetail);
router.delete("/applications/:applicationId", withdrawApplication);
router.delete("/applications/:applicationId/cancel", cancelApplication);


router.get("/interviews", getCandidateInterviews);
router.put("/interviews/:interviewId/accept", acceptInterview);
router.put("/interviews/:interviewId/decline", declineInterview);
router.put("/interviews/:interviewId/propose-date", proposeAlternativeDate);


router.get("/conversations", getCandidateConversations);
router.get("/conversations/:conversationId", getConversationMessages);
router.post(
  "/conversations/:conversationId/messages",
  uploadAttachments.array("attachments", 3),
  sendMessageAsCandidate,
);

export default router;


=== routes\notificationRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import {
  getMyNotifications,
  getUnreadCount,
  markAsRead,
} from "../controllers/notificationController.js";

const router = express.Router();

router.use(auth);

router.get("/", getMyNotifications);
router.get("/unread-count", getUnreadCount);
router.put("/:id/read", markAsRead);

export default router;


=== routes\offerRoutes.js ===
import express from "express";
import {
  getAllActiveOffers,
  getOfferDetails,
} from "../controllers/offerController.js";

const router = express.Router();

router.get("/", getAllActiveOffers);

router.get("/:id", getOfferDetails);

export default router;


=== routes\recruiterRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { optionalAuth } from "../middleware/optionalAuth.js";
import { authRole } from "../middleware/roles.js";
import { requireEmailVerification } from "../middleware/requireEmailVerification.js";

import { uploadImage, uploadAttachments } from "../config/multer.js";


import {
  getRecruiterById,
  createOffer,
  getMyOffers,
  updateOffer,
  deactivateOffer,
  updateRecruiterProfile,
  updateCompanyDetails,
  getRecruiterDashboard,
  getRecruiterProfileEndpoint,
  getCompanyTeam,
  getOfferStats,
  submitValidationResponse,
  getCandidateFullProfile,
} from "../controllers/recruiterController.js";


import {
  getOfferApplications, 
  getAllApplications,
  markAsSeen,
  updateRecruiterStatus,
  toggleStarred,
  updateNotes,
} from "../controllers/recruiterApplicationController.js";

import {
  proposeInterview,
  getRecruiterInterviews,
  acceptAlternativeDate,
  rescheduleByRecruiter,
  cancelInterviewByRecruiter,
  completeInterview,
} from "../controllers/interviewController.js";

import {
  getRecruiterConversations,
  openConversation,
  sendMessageAsRecruiter,
} from "../controllers/conversationController.js";

const router = express.Router();


router.get("/public/:id", optionalAuth, getRecruiterById);


router.use(auth, authRole(["recruteur"]));


router.get("/profile", getRecruiterProfileEndpoint);
router.put("/profile", updateRecruiterProfile);
router.get("/candidates/:candidateId", getCandidateFullProfile);
router.get("/dashboard", getRecruiterDashboard);

router.post(
  "/validation-response",
  uploadAttachments.array("documents", 5),
  submitValidationResponse
);

router.post("/offers", requireEmailVerification, createOffer);
router.get("/my-offers", getMyOffers);
router.put("/offers/:id", updateOffer);
router.put("/offers/:id/deactivate", deactivateOffer);
router.get("/offers/:offerId/stats", getOfferStats);

router.put("/company", updateCompanyDetails);
router.get("/company/team", getCompanyTeam);




router.get("/offers/:offerId/applications", getOfferApplications); 
router.get("/applications", getAllApplications);
router.put("/applications/:applicationId/seen", markAsSeen);
router.put("/applications/:applicationId/status", updateRecruiterStatus); 
router.put("/applications/:applicationId/star", toggleStarred);
router.put("/applications/:applicationId/notes", updateNotes);


router.get("/interviews", getRecruiterInterviews);
router.post("/applications/:applicationId/interviews", proposeInterview);
router.put(
  "/interviews/:interviewId/accept-alternative",
  acceptAlternativeDate
);
router.put("/interviews/:interviewId/reschedule", rescheduleByRecruiter);
router.put("/interviews/:interviewId/cancel", cancelInterviewByRecruiter);
router.put("/interviews/:interviewId/complete", completeInterview);


router.get("/conversations", getRecruiterConversations);
router.post("/applications/:applicationId/conversation", openConversation);
router.post(
  "/conversations/:conversationId/messages",
  uploadAttachments.array("attachments", 3),
  sendMessageAsRecruiter
);

export default router;


=== routes\skillRoutes.js ===
import express from "express";
import { getSkills } from "../controllers/skillController.js";
import auth from "../middleware/auth.js";

const router = express.Router();

router.get("/", auth, getSkills);

export default router;


=== routes\supportRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import * as supportController from "../controllers/supportController.js";
import { uploadAttachments } from "../config/multer.js";

const router = express.Router();

router.use(auth);

router.post(
  "/tickets",
  uploadAttachments.array("attachments", 5),
  supportController.createTicket
);
router.get("/tickets", supportController.getMyTickets);
router.get("/tickets/:ticketId", supportController.getTicketDetails);
router.post(
  "/tickets/:ticketId/reply",
  uploadAttachments.array("attachments", 3),
  supportController.replyToTicket
);

export default router;


=== startup\seedAdmin.js ===
import bcrypt from "bcryptjs";
import User from "../models/User.js";
import Admin from "../models/Admin.js";

export const seedAdmin = async () => {
  try {
    const exist = await User.findOne({ role: "admin" });
    if (exist) {
      console.log("ðŸ‘‘ Admin dÃ©jÃ  existant.");
      return;
    }

    const hash = await bcrypt.hash("admin", 10);

    const user = await User.create({
      nom: "Super Admin",
      email: "admin@recrutement.com",
      motDePasse: hash,
      role: "admin",
      emailVerified: true,
      accountStatus: "active",
    });

    await Admin.create({
      userId: user._id,
      label: "super_admin",
      status: "active",
      permissions: {
        createAdmin: true,
        deleteAdmin: true,
        editAdminPermissions: true,
        assignAdminLabels: true,
        validateOffers: true,
        validateRecruiters: true,
        validateCompanies: true,
        banUsers: true,
        suspendUsers: true,
        proposeCandidates: true,
        manageAnnouncements: true,
        sendNotifications: true,
        handleSupportTickets: true,
        viewStats: true,
        viewLogs: true,
      },
    });

    console.log("âœ… Super Admin crÃ©Ã© avec toutes les permissions");
  } catch (err) {
    console.error("âŒ Erreur crÃ©ation admin:", err.message);
  }
};


=== startup\setupFolders.js ===
import fs from "fs";

export default function setupFolders() {
  const folders = [
    "uploads",
    "uploads/cv",
    "uploads/images",
    "uploads/attachments",
    "uploads/documents",
  ];

  folders.forEach((dir) => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
      console.log(`ðŸ“ Dossier crÃ©Ã© : ${dir}`);
    }
  });
}


=== utils\profileCompletion.js ===
export const calculateProfileCompletion = (candidate, user) => {
  const checks = {
    nom: !!user?.nom,
    telephone: !!candidate?.telephone,
    residence: !!candidate?.residence?.wilaya,

    bio: !!candidate?.bio,
    dateOfBirth: !!candidate?.dateOfBirth,
    gender: !!candidate?.gender,
    profilePicture: !!candidate?.profilePicture,

    desiredPosition: !!candidate?.desiredPosition,
    cv: candidate?.cvs?.length > 0,
    skills: candidate?.skills?.length > 0,
    experiences: candidate?.experiences?.length > 0,
    education: candidate?.education?.length > 0,
  };

  const completed = Object.values(checks).filter(Boolean).length;
  const total = Object.keys(checks).length;

  const minimumRequiredForApplication = {
    telephone: !!candidate?.telephone,
    residence: !!candidate?.residence?.wilaya,
    cv: candidate?.cvs?.length > 0,
    skills: candidate?.skills?.length > 0,
  };

  const canApply = Object.values(minimumRequiredForApplication).every(Boolean);
  const missingForApplication = Object.entries(minimumRequiredForApplication)
    .filter(([_, v]) => !v)
    .map(([k]) => {
      const labels = {
        telephone: "NumÃ©ro de tÃ©lÃ©phone",
        residence: "Localisation (wilaya)",
        cv: "CV",
        skills: "Au moins une compÃ©tence",
      };
      return labels[k] || k;
    });

  return {
    percentage: Math.round((completed / total) * 100),
    missing: Object.entries(checks)
      .filter(([_, v]) => !v)
      .map(([k]) => k),
    isComplete: completed === total,
    canApply,
    missingForApplication,
  };
};


=== utils\statusMapping.js ===
export const RECRUITER_TO_CANDIDATE_STATUS = {
  nouvelle: "envoyee",
  consultee: "en_cours",
  preselection: "en_cours",
  en_discussion: "en_cours",
  entretien_planifie: "en_cours",
  entretien_termine: "en_cours",
  retenue: "retenue",
  refusee: "non_retenue",
};

export const mapRecruiterToCandidate = (recruiterStatus) => {
  return RECRUITER_TO_CANDIDATE_STATUS[recruiterStatus] || "en_cours";
};


export const NOTIFY_CANDIDATE_STATUSES = ["retenue", "refusee"];


export const TERMINAL_STATUSES = {
  candidate: ["retenue", "non_retenue", "retiree"],
  recruiter: ["retenue", "refusee"],
};
