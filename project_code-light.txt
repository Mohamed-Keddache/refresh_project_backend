

=== server.js ===
import dotenv from "dotenv";
dotenv.config();
import express from "express";
import cors from "cors";
import morgan from "morgan";
import connectDB from "./config/db.js";
import setupFolders from "./startup/setupFolders.js";
import { seedAdmin } from "./startup/seedAdmin.js";
import { setupSecurity } from "./middleware/security.js";
import SystemSettings from "./models/SystemSettings.js";
import { verifySmtpConnection } from "./services/emailService.js";

import authRoutes from "./routes/authRoutes.js";
import candidateRoutes from "./routes/candidateRoutes.js";
import offerRoutes from "./routes/offerRoutes.js";
import notificationRoutes from "./routes/notificationRoutes.js";
import skillRoutes from "./routes/skillRoutes.js";
import supportRoutes from "./routes/supportRoutes.js";
import announcementRoutes from "./routes/announcementRoutes.js";

import recruiterRoutes from "./routes/recruiterRoutes.js";
import adminRoutes from "./routes/adminRoutes.js";
import anemRoutes from "./routes/anemRoutes.js";

const app = express();

try {
  setupSecurity(app);
} catch (err) {
  console.warn("âš ï¸ setupSecurity not found or failed, skipping...");
}

app.use(
  cors({
    origin: "*",
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
    allowedHeaders: [
      "Content-Type",
      "Authorization",
      "ngrok-skip-browser-warning",
    ],
  }),
);

app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

if (process.env.NODE_ENV !== "test") {
  app.use(morgan(process.env.NODE_ENV === "production" ? "combined" : "dev"));
}

app.use("/uploads", express.static("uploads"));

app.use((err, req, res, next) => {
  if (err instanceof SyntaxError && err.status === 400 && "body" in err) {
    return res.status(400).json({ msg: "JSON invalide" });
  }
  next(err);
});

async function startServer() {
  try {
    
    console.log("ðŸ”§ Environment check:");
    console.log("   NODE_ENV:", process.env.NODE_ENV || "development");
    console.log("   SMTP_HOST:", process.env.SMTP_HOST || "NOT SET");
    console.log("   SMTP_PORT:", process.env.SMTP_PORT || "NOT SET");
    console.log("   SMTP_USER:", process.env.SMTP_USER || "NOT SET");
    console.log("   SMTP_PASS:", process.env.SMTP_PASS ? "SET" : "NOT SET");

    await connectDB();
    setupFolders();

    await seedAdmin();

    await SystemSettings.initializeDefaults();
    console.log("âš™ï¸ ParamÃ¨tres systÃ¨me initialisÃ©s");

    
    const emailMode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );
    console.log(`ðŸ“§ Email verification mode: ${emailMode}`);

    if (emailMode === "smtp") {
      console.log("ðŸ“§ Verifying SMTP connection...");
      const smtpOk = await verifySmtpConnection();
      if (smtpOk) {
        console.log("âœ… SMTP ready for sending emails");
      } else {
        console.warn("âš ï¸ SMTP connection failed - emails may not be sent");
        console.warn("   Falling back to development mode for safety");
        
        
      }
    } else {
      console.log("ðŸ“§ Development mode: Use code 123456 for verification");
    }

    
    app.use("/api/auth", authRoutes);
    app.use("/api/skills", skillRoutes);
    app.use("/api/offers", offerRoutes);
    app.use("/api/candidates", candidateRoutes);
    app.use("/api/notifications", notificationRoutes);
    app.use("/api/support", supportRoutes);
    app.use("/api/announcements", announcementRoutes);

    app.use("/api/recruiters", recruiterRoutes);
    app.use("/api/admin", adminRoutes);
    app.use("/api/anem", anemRoutes);

    
    app.get("/", (req, res) =>
      res.json({
        status: "ok",
        message: "âœ… API Recrutement opÃ©rationnelle !",
        timestamp: new Date().toISOString(),
      }),
    );

    app.get("/health", (req, res) =>
      res.json({
        status: "healthy",
        uptime: process.uptime(),
        timestamp: new Date().toISOString(),
      }),
    );

    
    if (process.env.NODE_ENV !== "production") {
      app.get("/debug/smtp", async (req, res) => {
        try {
          const smtpOk = await verifySmtpConnection();
          const emailMode = await SystemSettings.getSetting(
            "email_verification_mode",
            "development",
          );
          res.json({
            smtpConnection: smtpOk,
            emailMode,
            config: {
              host: process.env.SMTP_HOST,
              port: process.env.SMTP_PORT,
              user: process.env.SMTP_USER,
              passSet: !!process.env.SMTP_PASS,
            },
          });
        } catch (err) {
          res.status(500).json({ error: err.message });
        }
      });
    }

    
    app.use((req, res) => {
      res.status(404).json({ msg: "Route non trouvÃ©e" });
    });

    
    app.use((err, req, res, next) => {
      console.error("âŒ Erreur serveur:", err);

      const message =
        process.env.NODE_ENV === "production"
          ? "Erreur interne du serveur"
          : err.message;

      res.status(err.status || 500).json({
        msg: message,
        ...(process.env.NODE_ENV !== "production" && { stack: err.stack }),
      });
    });

    const PORT = process.env.PORT || 5000;
    app.listen(PORT, () => {
      console.log(`ðŸš€ Serveur lancÃ© sur le port ${PORT}`);
      console.log(`ðŸ“Š Environnement: ${process.env.NODE_ENV || "development"}`);
    });
  } catch (error) {
    console.error("âŒ Erreur lors du dÃ©marrage du serveur :", error);
    process.exit(1);
  }
}

startServer();

process.on("uncaughtException", (err) => {
  console.error("âŒ Uncaught Exception:", err);
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
  console.error("âŒ Unhandled Rejection at:", promise, "reason:", reason);
});

export default app;


=== config\db.js ===
import mongoose from "mongoose";

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("ðŸŸ¢ ConnectÃ© Ã  MongoDB");
  } catch (err) {
    console.error("âŒ Erreur MongoDB :", err.message);
    process.exit(1);
  }
};

export default connectDB;


=== controllers\adminController.js ===
import User from "../models/User.js";
import Recruiter from "../models/Recruiter.js";
import Candidate from "../models/Candidate.js";
import Offer from "../models/Offer.js";
import Admin from "../models/Admin.js";
import Notification from "../models/Notification.js";
import Application from "../models/Application.js";
import Company from "../models/Company.js";
import bcrypt from "bcryptjs";
import SupportTicket from "../models/SupportTicket.js";
import AdminLog, { logAdminAction } from "../models/AdminLog.js";
import AnemRegistration from "../models/AnemRegistration.js";

export const getRecruiters = async (req, res) => {
  try {
    const { status, page = 1, limit = 20, search } = req.query;

    let query = {};

    if (status === "pending") {
      query.status = { $in: ["pending_validation", "pending_revalidation"] };
    } else if (status === "requests_sent") {
      query.status = {
        $in: [
          "pending_info",
          "pending_documents",
          "pending_info_and_documents",
        ],
      };
    } else if (status === "decision_made") {
      query.status = { $in: ["validated", "rejected"] };
    } else if (status) {
      query.status = status;
    }

    if (search) {
      const users = await User.find({
        $or: [
          { nom: { $regex: search, $options: "i" } },
          { email: { $regex: search, $options: "i" } },
        ],
      }).select("_id");

      const userIds = users.map((u) => u._id);

      const companies = await Company.find({
        name: { $regex: search, $options: "i" },
      }).select("_id");
      const companyIds = companies.map((c) => c._id);

      query.$or = [
        { userId: { $in: userIds } },
        { companyId: { $in: companyIds } },
      ];
    }

    const skip = (page - 1) * limit;

    const recruiters = await Recruiter.find(query)
      .populate({
        path: "userId",
        select: "nom email createdAt",
      })
      .populate("companyId", "name status logo")
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Recruiter.countDocuments(query);

    const enriched = recruiters
      .filter((r) => r.userId !== null)
      .map((r) => ({
        _id: r._id,
        userId: r.userId._id,
        nom: r.userId.nom,
        email: r.userId.email,
        createdAt: r.userId.createdAt,

        entrepriseId: r.companyId?._id,
        entreprise: r.companyId?.name || "Inconnue",
        entrepriseStatus: r.companyId?.status,
        entrepriseLogo: r.companyId?.logo,
        entrepriseDetails: r.companyId,

        position: r.position,
        telephone: r.telephone || "Non renseignÃ©",
        recruiterStatus: r.status,
        isAdmin: r.isAdmin,
        rejectionReason: r.rejectionReason,

        anem: {
          status: r.anem?.status || "not_started",
          anemId: r.anem?.anemId,
          isRegistered: r.anem?.status === "registered",
        },

        validationRequests: r.validationRequests,

        lastRequestDate:
          r.validationRequests.length > 0
            ? r.validationRequests[r.validationRequests.length - 1].createdAt
            : null,
      }));

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const cancelValidationRequest = async (req, res) => {
  try {
    const { id } = req.params;

    const recruiter = await Recruiter.findById(id);
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    recruiter.status = "pending_validation";

    recruiter.validationRequests = recruiter.validationRequests.filter(
      (req) => req.status !== "pending",
    );

    await recruiter.save();

    await logAdminAction(
      req.user.id,
      "recruiter_request_canceled",
      { type: "recruiter", id: recruiter._id },
      {},
      req,
    );

    res.json({ msg: "Demande annulÃ©e, recruteur replacÃ© en attente âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanyDetailsAdmin = async (req, res) => {
  try {
    const { companyId } = req.params;
    const company = await Company.findById(companyId);

    if (!company)
      return res.status(404).json({ msg: "Entreprise introuvable" });

    const recruiterCount = await Recruiter.countDocuments({ companyId });
    const offerCount = await Offer.countDocuments({ companyId });

    res.json({
      ...company.toObject(),
      stats: {
        recruiters: recruiterCount,
        offers: offerCount,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const validateRecruiter = async (req, res) => {
  try {
    const { id } = req.params;

    let recruiter = await Recruiter.findById(id).populate("companyId");
    if (!recruiter) {
      recruiter = await Recruiter.findOne({ userId: id }).populate("companyId");
    }

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    const user = await User.findById(recruiter.userId);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable" });
    }

    recruiter.status = "validated";

    const existingAdmins = await Recruiter.countDocuments({
      companyId: recruiter.companyId._id,
      status: "validated",
      isAdmin: true,
    });

    if (existingAdmins === 0 && recruiter.companyId.status === "active") {
      recruiter.isAdmin = true;
      recruiter.permissions.editCompany = true;
      recruiter.permissions.manageTeam = true;

      await Notification.create({
        userId: user._id,
        message: `FÃ©licitations ! Vous Ãªtes le premier recruteur validÃ© de "${recruiter.companyId.name}" et devenez automatiquement administrateur de l'entreprise.`,
        type: "validation",
      });
    }

    await recruiter.save();

    await Notification.create({
      userId: user._id,
      message:
        "FÃ©licitations ! Votre compte recruteur a Ã©tÃ© validÃ©. Vous pouvez maintenant publier des offres.",
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_validated",
      { type: "recruiter", id: recruiter._id },
      { isFirstAdmin: recruiter.isAdmin },
      req,
    );

    res.json({
      msg: "Recruteur validÃ© avec succÃ¨s âœ…",
      isCompanyAdmin: recruiter.isAdmin,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectRecruiter = async (req, res) => {
  try {
    const { id } = req.params;
    const { message } = req.body;

    let recruiter = await Recruiter.findById(id);
    if (!recruiter) {
      recruiter = await Recruiter.findOne({ userId: id });
    }

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    recruiter.status = "rejected";
    recruiter.rejectionReason = message || "Non spÃ©cifiÃ©e";
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId,
      message: `Votre compte recruteur a Ã©tÃ© rejetÃ©. Raison : ${
        message || "Non spÃ©cifiÃ©e"
      }`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_rejected",
      { type: "recruiter", id: recruiter._id },
      { reason: message },
      req,
    );

    res.json({ msg: "Recruteur rejetÃ© âŒ" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllAdmins = async (req, res) => {
  try {
    const admins = await Admin.find()
      .populate("userId", "nom email createdAt")
      .populate("createdBy", "nom")
      .sort({ createdAt: -1 });

    res.json(admins);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const suspendAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason, until } = req.body;

    if (id === req.user.id) {
      return res
        .status(400)
        .json({ msg: "Vous ne pouvez pas vous suspendre vous-mÃªme." });
    }

    const targetAdmin = await Admin.findOne({ userId: id });
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin introuvable" });
    }

    if (targetAdmin.label === "super_admin") {
      return res
        .status(403)
        .json({ msg: "Impossible de suspendre un super admin" });
    }

    targetAdmin.status = "suspended";
    targetAdmin.suspensionReason = reason;
    targetAdmin.suspendedUntil = until ? new Date(until) : null;
    await targetAdmin.save();

    await logAdminAction(
      req.user.id,
      "admin_suspended",
      { type: "admin", id: targetAdmin._id },
      { reason, until },
      req,
    );

    res.json({ msg: "Administrateur suspendu â›”" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getPendingCompanies = async (req, res) => {
  try {
    const companies = await Company.find({ status: "pending" }).sort({
      createdAt: -1,
    });
    res.json(companies);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const validateCompany = async (req, res) => {
  try {
    const { id } = req.params;
    const company = await Company.findByIdAndUpdate(
      id,
      { status: "active" },
      { new: true },
    );

    if (!company)
      return res.status(404).json({ msg: "Entreprise introuvable" });

    res.json({ msg: "Entreprise validÃ©e avec succÃ¨s âœ…", company });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectCompany = async (req, res) => {
  try {
    const { id } = req.params;
    const company = await Company.findByIdAndUpdate(
      id,
      { status: "rejected" },
      { new: true },
    );

    if (!company)
      return res.status(404).json({ msg: "Entreprise introuvable" });

    res.json({ msg: "Entreprise rejetÃ©e âŒ", company });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const createAdmin = async (req, res) => {
  try {
    const { nom, email, motDePasse, forceVerify } = req.body;

    const exist = await User.findOne({ email });
    if (exist) return res.status(400).json({ msg: "Email dÃ©jÃ  utilisÃ©" });

    const hash = await bcrypt.hash(motDePasse, 10);

    const emailVerified = forceVerify !== undefined ? forceVerify : true;

    const user = await User.create({
      nom,
      email,
      motDePasse: hash,
      role: "admin",
      statutValidation: "validÃ©",
      emailVerified: emailVerified,
    });

    await Admin.create({ userId: user._id });

    res.status(201).json({ msg: "Nouvel administrateur crÃ©Ã© âœ…", admin: user });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteAdmin = async (req, res) => {
  try {
    const { id } = req.params;

    if (id === req.user.id)
      return res
        .status(400)
        .json({ msg: "Vous ne pouvez pas vous supprimer vous-mÃªme." });

    const adminUser = await User.findById(id);
    if (!adminUser || adminUser.role !== "admin")
      return res.status(404).json({ msg: "Admin introuvable" });

    await User.findByIdAndDelete(id);
    await Admin.findOneAndDelete({ userId: id });

    res.json({ msg: "Administrateur supprimÃ© ðŸ—‘ï¸" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const banUser = async (req, res) => {
  try {
    const { id } = req.params;
    const { raison } = req.body;

    const user = await User.findById(id);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });
    if (user.role === "admin")
      return res.status(403).json({ msg: "Impossible de bannir un admin." });

    user.accountStatus = "banned";
    user.suspensionReason = raison || "Non respect des conditions.";
    await user.save();

    await Notification.create({
      userId: user._id,
      message: `Votre compte a Ã©tÃ© dÃ©sactivÃ©. Raison : ${
        raison || "Non respect des conditions."
      }`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "user_banned",
      { type: "user", id: user._id },
      { reason: raison },
      req,
    );

    res.json({ msg: `Utilisateur ${user.nom} a Ã©tÃ© banni â›”` });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const unBanUser = async (req, res) => {
  try {
    const { id } = req.params;

    const user = await User.findById(id);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });

    if (user.role === "admin") {
      return res.status(400).json({ msg: "Action inutile sur un admin." });
    }

    if (user.accountStatus === "active") {
      return res.status(400).json({ msg: "Cet utilisateur n'est pas banni." });
    }

    user.accountStatus = "active";
    user.suspensionReason = undefined;
    user.suspendedUntil = undefined;
    await user.save();

    await Notification.create({
      userId: user._id,
      message:
        "Bonne nouvelle ! Votre compte a Ã©tÃ© rÃ©activÃ© par l'administration. Vous pouvez Ã  nouveau vous connecter.",
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "user_unbanned",
      { type: "user", id: user._id },
      {},
      req,
    );

    res.json({ msg: `L'utilisateur ${user.nom} a Ã©tÃ© dÃ©banni et rÃ©activÃ© âœ…` });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllUsers = async (req, res) => {
  try {
    const {
      role,
      status,
      search,
      wilaya,
      proposable,
      emailVerified,
      page = 1,
      limit = 20,
    } = req.query;

    let query = {};
    if (role) query.role = role;
    if (status) query.accountStatus = status;
    if (emailVerified) query.emailVerified = emailVerified === "true";

    if (search) {
      query.$or = [
        { nom: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } },
      ];
    }

    const skip = (page - 1) * limit;

    const [users, total] = await Promise.all([
      User.find(query)
        .select("-motDePasse")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean(),
      User.countDocuments(query),
    ]);

    const userIds = users.map((u) => u._id);

    const [candidates, recruiters] = await Promise.all([
      Candidate.find({ userId: { $in: userIds } })
        .select(
          "userId telephone residence autoriserProposition desiredPosition",
        )
        .lean(),
      Recruiter.find({ userId: { $in: userIds } })
        .populate("companyId", "name")
        .select("userId status companyId")
        .lean(),
    ]);

    const candidateMap = new Map(
      candidates.map((c) => [c.userId.toString(), c]),
    );
    const recruiterMap = new Map(
      recruiters.map((r) => [r.userId.toString(), r]),
    );

    const recruiterIds = recruiters.map((r) => r._id);
    const offerCounts = await Offer.aggregate([
      { $match: { recruteurId: { $in: recruiterIds } } },
      { $group: { _id: "$recruteurId", count: { $sum: 1 } } },
    ]);

    const offerCountMap = new Map(
      offerCounts.map((o) => [o._id.toString(), o.count]),
    );

    let enriched = users.map((u) => {
      const userId = u._id.toString();
      let details = {};

      if (u.role === "candidat") {
        const cand = candidateMap.get(userId);
        if (cand) {
          details = {
            telephone: cand.telephone,
            wilaya: cand.residence?.wilaya || null,
            autoriserProposition: cand.autoriserProposition,
            poste: cand.desiredPosition,
          };
        }
      }

      if (u.role === "recruteur") {
        const rec = recruiterMap.get(userId);
        if (rec) {
          details = {
            entreprise: rec.companyId?.name || "Inconnue",
            recruiterStatus: rec.status,
            offres: offerCountMap.get(rec._id.toString()) || 0,
          };
        }
      }

      return {
        ...u,
        accountStatus: u.accountStatus,
        details,
      };
    });

    if (wilaya) {
      enriched = enriched.filter(
        (u) =>
          u.details?.wilaya &&
          u.details.wilaya.toLowerCase() === wilaya.toLowerCase(),
      );
    }

    if (proposable === "true") {
      enriched = enriched.filter(
        (u) => u.details?.autoriserProposition === true,
      );
    }

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const sendMessageToUser = async (req, res) => {
  try {
    const { id } = req.params;
    const { message } = req.body;

    await Notification.create({
      userId: id,
      message: `Message de l'administration : ${message}`,
      type: "info",
    });

    res.json({ msg: "Notification envoyÃ©e âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteOfferAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const { motif } = req.body;

    const offer = await Offer.findById(id).populate("recruteurId");
    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    if (offer.recruteurId && offer.recruteurId.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Votre offre "${offer.titre}" a Ã©tÃ© supprimÃ©e. Motif : ${
          motif || "Non conforme"
        }`,
        type: "alerte",
      });
    }

    await Offer.findByIdAndDelete(id);

    res.json({ msg: "Offre supprimÃ©e et recruteur notifiÃ© ðŸ—‘ï¸" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getGlobalStats = async (req, res) => {
  try {
    const now = new Date();
    const fifteenMinutesAgo = new Date(now - 15 * 60 * 1000);
    const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);

    const [
      onlineUsers,
      totalUsers,
      newUsersThisMonth,
      usersByRole,
      totalOffres,
      offresActives,
      pendingOffers,
      newOffersThisMonth,
      applicationStats,
      pendingRecruiters,
      pendingCompanies,
      openTickets,
      pendingAnem,
      recentAdminActions,
    ] = await Promise.all([
      User.countDocuments({ derniereConnexion: { $gt: fifteenMinutesAgo } }),
      User.countDocuments(),
      User.countDocuments({ createdAt: { $gte: thirtyDaysAgo } }),
      User.aggregate([{ $group: { _id: "$role", count: { $sum: 1 } } }]),
      Offer.countDocuments(),
      Offer.countDocuments({ actif: true, validationStatus: "approved" }),
      Offer.countDocuments({ validationStatus: "pending" }),
      Offer.countDocuments({ createdAt: { $gte: thirtyDaysAgo } }),
      Application.aggregate([
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),

      Recruiter.countDocuments({
        status: { $in: ["pending_validation", "pending_revalidation"] },
      }),
      Company.countDocuments({ status: "pending" }),
      SupportTicket.countDocuments({
        status: { $in: ["open", "in_progress"] },
      }),
      AnemRegistration.countDocuments({
        status: { $in: ["pending", "pending_verification"] },
      }),
      AdminLog.find()
        .populate("adminId", "nom")
        .sort({ createdAt: -1 })
        .limit(10),
    ]);

    const roleMap = {};
    usersByRole.forEach((r) => {
      roleMap[r._id] = r.count;
    });

    const statsCandidatures = {};
    applicationStats.forEach((s) => {
      statsCandidatures[s._id] = s.count;
    });

    const pendingTasks = {
      recruiters: pendingRecruiters,
      companies: 0,
      offers: pendingOffers,
      tickets: openTickets,
      total: pendingRecruiters + pendingOffers + openTickets,
    };

    res.json({
      users: {
        online: onlineUsers,
        total: totalUsers,
        newThisMonth: newUsersThisMonth,
        byRole: roleMap,
      },
      offres: {
        total: totalOffres,
        actives: offresActives,
        pending: pendingOffers,
        newThisMonth: newOffersThisMonth,
      },
      candidatures: statsCandidatures,
      pendingTasks,
      recentAdminActions,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getTrends = async (req, res) => {
  try {
    const { period = "30" } = req.query;
    const days = parseInt(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const [rawUsers, rawOffers, rawApplications] = await Promise.all([
      User.aggregate([
        { $match: { createdAt: { $gte: startDate } } },
        {
          $group: {
            _id: {
              date: {
                $dateToString: { format: "%Y-%m-%d", date: "$createdAt" },
              },
            },
            count: { $sum: 1 },
          },
        },
      ]),

      Offer.aggregate([
        { $match: { createdAt: { $gte: startDate } } },
        {
          $group: {
            _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
            count: { $sum: 1 },
          },
        },
      ]),

      Application.aggregate([
        { $match: { datePostulation: { $gte: startDate } } },
        {
          $group: {
            _id: {
              $dateToString: { format: "%Y-%m-%d", date: "$datePostulation" },
            },
            count: { $sum: 1 },
          },
        },
      ]),
    ]);

    const statsMap = new Map();
    for (let i = 0; i < days; i++) {
      const d = new Date();
      d.setDate(d.getDate() - i);
      const dateStr = d.toISOString().split("T")[0];

      statsMap.set(dateStr, {
        date: dateStr,
        users: 0,
        offers: 0,
        applications: 0,
      });
    }

    rawUsers.forEach((u) => {
      const date = u._id.date;
      if (statsMap.has(date)) {
        statsMap.get(date).users += u.count;
      }
    });

    rawOffers.forEach((o) => {
      const date = o._id;
      if (statsMap.has(date)) {
        statsMap.get(date).offers += o.count;
      }
    });

    rawApplications.forEach((a) => {
      const date = a._id;
      if (statsMap.has(date)) {
        statsMap.get(date).applications += a.count;
      }
    });

    const chartData = Array.from(statsMap.values()).sort(
      (a, b) => new Date(a.date) - new Date(b.date),
    );

    res.json({
      data: chartData,
      period: days,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getManualSelectionOffers = async (req, res) => {
  try {
    const {
      minProposals,
      maxProposals,
      startDate,
      endDate,
      sortBy = "datePublication",
    } = req.query;

    const pipeline = [
      {
        $match: {
          actif: true,
          candidateSearchMode: "manual",
          validationStatus: "approved",
        },
      },
    ];

    if (startDate || endDate) {
      const dateFilter = {};
      if (startDate) dateFilter.$gte = new Date(startDate);
      if (endDate) dateFilter.$lte = new Date(endDate);
      pipeline[0].$match.datePublication = dateFilter;
    }

    pipeline.push({
      $lookup: {
        from: "applications",
        let: { offerId: "$_id" },
        pipeline: [
          {
            $match: {
              $expr: {
                $and: [
                  { $eq: ["$offerId", "$$offerId"] },
                  { $eq: ["$recommandeParAdmin", true] },
                ],
              },
            },
          },
          { $count: "count" },
        ],
        as: "adminProposals",
      },
    });

    pipeline.push({
      $addFields: {
        proposalCount: {
          $ifNull: [{ $arrayElemAt: ["$adminProposals.count", 0] }, 0],
        },
      },
    });

    if (minProposals !== undefined || maxProposals !== undefined) {
      const countMatch = {};
      if (minProposals !== undefined) countMatch.$gte = parseInt(minProposals);
      if (maxProposals !== undefined) countMatch.$lte = parseInt(maxProposals);
      pipeline.push({ $match: { proposalCount: countMatch } });
    }

    pipeline.push(
      {
        $lookup: {
          from: "recruiters",
          localField: "recruteurId",
          foreignField: "_id",
          as: "recruteur",
        },
      },
      { $unwind: "$recruteur" },
      {
        $lookup: {
          from: "companies",
          localField: "companyId",
          foreignField: "_id",
          as: "company",
        },
      },
      { $unwind: "$company" },
    );

    let sortStage = {};
    if (sortBy === "lastModified") {
      sortStage = { updatedAt: -1 };
    } else {
      sortStage = { datePublication: -1 };
    }
    pipeline.push({ $sort: sortStage });

    const offers = await Offer.aggregate(pipeline);

    res.json(offers);
  } catch (err) {
    console.error("Erreur Manual Matching:", err);
    res.status(500).json({ msg: err.message });
  }
};

export const proposeCandidateToOffer = async (req, res) => {
  try {
    const { candidatId, offreId } = req.body;

    const offer = await Offer.findById(offreId).populate("recruteurId");
    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    let candidate = await Candidate.findById(candidatId).populate("userId");

    if (!candidate) {
      candidate = await Candidate.findOne({ userId: candidatId }).populate(
        "userId",
      );
    }

    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    if (!candidate.userId?.emailVerified) {
      return res.status(400).json({ msg: "Email candidat non vÃ©rifiÃ©." });
    }

    if (!candidate.autoriserProposition) {
      return res
        .status(403)
        .json({ msg: "Ce candidat refuse les propositions." });
    }

    if (!candidate.cvs || candidate.cvs.length === 0) {
      return res.status(400).json({
        msg: "Impossible de proposer ce candidat : il n'a pas de CV.",
      });
    }

    const existingApp = await Application.findOne({
      offerId: offreId,
      candidateId: candidate._id,
    });

    if (existingApp) {
      return res.status(400).json({ msg: "Candidat dÃ©jÃ  positionnÃ©." });
    }
    const lastCv = candidate.cvs[candidate.cvs.length - 1].url;

    await Application.create({
      offerId: offreId,
      candidateId: candidate._id,
      cvUrl: lastCv,

      candidateStatus: "envoyee",
      recruiterStatus: "nouvelle",

      source: "admin_proposal",
      proposedBy: req.user.id,
      proposedAt: new Date(),

      coverLetter:
        "Recommandation Admin : Ce profil correspond parfaitement aux critÃ¨res de lâ€™offre.",

      offerSnapshot: {
        titre: offer.titre,
        companyId: offer.companyId,
        type: offer.type,
      },
    });

    offer.nombreCandidatures += 1;
    await offer.save();

    if (offer.recruteurId?.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Un administrateur vous a proposÃ© un candidat recommandÃ© (${candidate.userId.nom}) pour votre offre "${offer.titre}".`,
        type: "validation",
      });
    }

    await Notification.create({
      userId: candidate.userId._id,
      message: `Bonne nouvelle ! Votre profil a Ã©tÃ© recommandÃ© par un administrateur pour l'offre "${offer.titre}".`,
      type: "info",
    });

    return res.json({ msg: "Candidat proposÃ© avec succÃ¨s âœ…" });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ msg: err.message });
  }
};

export const getAdminLogs = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      adminId,
      action,
      startDate,
      endDate,
    } = req.query;

    let query = {};
    if (adminId) query.adminId = adminId;
    if (action) query.action = action;
    if (startDate || endDate) {
      query.createdAt = {};
      if (startDate) query.createdAt.$gte = new Date(startDate);
      if (endDate) query.createdAt.$lte = new Date(endDate);
    }

    const logs = await AdminLog.find(query)
      .populate("adminId", "nom email")
      .sort({ createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await AdminLog.countDocuments(query);

    res.json({
      data: logs,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getPendingOffers = async (req, res) => {
  try {
    const { page = 1, limit = 20, sortBy = "createdAt" } = req.query;

    const offers = await Offer.find({ validationStatus: "pending" })
      .populate("companyId", "name logo")
      .populate({
        path: "recruteurId",
        select: "userId position",
        populate: { path: "userId", select: "nom email" },
      })
      .sort({ [sortBy]: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await Offer.countDocuments({ validationStatus: "pending" });

    res.json({
      data: offers,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const approveOffer = async (req, res) => {
  try {
    const { id } = req.params;

    const offer = await Offer.findById(id).populate("recruteurId");
    if (!offer) return res.status(404).json({ msg: "Offre introuvable." });

    offer.validationStatus = "approved";
    offer.actif = true;
    offer.datePublication = new Date();
    offer.validationHistory.push({
      status: "approved",
      adminId: req.user.id,
    });
    await offer.save();

    if (offer.recruteurId && offer.recruteurId.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Votre offre "${offer.titre}" a Ã©tÃ© approuvÃ©e et est maintenant visible.`,
        type: "validation",
      });
    }

    await logAdminAction(
      req.user.id,
      "offer_approved",
      { type: "offer", id: offer._id },
      {},
      req,
    );

    res.json({ msg: "Offre approuvÃ©e âœ…", offer });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectOffer = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason, requestChanges } = req.body;

    const offer = await Offer.findById(id).populate("recruteurId");
    if (!offer) return res.status(404).json({ msg: "Offre introuvable." });

    offer.validationStatus = requestChanges ? "changes_requested" : "rejected";
    offer.rejectionReason = reason;
    offer.validationHistory.push({
      status: offer.validationStatus,
      message: reason,
      adminId: req.user.id,
    });
    await offer.save();

    const msgType = requestChanges
      ? `Des modifications sont demandÃ©es pour votre offre "${offer.titre}": ${reason}`
      : `Votre offre "${offer.titre}" a Ã©tÃ© refusÃ©e: ${reason}`;

    if (offer.recruteurId && offer.recruteurId.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: msgType,
        type: "alerte",
      });
    }

    await logAdminAction(
      req.user.id,
      requestChanges ? "offer_changes_requested" : "offer_rejected",
      { type: "offer", id: offer._id },
      { reason },
      req,
    );

    res.json({
      msg: requestChanges ? "Modifications demandÃ©es." : "Offre refusÃ©e.",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const requestRecruiterDocuments = async (req, res) => {
  try {
    const { recruiterId } = req.params;
    const { type, message, requiredDocuments, requiredFields } = req.body;

    const recruiter = await Recruiter.findById(recruiterId).populate("userId");
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    recruiter.status =
      type === "document" ? "pending_documents" : "pending_info";
    recruiter.validationRequests.push({
      type,
      message,
      requiredDocuments,
      requiredFields,
      status: "pending",
    });
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Action requise : ${message}`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_documents_requested",
      { type: "recruiter", id: recruiter._id },
      { requestType: type, message },
      req,
    );

    res.json({ msg: "Demande envoyÃ©e au recruteur âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAdminPermissions = async (req, res) => {
  try {
    const { id } = req.params;
    const { permissions } = req.body;

    const targetAdmin = await Admin.findOne({ userId: id });
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin introuvable" });
    }

    if (targetAdmin.label === "super_admin") {
      return res.status(403).json({
        msg: "Impossible de modifier les permissions d'un super admin",
      });
    }

    targetAdmin.permissions = { ...targetAdmin.permissions, ...permissions };
    await targetAdmin.save();

    await logAdminAction(
      req.user.id,
      "admin_permissions_updated",
      { type: "admin", id: targetAdmin._id },
      { newPermissions: permissions },
      req,
    );

    res.json({ msg: "Permissions mises Ã  jour âœ…", admin: targetAdmin });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAdminLabel = async (req, res) => {
  try {
    const { id } = req.params;
    const { label } = req.body;

    const validLabels = [
      "super_admin",
      "support",
      "technical",
      "operational",
      "recruitment",
      "moderation",
      "product",
    ];

    if (!validLabels.includes(label)) {
      return res.status(400).json({ msg: "Label invalide" });
    }

    const targetAdmin = await Admin.findOne({ userId: id });
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin introuvable" });
    }

    const oldLabel = targetAdmin.label;
    targetAdmin.label = label;
    await targetAdmin.save();

    await logAdminAction(
      req.user.id,
      "admin_label_changed",
      { type: "admin", id: targetAdmin._id },
      { oldLabel, newLabel: label },
      req,
    );

    res.json({ msg: "Label mis Ã  jour âœ…", admin: targetAdmin });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const createCompanyByAdmin = async (req, res) => {
  try {
    const { name, website, description, industry, location, size, logo } =
      req.body;

    if (!name) {
      return res
        .status(400)
        .json({ msg: "Le nom de l'entreprise est obligatoire." });
    }

    const existingCompany = await Company.findOne({
      name: { $regex: new RegExp(`^${name}$`, "i") },
    });

    if (existingCompany) {
      return res
        .status(400)
        .json({ msg: "Une entreprise avec ce nom existe dÃ©jÃ ." });
    }

    const company = await Company.create({
      name,
      website,
      description,
      industry,
      location,
      size,
      logo,
      status: "active",
    });

    await logAdminAction(
      req.user.id,
      "company_created_by_admin",
      { type: "company", id: company._id },
      { name },
      req,
    );

    res.status(201).json({
      msg: "Entreprise crÃ©Ã©e avec succÃ¨s âœ…",
      company,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanyRecruiters = async (req, res) => {
  try {
    const { companyId } = req.params;

    const company = await Company.findById(companyId);
    if (!company) {
      return res.status(404).json({ msg: "Entreprise introuvable." });
    }

    const recruiters = await Recruiter.find({ companyId })
      .populate("userId", "nom email createdAt")
      .sort({ isAdmin: -1, createdAt: 1 });

    res.json({
      company: {
        _id: company._id,
        name: company.name,
        status: company.status,
      },
      recruiters,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const assignCompanyAdmin = async (req, res) => {
  try {
    const { companyId, recruiterId } = req.body;

    const company = await Company.findById(companyId);
    if (!company) {
      return res.status(404).json({ msg: "Entreprise introuvable." });
    }

    const recruiter = await Recruiter.findById(recruiterId).populate("userId");
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    if (recruiter.companyId.toString() !== companyId) {
      return res.status(400).json({
        msg: "Ce recruteur n'appartient pas Ã  cette entreprise.",
      });
    }

    if (recruiter.status !== "validated") {
      return res.status(400).json({
        msg: "Le recruteur doit Ãªtre validÃ© avant de devenir administrateur.",
      });
    }

    recruiter.isAdmin = true;
    recruiter.permissions.editCompany = true;
    recruiter.permissions.manageTeam = true;
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Vous Ãªtes maintenant administrateur de l'entreprise "${company.name}".`,
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "company_admin_assigned",
      { type: "recruiter", id: recruiter._id },
      { companyId, companyName: company.name },
      req,
    );

    res.json({
      msg: `${recruiter.userId.nom} est maintenant administrateur de ${company.name} âœ…`,
      recruiter,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const removeCompanyAdmin = async (req, res) => {
  try {
    const { recruiterId } = req.params;

    const recruiter = await Recruiter.findById(recruiterId)
      .populate("userId")
      .populate("companyId");

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    if (!recruiter.isAdmin) {
      return res.status(400).json({
        msg: "Ce recruteur n'est pas administrateur d'entreprise.",
      });
    }

    recruiter.isAdmin = false;
    recruiter.permissions.editCompany = false;
    recruiter.permissions.manageTeam = false;
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Vous n'Ãªtes plus administrateur de l'entreprise "${recruiter.companyId.name}".`,
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "company_admin_removed",
      { type: "recruiter", id: recruiter._id },
      {
        companyId: recruiter.companyId._id,
        companyName: recruiter.companyId.name,
      },
      req,
    );

    res.json({
      msg: `${recruiter.userId.nom} n'est plus administrateur âš ï¸`,
      recruiter,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateCompanyByAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, website, description, industry, location, size, logo } =
      req.body;

    const company = await Company.findByIdAndUpdate(
      id,
      { name, website, description, industry, location, size, logo },
      { new: true },
    );

    if (!company) {
      return res.status(404).json({ msg: "Entreprise introuvable." });
    }

    await logAdminAction(
      req.user.id,
      "company_updated_by_admin",
      { type: "company", id: company._id },
      { updates: req.body },
      req,
    );

    res.json({ msg: "Entreprise mise Ã  jour âœ…", company });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const requestMultipleValidationItems = async (req, res) => {
  try {
    const { recruiterId } = req.params;
    const { requests } = req.body;

    const recruiter = await Recruiter.findById(recruiterId).populate("userId");
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    requests.forEach((request) => {
      recruiter.validationRequests.push({
        type: request.type,
        message: request.message,
        requiredDocuments: request.requiredDocuments || 0,
        requiredFields: request.requiredFields || [],
        status: "pending",
      });
    });

    const hasDocRequest = requests.some((r) => r.type === "document");
    const hasInfoRequest = requests.some((r) => r.type === "information");

    if (hasDocRequest && hasInfoRequest) {
      recruiter.status = "pending_info_and_documents";
    } else if (hasDocRequest) {
      recruiter.status = "pending_documents";
    } else if (hasInfoRequest) {
      recruiter.status = "pending_info";
    } else {
      return res.status(400).json({ msg: "Aucune demande valide reÃ§ue." });
    }

    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Action requise : Des informations ou documents vous sont demandÃ©s.`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_multiple_requests",
      { type: "recruiter", id: recruiter._id },
      { requestCount: requests.length, newStatus: recruiter.status },
      req,
    );

    res.json({
      msg: `Demandes envoyÃ©es. Statut mis Ã  jour vers : ${recruiter.status} âœ…`,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllCompanies = async (req, res) => {
  try {
    const { page = 1, limit = 20, search, status } = req.query;

    let query = {};

    if (status) {
      query.status = status;
    }

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { industry: { $regex: search, $options: "i" } },
      ];
    }

    const skip = (page - 1) * limit;

    const companies = await Company.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Company.countDocuments(query);

    const enrichedCompanies = await Promise.all(
      companies.map(async (company) => {
        const recruitersCount = await Recruiter.countDocuments({
          companyId: company._id,
        });
        return {
          ...company.toObject(),
          recruitersCount,
        };
      }),
    );

    res.json({
      data: enrichedCompanies,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const getOfferDetailsAdmin = async (req, res) => {
  try {
    const { id } = req.params;

    const offer = await Offer.findById(id)
      .populate("companyId", "name logo status website location")
      .populate({
        path: "recruteurId",
        select: "userId position status telephone",
        populate: { path: "userId", select: "nom email" },
      });

    if (!offer) return res.status(404).json({ msg: "Offre introuvable." });

    res.json(offer);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const updateOfferByAdmin = async (req, res) => {
  try {
    const { id } = req.params;

    const offer = await Offer.findByIdAndUpdate(
      id,
      { $set: req.body },
      { new: true },
    );

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    await logAdminAction(
      req.user.id,
      "offer_updated_by_admin",
      { type: "offer", id: offer._id },
      { updates: req.body },
      req,
    );

    res.json({ msg: "Offre modifiÃ©e par l'admin âœ…", offer });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const toggleOfferVisibility = async (req, res) => {
  try {
    const { id } = req.params;
    const { actif } = req.body;

    const offer = await Offer.findByIdAndUpdate(
      id,
      { actif: actif },
      { new: true },
    );

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    await logAdminAction(
      req.user.id,
      actif ? "offer_activated_admin" : "offer_deactivated_admin",
      { type: "offer", id: offer._id },
      {},
      req,
    );

    res.json({
      msg: `Offre ${actif ? "activÃ©e" : "dÃ©sactivÃ©e"} avec succÃ¨s`,
      offer,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateDetailsAdmin = async (req, res) => {
  const candidate = await Candidate.findById(req.params.id).populate("userId");
  res.json(candidate);
};


=== controllers\adminSettingsController.js ===
import SystemSettings from "../models/SystemSettings.js";
import { verifySmtpConnection } from "../services/emailService.js";


export const toggleEmailVerificationMode = async (req, res) => {
  try {
    const { mode } = req.body;

    if (!["smtp", "development"].includes(mode)) {
      return res.status(400).json({
        msg: "Mode invalide. Utilisez 'smtp' ou 'development'.",
      });
    }

    
    if (mode === "smtp") {
      const isConnected = await verifySmtpConnection();
      if (!isConnected) {
        return res.status(400).json({
          msg: "Impossible d'activer le mode SMTP : connexion SMTP Ã©chouÃ©e. VÃ©rifiez les variables d'environnement SMTP.",
        });
      }
    }

    await SystemSettings.setSetting(
      "email_verification_mode",
      mode,
      "Mode de vÃ©rification email",
      req.user.id,
    );

    res.json({
      msg: `Mode de vÃ©rification email changÃ© en : ${mode}`,
      mode,
      description:
        mode === "smtp"
          ? "Les emails de vÃ©rification seront envoyÃ©s via SMTP"
          : "Mode dÃ©veloppement actif : le code 123456 sera acceptÃ© pour tous les utilisateurs",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getEmailVerificationMode = async (req, res) => {
  try {
    const mode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );

    res.json({
      mode,
      description:
        mode === "smtp"
          ? "Les emails de vÃ©rification sont envoyÃ©s via SMTP"
          : "Mode dÃ©veloppement : le code 123456 est acceptÃ©",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const toggleSkillProposal = async (req, res) => {
  try {
    const { enabled } = req.body;

    if (typeof enabled !== "boolean") {
      return res
        .status(400)
        .json({ msg: "Valeur 'enabled' requise (boolean)" });
    }

    await SystemSettings.setSetting(
      "skill_proposal_enabled",
      enabled,
      "Permet aux candidats de proposer de nouvelles compÃ©tences",
      req.user.id,
    );

    res.json({
      msg: enabled
        ? "Proposition de compÃ©tences activÃ©e"
        : "Proposition de compÃ©tences dÃ©sactivÃ©e",
      enabled,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getAllSettings = async (req, res) => {
  try {
    const settings = await SystemSettings.find({})
      .select("-__v")
      .populate("updatedBy", "nom email");

    res.json(settings);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getSettingsByCategory = async (req, res) => {
  try {
    const { category } = req.params;
    const validCategories = [
      "general",
      "email",
      "skills",
      "candidates",
      "recruiters",
      "security",
    ];

    if (!validCategories.includes(category)) {
      return res.status(400).json({ msg: "CatÃ©gorie invalide." });
    }

    const settings = await SystemSettings.getSettingsByCategory(category);
    res.json(settings);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateSettingsBulk = async (req, res) => {
  try {
    const { settings } = req.body;

    if (!settings || typeof settings !== "object") {
      return res.status(400).json({ msg: "Settings object requis." });
    }

    const results = [];
    for (const [key, value] of Object.entries(settings)) {
      const updated = await SystemSettings.setSetting(
        key,
        value,
        null,
        req.user.id,
      );
      results.push({ key, value: updated.value });
    }

    res.json({
      msg: "ParamÃ¨tres mis Ã  jour",
      updated: results,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\candidateController.js ===
import Candidate from "../models/Candidate.js";
import Offer from "../models/Offer.js";
import User from "../models/User.js";
import Application from "../models/Application.js";
import Company from "../models/Company.js";
import Skill from "../models/Skills.js";
import ProposedSkill from "../models/ProposedSkill.js";
import SystemSettings from "../models/SystemSettings.js";
import Notification from "../models/Notification.js";
import Interview from "../models/Interview.js";
import {
  uploadCV as cloudinaryUploadCV,
  uploadProfileImage,
  deleteFromCloudinary,
  getPublicIdFromUrl,
  deleteMultipleFromCloudinary,
} from "../config/cloudinary.js";
import { calculateProfileCompletion } from "../utils/profileCompletion.js";

import {
  addSkillToCandidate as addSkill,
  updateCandidateSkill as updateSkill,
  deleteCandidateSkill as deleteSkill,
  getSkillDetails,
  submitSkillFeedback,
} from "./skillController.js";



export const getProfile = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id })
      .populate("userId", "nom email emailVerified")
      .populate("skills.officialSkillId", "name category");

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const user = await User.findById(req.user.id);
    const completion = calculateProfileCompletion(candidate, user);

    res.json({
      profil: candidate,
      completion,
      emailVerified: user.emailVerified,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const {
      telephone,
      residence,
      searchPreferences,
      desiredPosition,
      desiredJobTypes,
      dateOfBirth,
      bio,
      gender,
      autoriserProposition,
      links,
    } = req.body;

    let candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      candidate = new Candidate({ userId });
    }

    
    if (telephone !== undefined) candidate.telephone = telephone;
    if (residence !== undefined) candidate.residence = residence;
    if (searchPreferences !== undefined)
      candidate.searchPreferences = searchPreferences;
    if (desiredPosition !== undefined)
      candidate.desiredPosition = desiredPosition;
    if (desiredJobTypes !== undefined)
      candidate.desiredJobTypes = desiredJobTypes;
    if (dateOfBirth !== undefined) candidate.dateOfBirth = dateOfBirth;
    if (bio !== undefined) candidate.bio = bio;
    if (gender !== undefined) candidate.gender = gender;
    if (autoriserProposition !== undefined)
      candidate.autoriserProposition = autoriserProposition;
    if (links !== undefined) candidate.links = links;

    await candidate.save();

    const user = await User.findById(userId);
    const completion = calculateProfileCompletion(candidate, user);

    res.json({
      msg: "Profil mis Ã  jour âœ…",
      candidate,
      completion,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAccount = async (req, res) => {
  try {
    const userId = req.user.id;
    const { nom, email, motDePasse } = req.body;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable." });
    }

    if (nom) user.nom = nom;

    if (email && email !== user.email) {
      const emailExists = await User.findOne({ email, _id: { $ne: userId } });
      if (emailExists) {
        return res.status(400).json({ msg: "Cet email est dÃ©jÃ  utilisÃ©." });
      }
      
      user.email = email;
    }

    if (motDePasse) {
      const bcrypt = await import("bcryptjs");
      user.motDePasse = await bcrypt.default.hash(motDePasse, 10);
    }

    await user.save();
    res.json({ msg: "Compte mis Ã  jour âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const uploadProfilePicture = async (req, res) => {
  try {
    const userId = req.user.id;
    const candidate = await Candidate.findOne({ userId });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    if (!req.file) {
      return res.status(400).json({ msg: "Aucune image fournie." });
    }

    
    if (candidate.profilePicture) {
      const publicId = getPublicIdFromUrl(candidate.profilePicture);
      if (publicId) {
        await deleteFromCloudinary(publicId, "image");
      }
    }

    
    const result = await uploadProfileImage(req.file.buffer, userId);

    candidate.profilePicture = result.secure_url;
    await candidate.save();

    res.json({
      msg: "Photo de profil mise Ã  jour ðŸ“¸",
      profilePicture: candidate.profilePicture,
    });
  } catch (err) {
    console.error("Profile picture upload error:", err);
    res.status(500).json({ msg: "Erreur lors du tÃ©lÃ©chargement de l'image" });
  }
};

export const uploadCandidateCV = async (req, res) => {
  try {
    const userId = req.user.id;
    const candidate = await Candidate.findOne({ userId });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const maxCVs = await SystemSettings.getSetting("max_cv_per_candidate", 3);
    if (candidate.cvs.length >= maxCVs) {
      return res.status(400).json({
        msg: `Vous ne pouvez pas ajouter plus de ${maxCVs} CV.`,
      });
    }

    if (!req.file) {
      return res.status(400).json({ msg: "Aucun fichier fourni." });
    }

    
    const result = await cloudinaryUploadCV(
      req.file.buffer,
      req.file.originalname,
      userId,
    );

    
    const fileSize = req.file.size;
    let score = 100;
    if (fileSize < 20 * 1024)
      score = 50; 
    else if (fileSize > 5 * 1024 * 1024) score = 70; 

    candidate.cvs.push({
      url: result.secure_url,
      dateDepot: new Date(),
      score,
    });

    await candidate.save();

    res.json({
      msg: "CV ajoutÃ© avec succÃ¨s âœ…",
      cv: {
        _id: candidate.cvs[candidate.cvs.length - 1]._id,
        url: result.secure_url,
        score,
      },
    });
  } catch (err) {
    console.error("CV upload error:", err);
    res.status(500).json({ msg: "Erreur lors du tÃ©lÃ©chargement du CV" });
  }
};

export const deleteCV = async (req, res) => {
  try {
    const userId = req.user.id;
    const { cvId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const cv = candidate.cvs.id(cvId);
    if (!cv) {
      return res.status(404).json({ msg: "CV introuvable." });
    }

    
    const publicId = getPublicIdFromUrl(cv.url);
    if (publicId) {
      await deleteFromCloudinary(publicId, "raw");
    }

    candidate.cvs.pull(cvId);
    await candidate.save();

    res.json({
      msg: "CV supprimÃ© avec succÃ¨s ðŸ—‘ï¸",
      cvs: candidate.cvs,
    });
  } catch (err) {
    console.error("CV deletion error:", err);
    res.status(500).json({ msg: err.message });
  }
};





export const addExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const { jobTitle, company, startDate, endDate, description } = req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    candidate.experiences.push({
      jobTitle,
      company,
      startDate,
      endDate: endDate || null,
      description,
    });

    await candidate.save();

    res.json({ msg: "ExpÃ©rience ajoutÃ©e", experiences: candidate.experiences });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const { experienceId } = req.params;
    const { jobTitle, company, startDate, endDate, description } = req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const experience = candidate.experiences.id(experienceId);
    if (!experience) {
      return res.status(404).json({ msg: "ExpÃ©rience introuvable." });
    }

    if (jobTitle) experience.jobTitle = jobTitle;
    if (company) experience.company = company;
    if (startDate) experience.startDate = startDate;
    if (endDate !== undefined) experience.endDate = endDate;
    if (description !== undefined) experience.description = description;

    await candidate.save();

    res.json({
      msg: "ExpÃ©rience mise Ã  jour",
      experiences: candidate.experiences,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const { experienceId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    candidate.experiences.pull(experienceId);
    await candidate.save();

    res.json({
      msg: "ExpÃ©rience supprimÃ©e",
      experiences: candidate.experiences,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const addEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { institut, degree, fieldOfStudy, startDate, endDate, description } =
      req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    candidate.education.push({
      institut,
      degree,
      fieldOfStudy,
      startDate,
      endDate: endDate || null,
      description,
    });

    await candidate.save();

    res.json({
      msg: "Formation ajoutÃ©e avec succÃ¨s ðŸŽ“",
      education: candidate.education,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { educationId } = req.params;
    const { institut, degree, fieldOfStudy, startDate, endDate, description } =
      req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const edu = candidate.education.id(educationId);
    if (!edu) {
      return res.status(404).json({ msg: "Formation introuvable." });
    }

    if (institut) edu.institut = institut;
    if (degree) edu.degree = degree;
    if (fieldOfStudy !== undefined) edu.fieldOfStudy = fieldOfStudy;
    if (startDate) edu.startDate = startDate;
    if (endDate !== undefined) edu.endDate = endDate;
    if (description !== undefined) edu.description = description;

    await candidate.save();

    res.json({
      msg: "Formation mise Ã  jour âœ…",
      education: candidate.education,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { educationId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    candidate.education.pull(educationId);
    await candidate.save();

    res.json({ msg: "Formation supprimÃ©e ðŸ—‘ï¸", education: candidate.education });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const getFavorites = async (req, res) => {
  try {
    const userId = req.user.id;

    const candidate = await Candidate.findOne({ userId }).populate({
      path: "favoris.offerId",
      select:
        "titre companyId type wilaya salaryMin salaryMax datePublication actif validationStatus",
      populate: {
        path: "companyId",
        select: "name logo location",
      },
    });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    
    const validFavorites = candidate.favoris
      .filter((f) => f.offerId !== null)
      .map((f) => ({
        _id: f._id,
        savedAt: f.savedAt,
        offer: {
          _id: f.offerId._id,
          titre: f.offerId.titre,
          type: f.offerId.type,
          wilaya: f.offerId.wilaya,
          salaryMin: f.offerId.salaryMin,
          salaryMax: f.offerId.salaryMax,
          datePublication: f.offerId.datePublication,
          isActive:
            f.offerId.actif && f.offerId.validationStatus === "approved",
          company: {
            name: f.offerId.companyId?.name,
            logo: f.offerId.companyId?.logo,
            location: f.offerId.companyId?.location,
          },
        },
      }));

    res.json(validFavorites);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const addToFavorites = async (req, res) => {
  try {
    const { offerId } = req.params;
    const userId = req.user.id;

    const offerExists = await Offer.exists({
      _id: offerId,
      actif: true,
      validationStatus: "approved",
    });
    if (!offerExists) {
      return res.status(404).json({ msg: "Offre introuvable ou inactive." });
    }

    const candidateCheck = await Candidate.findOne({
      userId,
      "favoris.offerId": offerId,
    });

    if (candidateCheck) {
      return res
        .status(400)
        .json({ msg: "Cette offre est dÃ©jÃ  dans vos favoris." });
    }

    const updatedCandidate = await Candidate.findOneAndUpdate(
      { userId },
      {
        $push: {
          favoris: {
            offerId: offerId,
            savedAt: new Date(),
          },
        },
      },
      { new: true },
    );

    if (!updatedCandidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable." });
    }

    res.json({
      msg: "Offre ajoutÃ©e aux favoris â¤ï¸",
      favorisCount: updatedCandidate.favoris.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const removeFromFavorites = async (req, res) => {
  try {
    const { offerId } = req.params;
    const userId = req.user.id;

    const updatedCandidate = await Candidate.findOneAndUpdate(
      { userId },
      {
        $pull: {
          favoris: { offerId: offerId },
        },
      },
      { new: true },
    );

    if (!updatedCandidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable." });
    }

    res.json({
      msg: "Offre retirÃ©e des favoris ðŸ’”",
      favorisCount: updatedCandidate.favoris.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const applyToOffer = async (req, res) => {
  try {
    const userId = req.user.id;
    const { offreId, cvUrl, coverLetter } = req.body;

    const candidate = await Candidate.findOne({ userId });
    const user = await User.findById(userId);

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    if (!user.emailVerified) {
      return res.status(403).json({
        msg: "Email non vÃ©rifiÃ©.",
        code: "EMAIL_NOT_VERIFIED",
      });
    }

    const completion = calculateProfileCompletion(candidate, user);
    if (!completion.canApply) {
      return res.status(400).json({
        msg: "Profil incomplet.",
        missing: completion.missingForApplication,
      });
    }

    const cvExists = candidate.cvs.some((cv) => cv.url === cvUrl);
    if (!cvExists) {
      return res.status(400).json({ msg: "CV invalide." });
    }

    const offer = await Offer.findById(offreId);
    if (!offer || !offer.actif || offer.validationStatus !== "approved") {
      return res
        .status(400)
        .json({ msg: "Cette offre n'est plus disponible." });
    }

    
    const existingApp = await Application.findOne({
      offerId: offreId,
      candidateId: candidate._id,
    });

    if (existingApp) {
      const activeStatuses = ["envoyee", "en_cours", "retenue", "non_retenue"];

      if (activeStatuses.includes(existingApp.candidateStatus)) {
        return res.status(400).json({
          msg: "Vous avez dÃ©jÃ  une candidature active pour cette offre.",
        });
      }

      if (["cancelled", "retiree"].includes(existingApp.candidateStatus)) {
        if (offer.allowRepostulation === false) {
          return res.status(403).json({
            msg: "L'employeur n'accepte pas les repostulations pour cette offre.",
          });
        }

        const wasWithdrawn = existingApp.candidateStatus === "retiree";

        existingApp.candidateStatus = "envoyee";
        existingApp.recruiterStatus = "nouvelle";
        existingApp.cvUrl = cvUrl;
        existingApp.coverLetter = coverLetter || "";
        existingApp.seenByRecruiter = false;
        existingApp.seenAt = null;
        existingApp.datePostulation = new Date();
        existingApp.isRepostulation = true;
        existingApp.withdrawReason = undefined;
        existingApp.withdrawnAt = undefined;

        existingApp.statusHistory.push({
          candidateStatus: "envoyee",
          recruiterStatus: "nouvelle",
          changedBy: userId,
          note: wasWithdrawn
            ? "Repostulation aprÃ¨s retrait"
            : "Nouvelle postulation aprÃ¨s annulation",
        });

        await existingApp.save();

        await Offer.findByIdAndUpdate(offreId, {
          $inc: { nombreCandidatures: 1 },
        });

        return res.json({
          msg: "Candidature envoyÃ©e avec succÃ¨s âœ…",
          applicationId: existingApp._id,
          reactivated: true,
        });
      }
    }

    
    const company = await Company.findById(offer.companyId);

    const newApplication = await Application.create({
      offerId: offreId,
      candidateId: candidate._id,
      cvUrl,
      coverLetter: coverLetter || "",
      candidateStatus: "envoyee",
      recruiterStatus: "nouvelle",
      source: "direct",
      isRepostulation: false,
      offerSnapshot: {
        titre: offer.titre,
        entrepriseNom: company?.name || "Entreprise",
        companyId: offer.companyId,
        location: offer.wilaya,
        wilaya: offer.wilaya,
        salaryMin: offer.salaryMin,
        salaryMax: offer.salaryMax,
        type: offer.type,
        domaine: offer.domaine,
      },
    });

    await Offer.findByIdAndUpdate(offreId, {
      $inc: { nombreCandidatures: 1 },
    });

    res.json({
      msg: "Candidature envoyÃ©e avec succÃ¨s âœ…",
      applicationId: newApplication._id,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const getCandidateStats = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const [
      totalApplications,
      applicationsByStatus,
      recentApplications,
      weeklyApplications,
      viewedApplications,
      upcomingInterviews,
      pendingInterviewResponses,
    ] = await Promise.all([
      Application.countDocuments({ candidateId: candidate._id }),
      Application.aggregate([
        { $match: { candidateId: candidate._id } },
        { $group: { _id: "$candidateStatus", count: { $sum: 1 } } },
      ]),
      Application.countDocuments({
        candidateId: candidate._id,
        datePostulation: { $gte: thirtyDaysAgo },
      }),
      Application.countDocuments({
        candidateId: candidate._id,
        datePostulation: { $gte: sevenDaysAgo },
      }),
      Application.countDocuments({
        candidateId: candidate._id,
        seenByRecruiter: true,
      }),
      Interview.countDocuments({
        candidateId: candidate._id,
        status: "confirmed",
        scheduledAt: { $gte: new Date() },
      }),
      Interview.countDocuments({
        candidateId: candidate._id,
        status: "proposed",
        scheduledAt: { $gte: new Date() },
      }),
    ]);

    const statusMap = {};
    applicationsByStatus.forEach((item) => {
      statusMap[item._id] = item.count;
    });

    const responded =
      (statusMap["retenue"] || 0) +
      (statusMap["non_retenue"] || 0) +
      (statusMap["en_cours"] || 0);

    const responseRate =
      totalApplications > 0
        ? Math.round((responded / totalApplications) * 100)
        : 0;

    const viewRate =
      totalApplications > 0
        ? Math.round((viewedApplications / totalApplications) * 100)
        : 0;

    const user = await User.findById(req.user.id);
    const profileCompletion = calculateProfileCompletion(candidate, user);

    
    const suggestions = [];

    if (!user.emailVerified) {
      suggestions.push({
        type: "critical",
        priority: 1,
        message: "Confirmez votre email pour postuler aux offres",
        action: "verify_email",
        icon: "mail",
      });
    }

    if (profileCompletion.percentage < 100) {
      suggestions.push({
        type: "important",
        priority: 2,
        message: `ComplÃ©tez votre profil (${profileCompletion.percentage}%)`,
        action: "complete_profile",
        missing: profileCompletion.missing,
        icon: "user",
      });
    }

    if (candidate.cvs.length === 0) {
      suggestions.push({
        type: "important",
        priority: 3,
        message: "Ajoutez votre CV pour augmenter vos chances",
        action: "upload_cv",
        icon: "file",
      });
    }

    if (candidate.skills.length < 3) {
      suggestions.push({
        type: "suggestion",
        priority: 4,
        message:
          "Ajoutez plus de compÃ©tences pour de meilleures recommandations",
        action: "add_skills",
        icon: "star",
      });
    }

    if (pendingInterviewResponses > 0) {
      suggestions.push({
        type: "urgent",
        priority: 0,
        message: `${pendingInterviewResponses} proposition(s) d'entretien en attente`,
        action: "view_interviews",
        icon: "calendar",
      });
    }

    
    suggestions.sort((a, b) => a.priority - b.priority);

    res.json({
      applications: {
        total: totalApplications,
        thisMonth: recentApplications,
        thisWeek: weeklyApplications,
        byStatus: statusMap,
      },
      interviews: {
        upcoming: upcomingInterviews,
        pendingResponse: pendingInterviewResponses,
      },
      favorites: candidate.favoris.length,
      rates: {
        response: responseRate,
        view: viewRate,
      },
      completion: profileCompletion,
      suggestions,
      cvCount: candidate.cvs.length,
      skillCount: candidate.skills.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getActivityTimeline = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    const { limit = 20 } = req.query;

    
    const recentApplications = await Application.find({
      candidateId: candidate._id,
    })
      .sort({ updatedAt: -1 })
      .limit(parseInt(limit))
      .populate({
        path: "offerId",
        select: "titre",
        populate: { path: "companyId", select: "name logo" },
      })
      .lean();

    
    const recentInterviews = await Interview.find({
      candidateId: candidate._id,
    })
      .sort({ updatedAt: -1 })
      .limit(10)
      .populate("offerId", "titre")
      .lean();

    
    const activities = [
      ...recentApplications.map((app) => ({
        type: "application",
        date: app.updatedAt,
        title:
          app.offerId?.titre || app.offerSnapshot?.titre || "Offre supprimÃ©e",
        company:
          app.offerId?.companyId?.name || app.offerSnapshot?.entrepriseNom,
        companyLogo: app.offerId?.companyId?.logo,
        status: app.candidateStatus,
        applicationId: app._id,
        icon: getApplicationIcon(app.candidateStatus),
      })),
      ...recentInterviews.map((interview) => ({
        type: "interview",
        date: interview.updatedAt,
        title: interview.offerId?.titre || "Offre supprimÃ©e",
        status: interview.status,
        scheduledAt: interview.scheduledAt,
        interviewType: interview.type,
        interviewId: interview._id,
        icon: getInterviewIcon(interview.status),
      })),
    ];

    
    activities.sort((a, b) => new Date(b.date) - new Date(a.date));

    res.json(activities.slice(0, parseInt(limit)));
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


function getApplicationIcon(status) {
  const icons = {
    envoyee: "send",
    en_cours: "clock",
    retenue: "check-circle",
    non_retenue: "x-circle",
    retiree: "arrow-left",
    cancelled: "x",
  };
  return icons[status] || "file";
}

function getInterviewIcon(status) {
  const icons = {
    proposed: "calendar-plus",
    confirmed: "calendar-check",
    completed: "check",
    cancelled_by_candidate: "x",
    cancelled_by_recruiter: "x",
  };
  return icons[status] || "calendar";
}



export const getRecommendedOffers = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    
    const appliedOfferIds = await Application.find({
      candidateId: candidate._id,
    }).distinct("offerId");

    
    const baseQuery = {
      actif: true,
      validationStatus: "approved",
      _id: { $nin: appliedOfferIds },
    };

    const candidateSkills = [];

    for (const skill of candidate.skills || []) {
      if (!skill.isVisibleToRecruiters) continue;

      
      if (skill.normalizedText) {
        candidateSkills.push(skill.normalizedText);
      }

      
      if (skill.officialSkillName) {
        candidateSkills.push(skill.officialSkillName.toLowerCase());
      }

      
      if (skill.domain) {
        candidateSkills.push(skill.domain.toLowerCase());
      }
    }

    const candidateWilaya = candidate.residence?.wilaya;
    const desiredPosition = candidate.desiredPosition?.toLowerCase();
    const desiredJobTypes = candidate.desiredJobTypes || [];

    
    if (candidateSkills.length === 0 && !candidateWilaya && !desiredPosition) {
      const popularOffers = await Offer.find(baseQuery)
        .populate("companyId", "name logo location")
        .sort({ nombreCandidatures: -1 })
        .limit(10)
        .lean();

      return res.json(
        popularOffers.map((o) => ({
          ...o,
          matchScore: 0,
          matchReasons: ["Offres populaires"],
        })),
      );
    }

    
    const queryConditions = [];

    
    if (candidateSkills.length > 0) {
      queryConditions.push({
        skills: {
          $in: candidateSkills.map((s) => new RegExp(s, "i")),
        },
      });
    }

    
    if (candidateWilaya) {
      queryConditions.push({ wilaya: candidateWilaya });
    }

    
    if (desiredPosition) {
      queryConditions.push({
        titre: { $regex: desiredPosition, $options: "i" },
      });
    }

    
    if (desiredJobTypes.length > 0) {
      queryConditions.push({ type: { $in: desiredJobTypes } });
    }

    
    let offerQuery = { ...baseQuery };
    if (queryConditions.length > 0) {
      offerQuery.$or = queryConditions;
    }

    const offers = await Offer.find(offerQuery)
      .populate("companyId", "name logo location industry")
      .sort({ datePublication: -1 })
      .limit(50)
      .lean();

    
    const scoredOffers = offers.map((offer) => {
      let score = 0;
      const matchReasons = [];

      
      const offerSkills = (offer.skills || []).map((s) =>
        s.trim().toLowerCase(),
      );
      const matchingSkills = offerSkills.filter((skill) =>
        candidateSkills.some((cs) => skill.includes(cs) || cs.includes(skill)),
      );
      if (matchingSkills.length > 0) {
        const skillScore = Math.min(
          (matchingSkills.length / Math.max(offerSkills.length, 1)) * 40,
          40,
        );
        score += skillScore;
        matchReasons.push(
          `${matchingSkills.length} compÃ©tence(s) correspondante(s)`,
        );
      }

      
      if (candidateWilaya && offer.wilaya === candidateWilaya) {
        score += 25;
        matchReasons.push("MÃªme wilaya");
      }

      
      if (desiredJobTypes.length > 0 && desiredJobTypes.includes(offer.type)) {
        score += 20;
        matchReasons.push("Type de contrat souhaitÃ©");
      }

      
      if (
        desiredPosition &&
        offer.titre.toLowerCase().includes(desiredPosition)
      ) {
        score += 15;
        matchReasons.push("Correspond au poste recherchÃ©");
      }

      
      const isNew =
        new Date() - new Date(offer.datePublication) < 7 * 24 * 60 * 60 * 1000;
      if (isNew) {
        score += 5;
        matchReasons.push("Offre rÃ©cente");
      }

      return {
        ...offer,
        matchScore: Math.round(score),
        matchReasons,
        matchingSkills,
        isNew,
      };
    });

    
    scoredOffers.sort((a, b) => {
      if (b.matchScore !== a.matchScore) {
        return b.matchScore - a.matchScore;
      }
      return (
        new Date(b.datePublication).getTime() -
        new Date(a.datePublication).getTime()
      );
    });

    
    res.json(scoredOffers.slice(0, 10));
  } catch (err) {
    console.error("Recommendation error:", err);
    res.status(500).json({ msg: err.message });
  }
};
export {
  addSkill,
  updateSkill,
  deleteSkill,
  getSkillDetails,
  submitSkillFeedback,
};


=== controllers\notificationController.js ===
import Notification from "../models/Notification.js";

export const getMyNotifications = async (req, res) => {
  try {
    const notifications = await Notification.find({ userId: req.user.id }).sort(
      {
        date: -1,
      }
    );
    res.json(notifications);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getUnreadCount = async (req, res) => {
  try {
    const count = await Notification.countDocuments({
      userId: req.user.id,
      lu: false,
    });
    res.json({ count });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const markAsRead = async (req, res) => {
  try {
    const notification = await Notification.findOneAndUpdate(
      { _id: req.params.id, userId: req.user.id },
      { lu: true },
      { new: true }
    );

    if (!notification)
      return res.status(404).json({ msg: "Notification introuvable" });

    res.json(notification);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\offerController.js ===
import Offer from "../models/Offer.js";
import Company from "../models/Company.js";
import AnemOffer from "../models/AnemOffer.js";

const toCursor = (payload) => {
  return Buffer.from(JSON.stringify(payload)).toString("base64");
};

const fromCursor = (cursor) => {
  try {
    return JSON.parse(Buffer.from(cursor, "base64").toString("utf8"));
  } catch (e) {
    return null;
  }
};

export const getAllActiveOffers = async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    const {
      cursor,
      wilaya,
      sort,
      search,
      type,
      domaine,
      experienceLevel,
      minSalary,
      maxSalary,
      hasAnem,
    } = req.query;

    let query = { actif: true, validationStatus: "approved" };

    if (wilaya) {
      query.wilaya = { $regex: new RegExp(`^${wilaya}$`, "i") };
    }

    if (type) {
      query.type = type;
    }

    if (domaine) {
      query.domaine = domaine;
    }

    if (experienceLevel) {
      query.experienceLevel = experienceLevel;
    }

    if (minSalary) {
      query.salaryMax = { $gte: parseInt(minSalary) };
    }

    if (maxSalary) {
      query.salaryMin = { $lte: parseInt(maxSalary) };
    }

    
    if (hasAnem === "true" || hasAnem === "false") {
      const anemOfferIds = await AnemOffer.find({ anemEnabled: true }).distinct(
        "offerId",
      );
      if (hasAnem === "true") {
        query._id = { $in: anemOfferIds };
      } else {
        query._id = { $nin: anemOfferIds };
      }
    }

    if (search) {
      const matchingCompanies = await Company.find({
        name: { $regex: search, $options: "i" },
      }).select("_id");

      const companyIds = matchingCompanies.map((c) => c._id);

      query.$or = [
        { titre: { $regex: search, $options: "i" } },
        { description: { $regex: search, $options: "i" } },
        { skills: { $in: [new RegExp(search, "i")] } },
        { companyId: { $in: companyIds } },
      ];
    }

    if (cursor) {
      const decrypted = fromCursor(cursor);

      if (decrypted) {
        const { id, value } = decrypted;

        if (sort === "popular") {
          query.$and = [
            ...(query.$and || []),
            {
              $or: [
                { nombreCandidatures: { $lt: value } },
                { nombreCandidatures: value, _id: { $lt: id } },
              ],
            },
          ];
        } else {
          query.$and = [
            ...(query.$and || []),
            {
              $or: [
                { datePublication: { $lt: new Date(value) } },
                { datePublication: new Date(value), _id: { $lt: id } },
              ],
            },
          ];
        }
      }
    }

    let sortQuery = {};
    if (sort === "popular") {
      sortQuery = { nombreCandidatures: -1, _id: -1 };
    } else {
      sortQuery = { datePublication: -1, _id: -1 };
    }

    const offers = await Offer.find(query)
      .populate("companyId", "name logo location industry")
      .populate("recruteurId", "position")
      .sort(sortQuery)
      .limit(limit + 1);

    const hasNextPage = offers.length > limit;
    const data = hasNextPage ? offers.slice(0, limit) : offers;

    
    const offerIds = data.map((o) => o._id);
    const anemOffers = await AnemOffer.find({
      offerId: { $in: offerIds },
      anemEnabled: true,
    }).lean();
    const anemMap = new Map(
      anemOffers.map((a) => [a.offerId.toString(), true]),
    );

    const enrichedData = data.map((offer) => {
      const isNew =
        new Date() - new Date(offer.datePublication) < 2 * 24 * 60 * 60 * 1000;
      return {
        ...offer.toObject(),
        isNew,
        hasAnem: anemMap.has(offer._id.toString()),
      };
    });

    let nextCursor = null;
    if (hasNextPage && data.length > 0) {
      const lastItem = data[data.length - 1];

      const cursorValue =
        sort === "popular"
          ? lastItem.nombreCandidatures
          : lastItem.datePublication;

      nextCursor = toCursor({
        id: lastItem._id,
        value: cursorValue,
      });
    }

    res.json({
      data: enrichedData,
      meta: {
        nextCursor,
        hasNextPage,
        limit,
      },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: err.message });
  }
};

export const getOfferDetails = async (req, res) => {
  try {
    const offer = await Offer.findOne({ _id: req.params.id, actif: true })
      .populate("companyId", "name logo website description location size")
      .populate("recruteurId", "position");

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    const isNew =
      new Date() - new Date(offer.datePublication) < 2 * 24 * 60 * 60 * 1000;

    
    const anemOffer = await AnemOffer.findOne({
      offerId: offer._id,
      anemEnabled: true,
    }).lean();

    res.json({
      ...offer.toObject(),
      isNew,
      hasAnem: !!anemOffer,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\skillController.js ===
import Skill from "../models/Skills.js";
import SkillCluster from "../models/SkillCluster.js";
import SkillFeedback from "../models/SkillFeedback.js";
import ProposedSkill from "../models/ProposedSkill.js";
import Candidate from "../models/Candidate.js";
import User from "../models/User.js";
import SystemSettings from "../models/SystemSettings.js";
import { logAdminAction } from "../models/AdminLog.js";



const ABUSE_PATTERNS = [
  /\b(ceo of|king of|lord of|god of|master of)\b/i,
  /\b(fuck|shit|ass|porn|xxx|dick|pussy|bitch)\b/i,
  /(.)\1{4,}/i, 
  /^.{0,1}$/i, 
  /^.{100,}$/i, 
];

const detectAbuse = (text) => {
  for (const pattern of ABUSE_PATTERNS) {
    if (pattern.test(text)) {
      return true;
    }
  }
  return false;
};



const levenshtein = (a, b) => {
  const matrix = Array.from({ length: a.length + 1 }, (_, i) =>
    Array.from({ length: b.length + 1 }, (_, j) =>
      i === 0 ? j : j === 0 ? i : 0,
    ),
  );
  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost,
      );
    }
  }
  return matrix[a.length][b.length];
};

const similarity = (a, b) => {
  const maxLen = Math.max(a.length, b.length);
  if (maxLen === 0) return 1;
  return 1 - levenshtein(a, b) / maxLen;
};

const findBestMatch = async (rawText, threshold = 0.6) => {
  const normalized = rawText.trim().toLowerCase();

  
  const exactMatch = await Skill.findOne({
    name: normalized,
    isHidden: { $ne: true },
  });
  if (exactMatch) {
    return { match: exactMatch, type: "exact", confidence: 1.0 };
  }

  
  const aliasMatch = await Skill.findOne({
    aliases: normalized,
    isHidden: { $ne: true },
  });
  if (aliasMatch) {
    return { match: aliasMatch, type: "alias", confidence: 0.95 };
  }

  
  const prefix = normalized.substring(
    0,
    Math.max(2, Math.floor(normalized.length * 0.5)),
  );
  const candidates = await Skill.find({
    $or: [
      { name: { $regex: prefix, $options: "i" } },
      { aliases: { $regex: prefix, $options: "i" } },
    ],
    isHidden: { $ne: true },
  })
    .limit(50)
    .lean();

  let bestScore = 0;
  let bestCandidate = null;

  for (const skill of candidates) {
    const nameScore = similarity(normalized, skill.name);
    let maxAliasScore = 0;
    for (const alias of skill.aliases || []) {
      const aliasScore = similarity(normalized, alias);
      if (aliasScore > maxAliasScore) maxAliasScore = aliasScore;
    }
    const score = Math.max(nameScore, maxAliasScore);
    if (score > bestScore) {
      bestScore = score;
      bestCandidate = skill;
    }
  }

  if (bestScore >= threshold && bestCandidate) {
    return {
      match: bestCandidate,
      type: bestScore >= 0.9 ? "alias" : "fuzzy",
      confidence: bestScore,
    };
  }

  return { match: null, type: "unmatched", confidence: 0 };
};






export const getSkills = async (req, res) => {
  try {
    const { search, category } = req.query;

    const suggestionsEnabled = await SystemSettings.getSetting(
      "skill_suggestions_enabled",
      true,
    );

    if (!suggestionsEnabled && search) {
      return res.json({ skills: [], categories: [] });
    }

    let query = { isHidden: { $ne: true } };

    if (search) {
      const escaped = search.trim().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      query.$or = [
        { name: { $regex: escaped, $options: "i" } },
        { aliases: { $regex: escaped, $options: "i" } },
      ];
    }

    if (category) {
      query.category = category;
    }

    const skills = await Skill.find(query)
      .sort({ usageCount: -1, name: 1 })
      .limit(50)
      .select("name category subCategory aliases usageCount")
      .lean();

    const categories = await Skill.distinct("category", {
      isHidden: { $ne: true },
    });

    res.json({
      skills,
      categories: categories.filter(Boolean),
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getSkillProposalStatus = async (req, res) => {
  try {
    const settings = await SystemSettings.getMultipleSettings([
      "skill_proposal_enabled",
      "skill_system_enabled",
      "max_skills_per_candidate",
      "skill_level_enabled",
      "skill_suggestions_enabled",
      "skill_feedback_enabled",
    ]);

    res.json({
      systemEnabled: settings.skill_system_enabled ?? true,
      proposalEnabled: settings.skill_proposal_enabled ?? true,
      maxSkills: settings.max_skills_per_candidate ?? 6,
      levelEnabled: settings.skill_level_enabled ?? true,
      suggestionsEnabled: settings.skill_suggestions_enabled ?? true,
      feedbackEnabled: settings.skill_feedback_enabled ?? true,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const suggestSkills = async (req, res) => {
  try {
    const { q } = req.query;

    if (!q || q.trim().length < 2) {
      return res.json({ suggestions: [] });
    }

    const suggestionsEnabled = await SystemSettings.getSetting(
      "skill_suggestions_enabled",
      true,
    );

    if (!suggestionsEnabled) {
      return res.json({ suggestions: [] });
    }

    const threshold = await SystemSettings.getSetting(
      "skill_suggestion_threshold",
      0.6,
    );

    const normalized = q.trim().toLowerCase();
    const escaped = normalized.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

    
    const officialMatches = await Skill.find({
      $or: [
        { name: { $regex: escaped, $options: "i" } },
        { aliases: { $regex: escaped, $options: "i" } },
      ],
      isHidden: { $ne: true },
    })
      .sort({ usageCount: -1 })
      .limit(10)
      .select("name category usageCount")
      .lean();

    
    const suggestions = officialMatches.map((skill) => {
      const score = similarity(normalized, skill.name);
      let matchLevel = "close";
      if (score >= 0.9) matchLevel = "strong";
      if (score < threshold) matchLevel = "weak";

      return {
        _id: skill._id,
        name: skill.name,
        category: skill.category,
        confidence: Math.round(score * 100) / 100,
        matchLevel,
      };
    });

    
    const filtered = suggestions.filter((s) => s.confidence >= threshold);

    
    filtered.sort((a, b) => b.confidence - a.confidence);

    res.json({
      suggestions: filtered.slice(0, 5),
      query: q.trim(),
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const addSkillToCandidate = async (req, res) => {
  try {
    const userId = req.user.id;
    const { name, level, selectedSuggestionId } = req.body;

    if (!name || name.trim().length === 0) {
      return res
        .status(400)
        .json({ msg: "Le nom de la compÃ©tence est requis." });
    }

    const systemEnabled = await SystemSettings.getSetting(
      "skill_system_enabled",
      true,
    );
    if (!systemEnabled) {
      return res
        .status(400)
        .json({ msg: "Le systÃ¨me de compÃ©tences est actuellement dÃ©sactivÃ©." });
    }

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const maxSkills = await SystemSettings.getSetting(
      "max_skills_per_candidate",
      6,
    );
    if (candidate.skills.length >= maxSkills) {
      return res.status(400).json({
        msg: `Vous ne pouvez pas ajouter plus de ${maxSkills} compÃ©tences.`,
        maxSkills,
      });
    }

    const rawText = name.trim();
    const normalizedText = rawText.toLowerCase();

    
    const existingSkill = candidate.skills.find(
      (s) => s.normalizedText === normalizedText,
    );
    if (existingSkill) {
      return res.status(400).json({ msg: "Vous avez dÃ©jÃ  cette compÃ©tence." });
    }

    
    const abuseEnabled = await SystemSettings.getSetting(
      "skill_abuse_detection_enabled",
      true,
    );
    const isAbusive = abuseEnabled && detectAbuse(rawText);

    
    const skillEntry = {
      rawText,
      normalizedText,
      level: level || "unset",
      addedAt: new Date(),
      isVisibleToRecruiters: !isAbusive,
      isFlagged: isAbusive,
      flagReason: isAbusive ? "auto_detected_abuse" : undefined,
    };

    
    if (selectedSuggestionId) {
      const officialSkill = await Skill.findById(selectedSuggestionId);
      if (officialSkill && !officialSkill.isHidden) {
        skillEntry.officialSkillId = officialSkill._id;
        skillEntry.officialSkillName = officialSkill.name;
        skillEntry.domain = officialSkill.category;
        skillEntry.subDomain = officialSkill.subCategory;
        skillEntry.matchType = "exact";

        
        await Skill.findByIdAndUpdate(officialSkill._id, {
          $inc: { usageCount: 1 },
        });
      }
    } else if (!isAbusive) {
      
      const proposalEnabled = await SystemSettings.getSetting(
        "skill_proposal_enabled",
        true,
      );

      const threshold = await SystemSettings.getSetting(
        "skill_suggestion_threshold",
        0.6,
      );

      const matchResult = await findBestMatch(normalizedText, threshold);

      if (matchResult.match && matchResult.confidence >= 0.9) {
        
        skillEntry.officialSkillId = matchResult.match._id;
        skillEntry.officialSkillName = matchResult.match.name;
        skillEntry.domain = matchResult.match.category;
        skillEntry.subDomain = matchResult.match.subCategory;
        skillEntry.matchType = matchResult.type === "exact" ? "exact" : "alias";

        await Skill.findByIdAndUpdate(matchResult.match._id, {
          $inc: { usageCount: 1 },
        });
      } else {
        
        skillEntry.matchType = "unmatched";

        if (!proposalEnabled) {
          return res.status(400).json({
            msg: "Cette compÃ©tence n'existe pas dans notre liste. Veuillez en sÃ©lectionner une parmi les suggestions.",
          });
        }
      }
    }

    
    if (!isAbusive) {
      try {
        const { cluster } = await SkillCluster.trackVariant(normalizedText);
        skillEntry.clusterId = cluster._id;
      } catch (clusterErr) {
        console.error("Cluster tracking error (non-blocking):", clusterErr);
      }
    } else {
      
      try {
        const { cluster } = await SkillCluster.trackVariant(normalizedText);
        skillEntry.clusterId = cluster._id;
        cluster.isFlagged = true;
        cluster.flagCount = (cluster.flagCount || 0) + 1;
        cluster.flagReasons.push({
          reason: "auto_abuse_detection",
          flaggedBy: "system",
          flaggedAt: new Date(),
        });
        await cluster.save();
      } catch (clusterErr) {
        console.error("Cluster flagging error (non-blocking):", clusterErr);
      }
    }

    candidate.skills.push(skillEntry);
    await candidate.save();

    const addedSkill = candidate.skills[candidate.skills.length - 1];

    res.json({
      msg: "CompÃ©tence ajoutÃ©e",
      skill: {
        _id: addedSkill._id,
        rawText: addedSkill.rawText,
        level: addedSkill.level,
        officialSkillName: addedSkill.officialSkillName,
        domain: addedSkill.domain,
        subDomain: addedSkill.subDomain,
        matchType: addedSkill.matchType,
      },
      totalSkills: candidate.skills.length,
      maxSkills,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateCandidateSkill = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;
    const { level } = req.body;

    const levelEnabled = await SystemSettings.getSetting(
      "skill_level_enabled",
      true,
    );

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const skill = candidate.skills.id(skillId);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable." });
    }

    if (level && levelEnabled) {
      const validLevels = ["beginner", "intermediate", "expert", "unset"];
      if (!validLevels.includes(level)) {
        return res.status(400).json({ msg: "Niveau invalide." });
      }
      skill.level = level;
    } else if (level && !levelEnabled) {
      return res.status(400).json({
        msg: "La dÃ©finition du niveau de compÃ©tence est actuellement dÃ©sactivÃ©e.",
      });
    }

    await candidate.save();
    res.json({ msg: "CompÃ©tence mise Ã  jour", skill });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const deleteCandidateSkill = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const skill = candidate.skills.id(skillId);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable." });
    }

    
    if (skill.officialSkillId) {
      await Skill.findByIdAndUpdate(skill.officialSkillId, {
        $inc: { usageCount: -1 },
      });
    }

    candidate.skills.pull(skillId);
    await candidate.save();

    res.json({ msg: "CompÃ©tence supprimÃ©e", skills: candidate.skills });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getSkillDetails = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const skill = candidate.skills.id(skillId);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable." });
    }

    const feedbackEnabled = await SystemSettings.getSetting(
      "skill_feedback_enabled",
      true,
    );

    let canSubmitFeedback = false;
    if (feedbackEnabled && skill.officialSkillId) {
      const maxPerSkill = await SystemSettings.getSetting(
        "skill_feedback_max_per_skill",
        1,
      );
      const activeFeedback = await SkillFeedback.countDocuments({
        candidateSkillId: skill._id,
        userId,
        status: "pending",
      });
      canSubmitFeedback = activeFeedback < maxPerSkill;
    }

    res.json({
      _id: skill._id,
      rawText: skill.rawText,
      level: skill.level,
      officialSkillName: skill.officialSkillName,
      domain: skill.domain,
      subDomain: skill.subDomain,
      matchType: skill.matchType,
      addedAt: skill.addedAt,
      mappingHistory: skill.mappingHistory,
      canSubmitFeedback,
      feedbackEnabled,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const submitSkillFeedback = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;
    const { category, comment } = req.body;

    const feedbackEnabled = await SystemSettings.getSetting(
      "skill_feedback_enabled",
      true,
    );
    if (!feedbackEnabled) {
      return res.status(400).json({
        msg: "Le systÃ¨me de feedback de compÃ©tences est actuellement dÃ©sactivÃ©.",
      });
    }

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const skill = candidate.skills.id(skillId);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable." });
    }

    if (!skill.officialSkillId) {
      return res.status(400).json({
        msg: "Aucun mapping officiel Ã  signaler pour cette compÃ©tence.",
      });
    }

    
    const maxPerWeek = await SystemSettings.getSetting(
      "skill_feedback_max_per_week",
      3,
    );
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    const weeklyCount = await SkillFeedback.countDocuments({
      userId,
      createdAt: { $gte: oneWeekAgo },
    });
    if (weeklyCount >= maxPerWeek) {
      return res.status(429).json({
        msg: `Vous avez atteint la limite de ${maxPerWeek} feedback(s) par semaine.`,
      });
    }

    
    const maxPerSkill = await SystemSettings.getSetting(
      "skill_feedback_max_per_skill",
      1,
    );
    const skillCount = await SkillFeedback.countDocuments({
      candidateSkillId: skill._id,
      userId,
      status: "pending",
    });
    if (skillCount >= maxPerSkill) {
      return res.status(400).json({
        msg: "Vous avez dÃ©jÃ  un feedback en attente pour cette compÃ©tence.",
      });
    }

    const validCategories = [
      "incorrect_mapping",
      "wrong_domain",
      "skill_merged_incorrectly",
      "other",
    ];
    if (!category || !validCategories.includes(category)) {
      return res.status(400).json({ msg: "CatÃ©gorie de feedback invalide." });
    }

    const feedback = await SkillFeedback.create({
      userId,
      candidateId: candidate._id,
      candidateSkillId: skill._id,
      rawSkillText: skill.rawText,
      mappedToSkillId: skill.officialSkillId,
      mappedToName: skill.officialSkillName,
      category,
      comment: comment?.substring(0, 500),
    });

    res.json({
      msg: "Feedback soumis. Merci pour votre contribution.",
      feedbackId: feedback._id,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};






export const createSkill = async (req, res) => {
  try {
    const { name, category, subCategory, description, aliases } = req.body;
    const normalizedName = name.trim().toLowerCase();

    const exist = await Skill.findOne({
      $or: [{ name: normalizedName }, { aliases: normalizedName }],
    });
    if (exist) {
      return res.status(400).json({
        msg: "Cette compÃ©tence existe dÃ©jÃ .",
        existingSkill: exist.name,
      });
    }

    const normalizedAliases = (aliases || [])
      .map((a) => a.trim().toLowerCase())
      .filter(Boolean);

    const newSkill = await Skill.create({
      name: normalizedName,
      category: category?.trim() || null,
      subCategory: subCategory?.trim() || null,
      description: description?.trim() || null,
      aliases: normalizedAliases,
    });

    await logAdminAction(
      req.user.id,
      "skill_created",
      { type: "skill", id: newSkill._id },
      { name: normalizedName, category },
      req,
    );

    res.status(201).json(newSkill);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateSkill = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, category, subCategory, description, aliases, isHidden } =
      req.body;

    const updates = {};
    if (name) updates.name = name.trim().toLowerCase();
    if (category !== undefined) updates.category = category?.trim() || null;
    if (subCategory !== undefined)
      updates.subCategory = subCategory?.trim() || null;
    if (description !== undefined)
      updates.description = description?.trim() || null;
    if (aliases)
      updates.aliases = aliases
        .map((a) => a.trim().toLowerCase())
        .filter(Boolean);
    if (isHidden !== undefined) updates.isHidden = isHidden;

    const skill = await Skill.findByIdAndUpdate(id, updates, { new: true });
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable" });
    }

    await logAdminAction(
      req.user.id,
      "skill_updated",
      { type: "skill", id: skill._id },
      { updates },
      req,
    );

    res.json({ msg: "CompÃ©tence mise Ã  jour", skill });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const deleteSkill = async (req, res) => {
  try {
    const skill = await Skill.findByIdAndDelete(req.params.id);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable" });
    }

    await logAdminAction(
      req.user.id,
      "skill_deleted",
      { type: "skill", id: req.params.id },
      { name: skill.name },
      req,
    );

    res.json({ msg: "CompÃ©tence supprimÃ©e" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getTrendingClusters = async (req, res) => {
  try {
    const { days = 30, limit = 20 } = req.query;

    const windowDays = await SystemSettings.getSetting(
      "skill_trending_window_days",
      parseInt(days),
    );

    const startDate = new Date();
    startDate.setDate(startDate.getDate() - windowDays);

    const clusters = await SkillCluster.find({
      status: "pending",
      isFlagged: false,
      createdAt: { $gte: startDate },
    })
      .sort({ totalUsageCount: -1 })
      .limit(parseInt(limit))
      .lean();

    
    const enriched = clusters.map((c) => {
      const daysSinceCreation = Math.max(
        1,
        (Date.now() - new Date(c.createdAt).getTime()) / (1000 * 60 * 60 * 24),
      );
      const growthRate = c.totalUsageCount / daysSinceCreation;

      return {
        ...c,
        growthRate: Math.round(growthRate * 100) / 100,
        variantCount: c.variants?.length || 0,
      };
    });

    enriched.sort((a, b) => b.growthRate - a.growthRate);

    res.json({ data: enriched, windowDays });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getDuplicateClusters = async (req, res) => {
  try {
    const { limit = 20 } = req.query;

    const clusters = await SkillCluster.find({
      status: "pending",
      "variants.1": { $exists: true }, 
    })
      .sort({ totalUsageCount: -1 })
      .limit(parseInt(limit))
      .lean();

    const enriched = clusters.map((c) => ({
      ...c,
      variantCount: c.variants?.length || 0,
      variants: c.variants?.sort((a, b) => b.usageCount - a.usageCount),
    }));

    res.json({ data: enriched });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getOrphanClusters = async (req, res) => {
  try {
    const { limit = 20, minUsage = 3 } = req.query;

    const clusters = await SkillCluster.find({
      status: "pending",
      promotedToSkillId: { $exists: false },
      isFlagged: false,
      totalUsageCount: { $gte: parseInt(minUsage) },
    })
      .sort({ totalUsageCount: -1 })
      .limit(parseInt(limit))
      .lean();

    res.json({ data: clusters });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getFlaggedClusters = async (req, res) => {
  try {
    const { limit = 20 } = req.query;

    const clusters = await SkillCluster.find({
      isFlagged: true,
    })
      .sort({ flagCount: -1, createdAt: -1 })
      .limit(parseInt(limit))
      .lean();

    res.json({ data: clusters });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getClusterDetail = async (req, res) => {
  try {
    const { clusterId } = req.params;

    const cluster = await SkillCluster.findById(clusterId)
      .populate("promotedToSkillId", "name category")
      .populate("promotedBy", "nom")
      .populate("dismissedBy", "nom");

    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    
    const threshold = await SystemSettings.getSetting(
      "skill_suggestion_threshold",
      0.6,
    );

    const matchResult = await findBestMatch(cluster.canonicalName, threshold);

    
    const variantTexts = cluster.variants.map((v) => v.text);
    const candidateCount = await Candidate.countDocuments({
      "skills.normalizedText": { $in: variantTexts },
    });

    res.json({
      cluster,
      systemSuggestion: matchResult.match
        ? {
            name: matchResult.match.name,
            category: matchResult.match.category,
            confidence: matchResult.confidence,
          }
        : null,
      candidateCount,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const promoteCluster = async (req, res) => {
  try {
    const { clusterId } = req.params;
    const { name, domain, subDomain, description, aliasVariantTexts } =
      req.body;

    if (!name || !domain) {
      return res.status(400).json({ msg: "Nom et domaine sont obligatoires." });
    }

    const cluster = await SkillCluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    if (cluster.status === "promoted") {
      return res.status(400).json({ msg: "Ce cluster a dÃ©jÃ  Ã©tÃ© promu." });
    }

    const normalizedName = name.trim().toLowerCase();

    
    let officialSkill = await Skill.findOne({ name: normalizedName });

    const selectedAliases = (aliasVariantTexts || [])
      .map((a) => a.trim().toLowerCase())
      .filter((a) => a !== normalizedName);

    
    const allVariantTexts = cluster.variants
      .map((v) => v.text)
      .filter((t) => t !== normalizedName);

    const combinedAliases = [
      ...new Set([...selectedAliases, ...allVariantTexts]),
    ];

    if (officialSkill) {
      
      const existingAliases = new Set(officialSkill.aliases || []);
      combinedAliases.forEach((a) => existingAliases.add(a));
      officialSkill.aliases = [...existingAliases];
      if (!officialSkill.category && domain)
        officialSkill.category = domain.trim();
      if (!officialSkill.subCategory && subDomain)
        officialSkill.subCategory = subDomain.trim();
      officialSkill.isPromoted = true;
      officialSkill.promotedFrom = cluster._id;
      await officialSkill.save();
    } else {
      officialSkill = await Skill.create({
        name: normalizedName,
        category: domain.trim(),
        subCategory: subDomain?.trim() || null,
        description: description?.trim() || null,
        aliases: combinedAliases,
        isPromoted: true,
        promotedFrom: cluster._id,
      });
    }

    
    cluster.status = "promoted";
    cluster.promotedToSkillId = officialSkill._id;
    cluster.promotedAt = new Date();
    cluster.promotedBy = req.user.id;
    await cluster.save();

    
    const autoMigrate = await SystemSettings.getSetting(
      "skill_auto_migration_enabled",
      true,
    );

    let migratedCount = 0;

    if (autoMigrate) {
      const variantTexts = cluster.variants.map((v) => v.text);
      
      const allTexts = [...new Set([...variantTexts, normalizedName])];

      
      const candidatesToUpdate = await Candidate.find({
        "skills.normalizedText": { $in: allTexts },
        "skills.matchType": { $in: ["unmatched", "fuzzy"] },
      });

      for (const candidate of candidatesToUpdate) {
        let changed = false;
        for (const skill of candidate.skills) {
          if (
            allTexts.includes(skill.normalizedText) &&
            ["unmatched", "fuzzy"].includes(skill.matchType)
          ) {
            
            skill.mappingHistory.push({
              previousOfficialId: skill.officialSkillId,
              previousOfficialName: skill.officialSkillName,
              newOfficialId: officialSkill._id,
              newOfficialName: officialSkill.name,
              reason: "cluster_promotion",
              migratedAt: new Date(),
            });

            skill.officialSkillId = officialSkill._id;
            skill.officialSkillName = officialSkill.name;
            skill.domain = officialSkill.category;
            skill.subDomain = officialSkill.subCategory;
            skill.matchType = "promoted";
            
            changed = true;
          }
        }
        if (changed) {
          await candidate.save();
          migratedCount++;
        }
      }

      
      officialSkill.usageCount =
        (officialSkill.usageCount || 0) + cluster.totalUsageCount;
      await officialSkill.save();
    }

    await logAdminAction(
      req.user.id,
      "skill_cluster_promoted",
      { type: "skill_cluster", id: cluster._id },
      {
        officialSkillId: officialSkill._id,
        name: normalizedName,
        domain,
        aliasCount: combinedAliases.length,
        migratedCandidates: migratedCount,
      },
      req,
    );

    res.json({
      msg: "CompÃ©tence promue avec succÃ¨s",
      skill: officialSkill,
      migratedCandidates: migratedCount,
      aliasesAdded: combinedAliases.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const dismissCluster = async (req, res) => {
  try {
    const { clusterId } = req.params;
    const { reason } = req.body;

    const cluster = await SkillCluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    cluster.status = "dismissed";
    cluster.dismissedAt = new Date();
    cluster.dismissedBy = req.user.id;
    cluster.dismissReason = reason;
    await cluster.save();

    await logAdminAction(
      req.user.id,
      "skill_cluster_dismissed",
      { type: "skill_cluster", id: cluster._id },
      { reason },
      req,
    );

    res.json({ msg: "Cluster rejetÃ©" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const flagCluster = async (req, res) => {
  try {
    const { clusterId } = req.params;
    const { reason } = req.body;

    const cluster = await SkillCluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    cluster.isFlagged = true;
    cluster.flagCount += 1;
    cluster.flagReasons.push({
      reason: reason || "admin_flagged",
      flaggedBy: "admin",
      flaggedAt: new Date(),
    });
    await cluster.save();

    
    const maxFlags = await SystemSettings.getSetting(
      "skill_abuse_max_flags_before_hide",
      3,
    );

    if (cluster.flagCount >= maxFlags) {
      const variantTexts = cluster.variants.map((v) => v.text);
      await Candidate.updateMany(
        { "skills.normalizedText": { $in: variantTexts } },
        { $set: { "skills.$[elem].isVisibleToRecruiters": false } },
        { arrayFilters: [{ "elem.normalizedText": { $in: variantTexts } }] },
      );
    }

    res.json({ msg: "Cluster signalÃ©", flagCount: cluster.flagCount });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const unflagCluster = async (req, res) => {
  try {
    const { clusterId } = req.params;

    const cluster = await SkillCluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    cluster.isFlagged = false;
    cluster.status = "pending";
    await cluster.save();

    
    const variantTexts = cluster.variants.map((v) => v.text);
    await Candidate.updateMany(
      {
        "skills.normalizedText": { $in: variantTexts },
        "skills.flagReason": "auto_detected_abuse",
      },
      {
        $set: {
          "skills.$[elem].isVisibleToRecruiters": true,
          "skills.$[elem].isFlagged": false,
          "skills.$[elem].flagReason": null,
        },
      },
      {
        arrayFilters: [
          {
            "elem.normalizedText": { $in: variantTexts },
            "elem.flagReason": "auto_detected_abuse",
          },
        ],
      },
    );

    res.json({ msg: "Cluster dÃ©bloquÃ©" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getSkillFeedback = async (req, res) => {
  try {
    const { status = "pending", page = 1, limit = 20 } = req.query;

    let query = {};
    if (status !== "all") query.status = status;

    const [feedbacks, total] = await Promise.all([
      SkillFeedback.find(query)
        .sort({ createdAt: -1 })
        .skip((page - 1) * limit)
        .limit(parseInt(limit))
        .populate("userId", "nom email")
        .populate("mappedToSkillId", "name category")
        .populate("reviewedBy", "nom")
        .lean(),
      SkillFeedback.countDocuments(query),
    ]);

    res.json({
      data: feedbacks,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const reviewSkillFeedback = async (req, res) => {
  try {
    const { feedbackId } = req.params;
    const { action, note } = req.body;

    const validActions = [
      "mapping_adjusted",
      "mapping_removed",
      "no_change",
      "user_flagged",
    ];
    if (!action || !validActions.includes(action)) {
      return res.status(400).json({ msg: "Action invalide." });
    }

    const feedback = await SkillFeedback.findById(feedbackId);
    if (!feedback) {
      return res.status(404).json({ msg: "Feedback introuvable" });
    }

    feedback.status = action === "no_change" ? "rejected" : "accepted";
    feedback.reviewedBy = req.user.id;
    feedback.reviewedAt = new Date();
    feedback.reviewNote = note;
    feedback.actionTaken = action;
    await feedback.save();

    
    if (action === "mapping_removed") {
      const candidate = await Candidate.findById(feedback.candidateId);
      if (candidate) {
        const skill = candidate.skills.id(feedback.candidateSkillId);
        if (skill) {
          skill.mappingHistory.push({
            previousOfficialId: skill.officialSkillId,
            previousOfficialName: skill.officialSkillName,
            newOfficialId: null,
            newOfficialName: null,
            reason: "feedback_accepted",
            migratedAt: new Date(),
          });
          skill.officialSkillId = null;
          skill.officialSkillName = null;
          skill.domain = null;
          skill.subDomain = null;
          skill.matchType = "unmatched";
          await candidate.save();
        }
      }
    }

    
    if (action === "user_flagged") {
      await Candidate.findByIdAndUpdate(feedback.candidateId, {
        $inc: { skillTrustScore: -10 },
      });
    }

    await logAdminAction(
      req.user.id,
      "skill_feedback_reviewed",
      { type: "skill_feedback", id: feedback._id },
      { action, note },
      req,
    );

    res.json({ msg: "Feedback traitÃ©", feedback });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getSkillSystemStats = async (req, res) => {
  try {
    const [
      totalOfficialSkills,
      totalClusters,
      pendingClusters,
      flaggedClusters,
      promotedClusters,
      pendingFeedback,
      totalFeedback,
      topSkills,
      recentClusters,
      categoryDistribution,
    ] = await Promise.all([
      Skill.countDocuments({ isHidden: { $ne: true } }),
      SkillCluster.countDocuments(),
      SkillCluster.countDocuments({ status: "pending", isFlagged: false }),
      SkillCluster.countDocuments({ isFlagged: true }),
      SkillCluster.countDocuments({ status: "promoted" }),
      SkillFeedback.countDocuments({ status: "pending" }),
      SkillFeedback.countDocuments(),
      Skill.find({ isHidden: { $ne: true } })
        .sort({ usageCount: -1 })
        .limit(10)
        .select("name category usageCount")
        .lean(),
      SkillCluster.find({ status: "pending" })
        .sort({ createdAt: -1 })
        .limit(5)
        .select("canonicalName totalUsageCount createdAt")
        .lean(),
      Skill.aggregate([
        {
          $match: {
            isHidden: { $ne: true },
            category: { $exists: true, $ne: null },
          },
        },
        { $group: { _id: "$category", count: { $sum: 1 } } },
        { $sort: { count: -1 } },
      ]),
    ]);

    res.json({
      officialSkills: totalOfficialSkills,
      clusters: {
        total: totalClusters,
        pending: pendingClusters,
        flagged: flaggedClusters,
        promoted: promotedClusters,
      },
      feedback: {
        pending: pendingFeedback,
        total: totalFeedback,
      },
      topSkills,
      recentClusters,
      categoryDistribution,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getSkillSettings = async (req, res) => {
  try {
    const settings = await SystemSettings.getSettingsByCategory("skills");
    res.json(settings);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateSkillSettings = async (req, res) => {
  try {
    const { settings } = req.body;

    if (!settings || typeof settings !== "object") {
      return res.status(400).json({ msg: "Settings object requis." });
    }

    const validSkillKeys = [
      "skill_system_enabled",
      "max_skills_per_candidate",
      "skill_proposal_enabled",
      "skill_suggestions_enabled",
      "skill_suggestion_threshold",
      "skill_level_enabled",
      "skill_feedback_enabled",
      "skill_feedback_max_per_week",
      "skill_feedback_max_per_skill",
      "skill_abuse_detection_enabled",
      "skill_abuse_max_flags_before_hide",
      "skill_auto_migration_enabled",
      "skill_recruiter_search_expand_aliases",
      "skill_trending_window_days",
    ];

    const updates = {};
    for (const [key, value] of Object.entries(settings)) {
      if (!validSkillKeys.includes(key)) {
        return res.status(400).json({ msg: `ClÃ© invalide: ${key}` });
      }
      updates[key] = value;
    }

    for (const [key, value] of Object.entries(updates)) {
      await SystemSettings.setSetting(key, value, null, req.user.id);
    }

    await logAdminAction(
      req.user.id,
      "skill_settings_updated",
      { type: "system_settings" },
      { updates },
      req,
    );

    const updatedSettings =
      await SystemSettings.getSettingsByCategory("skills");

    res.json({
      msg: "ParamÃ¨tres des compÃ©tences mis Ã  jour",
      settings: updatedSettings,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export default {
  
  getSkills,
  getSkillProposalStatus,
  suggestSkills,
  
  addSkillToCandidate,
  updateCandidateSkill,
  deleteCandidateSkill,
  getSkillDetails,
  submitSkillFeedback,
  
  createSkill,
  updateSkill,
  deleteSkill,
  
  getTrendingClusters,
  getDuplicateClusters,
  getOrphanClusters,
  getFlaggedClusters,
  getClusterDetail,
  promoteCluster,
  dismissCluster,
  flagCluster,
  unflagCluster,
  
  getSkillFeedback,
  reviewSkillFeedback,
  
  getSkillSystemStats,
  getSkillSettings,
  updateSkillSettings,
};


=== middleware\adminPermissions.js ===
import Admin from "../models/Admin.js";

export const requireAdminPermission = (permission) => {
  return async (req, res, next) => {
    try {
      const admin = await Admin.findOne({ userId: req.user.id });

      if (!admin) {
        return res.status(403).json({ msg: "AccÃ¨s administrateur requis." });
      }

      if (admin.status !== "active") {
        return res
          .status(403)
          .json({ msg: "Votre compte administrateur est suspendu." });
      }

      if (!admin.hasPermission(permission)) {
        return res.status(403).json({
          msg: `Permission "${permission}" requise.`,
          code: "PERMISSION_DENIED",
        });
      }

      req.admin = admin;
      next();
    } catch (err) {
      res.status(500).json({ msg: err.message });
    }
  };
};

export const requireActiveAdmin = async (req, res, next) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin || admin.status !== "active") {
      return res
        .status(403)
        .json({ msg: "AccÃ¨s administrateur actif requis." });
    }

    req.admin = admin;
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== middleware\auth.js ===
import jwt from "jsonwebtoken";

export default function auth(req, res, next) {
  const token = req.header("Authorization");
  if (!token) return res.status(401).json({ msg: "Pas de token fourni" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch {
    res.status(401).json({ msg: "Token invalide" });
  }
}


=== middleware\optionalAuth.js ===
import jwt from "jsonwebtoken";

export const optionalAuth = (req, res, next) => {
  const token = req.header("Authorization");

  if (!token) {
    req.user = null;
    return next();
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
  } catch (err) {
    req.user = null;
  }
  next();
};


=== middleware\roles.js ===
export const authRole = (roles = []) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ msg: "AccÃ¨s refusÃ© : rÃ´le non autorisÃ©" });
    }
    next();
  };
};


=== middleware\validate.js ===
import { validationResult, body, param, query } from "express-validator";


export const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      msg: "DonnÃ©es invalides",
      errors: errors.array().map((e) => ({ field: e.path, message: e.msg })),
    });
  }
  next();
};


export const validators = {
  
  register: [
    body("nom")
      .trim()
      .notEmpty()
      .withMessage("Le nom est requis")
      .isLength({ max: 100 }),
    body("email")
      .trim()
      .isEmail()
      .withMessage("Email invalide")
      .normalizeEmail(),
    body("motDePasse")
      .isLength({ min: 8 })
      .withMessage("Le mot de passe doit contenir au moins 8 caractÃ¨res")
      .matches(/[a-z]/)
      .withMessage("Le mot de passe doit contenir une minuscule")
      .matches(/[A-Z]/)
      .withMessage("Le mot de passe doit contenir une majuscule")
      .matches(/\d/)
      .withMessage("Le mot de passe doit contenir un chiffre"),
    body("role").isIn(["candidat", "recruteur"]).withMessage("RÃ´le invalide"),
    handleValidationErrors,
  ],

  login: [
    body("email")
      .trim()
      .isEmail()
      .withMessage("Email invalide")
      .normalizeEmail(),
    body("motDePasse").notEmpty().withMessage("Mot de passe requis"),
    handleValidationErrors,
  ],

  verifyEmail: [
    body("code")
      .trim()
      .notEmpty()
      .withMessage("Code requis")
      .isLength({ min: 6, max: 6 }),
    handleValidationErrors,
  ],

  changeEmail: [
    body("newEmail")
      .trim()
      .isEmail()
      .withMessage("Email invalide")
      .normalizeEmail(),
    handleValidationErrors,
  ],

  
  updateProfile: [
    body("telephone")
      .optional()
      .trim()
      .matches(/^[0-9+\s-]{8,20}$/)
      .withMessage("TÃ©lÃ©phone invalide"),
    body("bio")
      .optional()
      .trim()
      .isLength({ max: 1000 })
      .withMessage("Bio trop longue (max 1000)"),
    body("dateOfBirth").optional().isISO8601().withMessage("Date invalide"),
    body("gender")
      .optional()
      .isIn(["homme", "femme"])
      .withMessage("Genre invalide"),
    handleValidationErrors,
  ],

  applyToOffer: [
    body("offreId").isMongoId().withMessage("ID offre invalide"),
    body("cvUrl").notEmpty().withMessage("CV requis"),
    body("coverLetter")
      .optional()
      .trim()
      .isLength({ max: 5000 })
      .withMessage("Lettre trop longue"),
    handleValidationErrors,
  ],

  addSkill: [
    body("name")
      .trim()
      .notEmpty()
      .withMessage("Nom requis")
      .isLength({ max: 100 }),
    body("level").optional().isIn(["beginner", "intermediate", "expert"]),
    handleValidationErrors,
  ],
  addSkillV2: [
    body("name")
      .trim()
      .notEmpty()
      .withMessage("Nom requis")
      .isLength({ min: 1, max: 100 })
      .withMessage("Le nom doit faire entre 1 et 100 caractÃ¨res"),
    body("level")
      .optional()
      .isIn(["beginner", "intermediate", "expert", "unset"])
      .withMessage("Niveau invalide"),
    body("selectedSuggestionId")
      .optional()
      .isMongoId()
      .withMessage("ID suggestion invalide"),
    handleValidationErrors,
  ],

  skillFeedback: [
    body("category")
      .isIn([
        "incorrect_mapping",
        "wrong_domain",
        "skill_merged_incorrectly",
        "other",
      ])
      .withMessage("CatÃ©gorie invalide"),
    body("comment")
      .optional()
      .trim()
      .isLength({ max: 500 })
      .withMessage("Commentaire trop long (max 500)"),
    handleValidationErrors,
  ],

  addExperience: [
    body("jobTitle")
      .trim()
      .notEmpty()
      .withMessage("Titre requis")
      .isLength({ max: 200 }),
    body("company")
      .trim()
      .notEmpty()
      .withMessage("Entreprise requise")
      .isLength({ max: 200 }),
    body("startDate").optional().isISO8601().withMessage("Date invalide"),
    body("endDate").optional().isISO8601().withMessage("Date invalide"),
    handleValidationErrors,
  ],

  addEducation: [
    body("institut")
      .trim()
      .notEmpty()
      .withMessage("Institut requis")
      .isLength({ max: 200 }),
    body("degree")
      .trim()
      .notEmpty()
      .withMessage("DiplÃ´me requis")
      .isLength({ max: 200 }),
    body("startDate").optional().isISO8601().withMessage("Date invalide"),
    handleValidationErrors,
  ],

  
  createTicket: [
    body("subject")
      .trim()
      .notEmpty()
      .withMessage("Sujet requis")
      .isLength({ max: 200 }),
    body("description")
      .trim()
      .notEmpty()
      .withMessage("Description requise")
      .isLength({ max: 5000 }),
    body("category")
      .isIn([
        "support_understanding",
        "technical_issue",
        "account_profile",
        "company_recruitment",
        "documents_verification",
        "special_request",
        "feedback_suggestion",
      ])
      .withMessage("CatÃ©gorie invalide"),
    handleValidationErrors,
  ],

  replyToTicket: [
    body("content")
      .trim()
      .notEmpty()
      .withMessage("Contenu requis")
      .isLength({ max: 5000 }),
    handleValidationErrors,
  ],

  
  mongoId: (paramName = "id") => [
    param(paramName).isMongoId().withMessage("ID invalide"),
    handleValidationErrors,
  ],

  
  pagination: [
    query("page").optional().isInt({ min: 1 }).toInt(),
    query("limit").optional().isInt({ min: 1, max: 100 }).toInt(),
    handleValidationErrors,
  ],
  forgotPassword: [
    body("email")
      .trim()
      .isEmail()
      .withMessage("Adresse email invalide")
      .normalizeEmail(),
    handleValidationErrors,
  ],

  verifyResetCode: [
    body("email")
      .trim()
      .isEmail()
      .withMessage("Adresse email invalide")
      .normalizeEmail(),
    body("code")
      .trim()
      .notEmpty()
      .withMessage("Code requis")
      .isLength({ min: 6, max: 6 })
      .withMessage("Le code doit contenir 6 chiffres"),
    handleValidationErrors,
  ],

  resetPassword: [
    body("resetToken")
      .trim()
      .notEmpty()
      .withMessage("Token de rÃ©initialisation requis"),
    body("newPassword")
      .isLength({ min: 8 })
      .withMessage("Le mot de passe doit contenir au moins 8 caractÃ¨res")
      .matches(/[a-z]/)
      .withMessage("Le mot de passe doit contenir une minuscule")
      .matches(/[A-Z]/)
      .withMessage("Le mot de passe doit contenir une majuscule")
      .matches(/\d/)
      .withMessage("Le mot de passe doit contenir un chiffre"),
    body("confirmPassword")
      .optional()
      .custom((value, { req }) => {
        if (value !== req.body.newPassword) {
          throw new Error("Les mots de passe ne correspondent pas");
        }
        return true;
      }),
    handleValidationErrors,
  ],
};

export default validators;


=== models\Admin.js ===
import mongoose from "mongoose";

const adminSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true,
    },

    label: {
      type: String,
      enum: [
        "super_admin",
        "support",
        "technical",
        "operational",
        "recruitment",
        "moderation",
        "product",
      ],
      default: "support",
    },

    permissions: {
      createAdmin: { type: Boolean, default: false },
      deleteAdmin: { type: Boolean, default: false },
      editAdminPermissions: { type: Boolean, default: false },
      assignAdminLabels: { type: Boolean, default: false },

      validateOffers: { type: Boolean, default: false },
      validateRecruiters: { type: Boolean, default: false },
      validateCompanies: { type: Boolean, default: false },

      banUsers: { type: Boolean, default: false },
      suspendUsers: { type: Boolean, default: false },

      proposeCandidates: { type: Boolean, default: false },

      manageAnnouncements: { type: Boolean, default: false },
      sendNotifications: { type: Boolean, default: false },

      handleSupportTickets: { type: Boolean, default: false },

      viewStats: { type: Boolean, default: true },
      viewLogs: { type: Boolean, default: false },
    },

    status: {
      type: String,
      enum: ["active", "suspended", "revoked"],
      default: "active",
    },
    suspensionReason: String,
    suspendedUntil: Date,

    createdBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
  },
  { timestamps: true }
);

adminSchema.methods.hasPermission = function (permission) {
  if (this.label === "super_admin") return true;
  return this.permissions[permission] === true;
};

export default mongoose.model("Admin", adminSchema);


=== models\AdminLog.js ===
import mongoose from "mongoose";

const adminLogSchema = new mongoose.Schema(
  {
    adminId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    action: {
      type: String,
      enum: [
        "admin_created",
        "admin_deleted",
        "admin_suspended",
        "admin_reactivated",
        "admin_permissions_updated",
        "admin_label_changed",
        "recruiter_validated",
        "recruiter_rejected",
        "recruiter_suspended",
        "recruiter_documents_requested",
        "recruiter_revalidated",
        "recruiter_request_canceled",
        "recruiter_multiple_requests",
        "company_validated",
        "company_rejected",
        "company_suspended",
        "company_created_by_admin",
        "company_updated_by_admin",
        "company_admin_assigned",
        "company_admin_removed",
        "offer_approved",
        "offer_rejected",
        "offer_changes_requested",
        "offer_deleted",
        "offer_updated_by_admin",
        "offer_activated_admin",
        "offer_deactivated_admin",
        "user_banned",
        "user_unbanned",
        "user_message_sent",
        "candidate_proposed",
        "announcement_created",
        "announcement_updated",
        "announcement_deleted",
        "ticket_responded",
        "ticket_closed",
        "ticket_reassigned",
        "anem_demande_viewed",
        "anem_demande_assigned",
        "anem_demande_in_progress",
        "anem_pdf_downloaded",
        "anem_id_approved",
        "anem_id_rejected",
        "anem_registration_success",
        "anem_registration_failed",
        "anem_bulk_status_update",
        "anem_note_added",
        
        "skill_created",
        "skill_updated",
        "skill_deleted",
        "skill_cluster_promoted",
        "skill_cluster_dismissed",
        "skill_feedback_reviewed",
        "skill_settings_updated",
      ],
      required: true,
      index: true,
    },
    targetType: {
      type: String,
      enum: [
        "user",
        "recruiter",
        "company",
        "offer",
        "application",
        "announcement",
        "ticket",
        "admin",
        "anem_registration",
        "skill",
        "skill_cluster",
        "skill_feedback",
        "system_settings",
      ],
    },
    targetId: { type: mongoose.Schema.Types.ObjectId },
    details: { type: mongoose.Schema.Types.Mixed },
    ip: { type: String },
    userAgent: { type: String },
  },
  { timestamps: true },
);

adminLogSchema.index({ createdAt: -1 });
adminLogSchema.index({ action: 1, createdAt: -1 });
adminLogSchema.index({ targetType: 1, targetId: 1 });

const AdminLog = mongoose.model("AdminLog", adminLogSchema);

export const logAdminAction = async (
  adminId,
  action,
  target = {},
  details = {},
  req = null,
) => {
  try {
    await AdminLog.create({
      adminId,
      action,
      targetType: target.type,
      targetId: target.id,
      details,
      ip: req?.ip || req?.connection?.remoteAddress,
      userAgent: req?.get?.("User-Agent") || req?.headers?.["user-agent"],
    });
  } catch (err) {
    console.error("Erreur lors du logging admin:", err);
  }
};

export default AdminLog;


=== models\Candidate.js ===
import mongoose from "mongoose";

const educationSchema = new mongoose.Schema({
  institut: { type: String, required: true },
  degree: { type: String, required: true },
  fieldOfStudy: { type: String },
  startDate: { type: Date },
  endDate: { type: Date },
  description: { type: String },
});

const experienceSchema = new mongoose.Schema({
  jobTitle: { type: String, required: true },
  company: { type: String, required: true },
  startDate: { type: Date },
  endDate: { type: Date },
  description: { type: String },
});

const skillSchema = new mongoose.Schema({
  rawText: {
    type: String,
    required: true,
    trim: true,
  },
  normalizedText: {
    type: String,
    required: true,
    trim: true,
    lowercase: true,
  },
  level: {
    type: String,
    enum: ["beginner", "intermediate", "expert", "unset"],
    default: "unset",
  },
  officialSkillId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Skill",
    default: null,
  },
  officialSkillName: {
    type: String,
    default: null,
  },
  domain: {
    type: String,
    default: null,
    trim: true,
  },
  subDomain: {
    type: String,
    default: null,
    trim: true,
  },
  clusterId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "SkillCluster",
    default: null,
  },
  matchType: {
    type: String,
    enum: ["exact", "alias", "promoted", "unmatched"],
    default: "unmatched",
  },
  isVisibleToRecruiters: {
    type: Boolean,
    default: true,
  },
  isFlagged: {
    type: Boolean,
    default: false,
  },
  flagReason: {
    type: String,
  },
  addedAt: {
    type: Date,
    default: Date.now,
  },
  mappingHistory: [
    {
      previousOfficialId: { type: mongoose.Schema.Types.ObjectId },
      previousOfficialName: { type: String },
      newOfficialId: { type: mongoose.Schema.Types.ObjectId },
      newOfficialName: { type: String },
      reason: { type: String },
      migratedAt: { type: Date, default: Date.now },
    },
  ],
});

const candidateSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true,
    },

    dateOfBirth: { type: Date },
    bio: { type: String, maxLength: 1000 },
    gender: {
      type: String,
      enum: ["homme", "femme"],
    },

    residence: {
      wilaya: { type: String },
      commune: { type: String },
      address: { type: String },
    },

    searchPreferences: {
      wilayas: [{ type: String }],
      remoteOnly: { type: Boolean, default: false },
      willingToRelocate: { type: Boolean, default: false },
    },

    desiredPosition: { type: String },

    desiredJobTypes: [
      {
        type: String,
        enum: [
          "full-time",
          "part-time",
          "remote",
          "internship",
          "freelance",
          "CDI",
          "CDD",
        ],
      },
    ],

    profilePicture: { type: String },
    telephone: { type: String },
    links: {
      website: { type: String },
      linkedin: { type: String },
      github: { type: String },
      portfolio: { type: String },
    },

    autoriserProposition: { type: Boolean, default: true },

    favoris: [
      {
        offerId: { type: mongoose.Schema.Types.ObjectId, ref: "Offer" },
        savedAt: { type: Date, default: Date.now },
      },
    ],

    cvs: [
      {
        url: { type: String, required: true },
        dateDepot: { type: Date, default: Date.now },
        score: { type: Number, default: 0 },
      },
    ],

    skills: [skillSchema],
    experiences: [experienceSchema],
    education: [educationSchema],

    skillTrustScore: {
      type: Number,
      default: 100,
      min: 0,
      max: 100,
    },
  },
  { timestamps: true },
);

candidateSchema.index({ userId: 1 });
candidateSchema.index({ "residence.wilaya": 1 });
candidateSchema.index({ autoriserProposition: 1 });
candidateSchema.index({ "skills.officialSkillId": 1 });
candidateSchema.index({ "skills.normalizedText": 1 });
candidateSchema.index({ "skills.isVisibleToRecruiters": 1 });
candidateSchema.index({ "skills.domain": 1 });

export default mongoose.model("Candidate", candidateSchema);


=== models\Notification.js ===
import mongoose from "mongoose";

const notificationSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    message: { type: String, required: true },
    type: {
      type: String,
      enum: ["info", "alerte", "validation"],
      default: "info",
    },
    lu: { type: Boolean, default: false },
    date: { type: Date, default: Date.now },
  },
  { timestamps: true }
);

notificationSchema.index({ userId: 1, lu: 1 });
notificationSchema.index({ userId: 1, date: -1 });

export default mongoose.model("Notification", notificationSchema);


=== models\Offer.js ===
import mongoose from "mongoose";

const offerSchema = new mongoose.Schema(
  {
    recruteurId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Recruiter",
      required: true,
    },
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
    },

    titre: { type: String, required: true },
    description: { type: String, required: true },
    requirements: { type: String, required: true },

    domaine: { type: String },
    type: {
      type: String,
      enum: [
        "full-time",
        "part-time",
        "remote",
        "internship",
        "freelance",
        "CDI",
        "CDD",
      ],
      default: "full-time",
    },
    salaryMin: { type: Number },
    salaryMax: { type: Number },
    experienceLevel: { type: String, enum: ["junior", "mid", "senior"] },
    skills: [{ type: String, index: true }],
    wilaya: { type: String },

    
    isAnem: { type: Boolean, default: false },
    

    allowRepostulation: { type: Boolean, default: true },

    validationStatus: {
      type: String,
      enum: ["draft", "pending", "approved", "rejected", "changes_requested"],
      default: "pending",
    },
    validationHistory: [
      {
        status: String,
        message: String,
        adminId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        date: { type: Date, default: Date.now },
      },
    ],
    rejectionReason: String,

    visibility: {
      isPublic: { type: Boolean, default: true },
      acceptsDirectApplications: { type: Boolean, default: true },
    },

    candidateSearchMode: {
      type: String,
      enum: ["disabled", "manual", "automatic"],
      default: "disabled",
    },

    actif: { type: Boolean, default: false },
    datePublication: { type: Date },
    nombreCandidatures: { type: Number, default: 0 },
  },
  { timestamps: true },
);

offerSchema.methods.isVisible = function () {
  return this.validationStatus === "approved" && this.actif;
};

offerSchema.index({ titre: "text", description: "text", skills: "text" });

export default mongoose.model("Offer", offerSchema);


=== models\ProposedSkill.js ===
import mongoose from "mongoose";

const proposedSkillSchema = new mongoose.Schema(
  {
    label: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
      index: true,
    },
    domain: {
      type: String,
      default: null,
      trim: true,
    },
    status: {
      type: String,
      enum: ["pending", "approved", "rejected", "merged"],
      default: "pending",
      index: true,
    },
    proposedBy: [
      {
        userId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        candidateId: { type: mongoose.Schema.Types.ObjectId, ref: "Candidate" },
        proposedAt: { type: Date, default: Date.now },
      },
    ],
    proposalCount: {
      type: Number,
      default: 1,
    },
    
    approvedSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Skill",
    },
    
    reviewedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    reviewedAt: Date,
    reviewNote: String,
    
    mergedInto: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "ProposedSkill",
    },
  },
  { timestamps: true },
);


proposedSkillSchema.index({ label: 1 }, { unique: true });
proposedSkillSchema.index({ status: 1, proposalCount: -1 });


proposedSkillSchema.statics.proposeSkill = async function (
  label,
  userId,
  candidateId,
) {
  const normalizedLabel = label.trim().toLowerCase();

  
  let proposedSkill = await this.findOne({ label: normalizedLabel });

  if (proposedSkill) {
    
    const alreadyProposed = proposedSkill.proposedBy.some(
      (p) => p.userId?.toString() === userId,
    );

    if (!alreadyProposed) {
      proposedSkill.proposedBy.push({
        userId,
        candidateId,
        proposedAt: new Date(),
      });
      proposedSkill.proposalCount += 1;
      await proposedSkill.save();
    }

    return { proposedSkill, isNew: false };
  }

  
  proposedSkill = await this.create({
    label: normalizedLabel,
    proposedBy: [{ userId, candidateId, proposedAt: new Date() }],
  });

  return { proposedSkill, isNew: true };
};

export default mongoose.model("ProposedSkill", proposedSkillSchema);


=== models\SkillCluster.js ===
import mongoose from "mongoose";

const skillClusterSchema = new mongoose.Schema(
  {
    canonicalName: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
      unique: true,
    },
    variants: [
      {
        text: { type: String, required: true, trim: true, lowercase: true },
        usageCount: { type: Number, default: 1 },
        firstSeenAt: { type: Date, default: Date.now },
        lastSeenAt: { type: Date, default: Date.now },
      },
    ],
    suggestedDomain: { type: String, trim: true },
    suggestedSubDomain: { type: String, trim: true },
    suggestedCanonicalName: { type: String, trim: true },
    confidenceScore: { type: Number, default: 0, min: 0, max: 1 },
    totalUsageCount: { type: Number, default: 0 },
    status: {
      type: String,
      enum: ["pending", "promoted", "dismissed", "flagged"],
      default: "pending",
    },
    promotedToSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Skill",
    },
    promotedAt: { type: Date },
    promotedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
    dismissedAt: { type: Date },
    dismissedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
    dismissReason: { type: String },
    flagCount: { type: Number, default: 0 },
    isFlagged: { type: Boolean, default: false },
    flagReasons: [
      {
        reason: String,
        flaggedBy: { type: String, enum: ["system", "user", "admin"] },
        flaggedAt: { type: Date, default: Date.now },
      },
    ],
  },
  { timestamps: true },
);

skillClusterSchema.index({ status: 1, totalUsageCount: -1 });
skillClusterSchema.index({ canonicalName: 1 });
skillClusterSchema.index({ "variants.text": 1 });
skillClusterSchema.index({ isFlagged: 1, flagCount: -1 });
skillClusterSchema.index({ createdAt: -1 });
skillClusterSchema.index({ totalUsageCount: -1 });

skillClusterSchema.statics.trackVariant = async function (rawText) {
  const normalized = rawText.trim().toLowerCase();

  let cluster = await this.findOne({ "variants.text": normalized });

  if (cluster) {
    const variant = cluster.variants.find((v) => v.text === normalized);
    if (variant) {
      variant.usageCount += 1;
      variant.lastSeenAt = new Date();
    }
    cluster.totalUsageCount += 1;
    await cluster.save();
    return { cluster, isNew: false };
  }

  cluster = await this.findOne({ canonicalName: normalized });

  if (cluster) {
    cluster.variants.push({
      text: normalized,
      usageCount: 1,
      firstSeenAt: new Date(),
      lastSeenAt: new Date(),
    });
    cluster.totalUsageCount += 1;
    await cluster.save();
    return { cluster, isNew: false };
  }

  cluster = await this.create({
    canonicalName: normalized,
    variants: [
      {
        text: normalized,
        usageCount: 1,
        firstSeenAt: new Date(),
        lastSeenAt: new Date(),
      },
    ],
    totalUsageCount: 1,
  });

  return { cluster, isNew: true };
};

const SkillCluster = mongoose.model("SkillCluster", skillClusterSchema);

export default SkillCluster;


=== models\SkillFeedback.js ===
import mongoose from "mongoose";

const skillFeedbackSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    candidateId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Candidate",
      required: true,
    },
    candidateSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
    },
    rawSkillText: {
      type: String,
      required: true,
      trim: true,
    },
    mappedToSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Skill",
    },
    mappedToName: {
      type: String,
      trim: true,
    },
    category: {
      type: String,
      enum: [
        "incorrect_mapping",
        "wrong_domain",
        "skill_merged_incorrectly",
        "other",
      ],
      required: true,
    },
    comment: {
      type: String,
      maxLength: 500,
    },
    status: {
      type: String,
      enum: ["pending", "reviewed", "accepted", "rejected"],
      default: "pending",
    },
    reviewedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    reviewedAt: { type: Date },
    reviewNote: { type: String },
    actionTaken: {
      type: String,
      enum: [
        "mapping_adjusted",
        "mapping_removed",
        "no_change",
        "user_flagged",
      ],
    },
  },
  { timestamps: true },
);

skillFeedbackSchema.index({ userId: 1, createdAt: -1 });
skillFeedbackSchema.index({ candidateSkillId: 1, status: 1 });
skillFeedbackSchema.index({ status: 1, createdAt: -1 });
skillFeedbackSchema.index({ mappedToSkillId: 1 });

export default mongoose.model("SkillFeedback", skillFeedbackSchema);


=== models\Skills.js ===
import mongoose from "mongoose";

const skillSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
      index: true,
    },
    category: {
      type: String,
      trim: true,
      index: true,
    },
    subCategory: {
      type: String,
      trim: true,
    },
    description: {
      type: String,
      maxLength: 500,
    },
    aliases: [
      {
        type: String,
        trim: true,
        lowercase: true,
      },
    ],
    isPromoted: {
      type: Boolean,
      default: false,
    },
    promotedFrom: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SkillCluster",
    },
    wasProposed: {
      type: Boolean,
      default: false,
    },
    proposedSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "ProposedSkill",
    },
    usageCount: {
      type: Number,
      default: 0,
    },
    isHidden: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true },
);

skillSchema.index({ name: "text", aliases: "text", category: "text" });
skillSchema.index({ aliases: 1 });
skillSchema.index({ usageCount: -1 });
skillSchema.index({ isHidden: 1 });

skillSchema.statics.findByNameOrAlias = async function (query) {
  const normalized = query.trim().toLowerCase();
  return this.findOne({
    $or: [{ name: normalized }, { aliases: normalized }],
    isHidden: { $ne: true },
  });
};

skillSchema.statics.searchSimilar = async function (query, limit = 10) {
  const normalized = query.trim().toLowerCase();
  const escaped = normalized.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

  return this.find({
    $or: [
      { name: { $regex: escaped, $options: "i" } },
      { aliases: { $regex: escaped, $options: "i" } },
    ],
    isHidden: { $ne: true },
  })
    .sort({ usageCount: -1 })
    .limit(limit)
    .lean();
};

export default mongoose.model("Skill", skillSchema);


=== models\SystemSettings.js ===
import mongoose from "mongoose";

const systemSettingsSchema = new mongoose.Schema(
  {
    key: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },
    value: {
      type: mongoose.Schema.Types.Mixed,
      required: true,
    },
    description: {
      type: String,
    },
    category: {
      type: String,
      enum: [
        "general",
        "email",
        "skills",
        "candidates",
        "recruiters",
        "security",
      ],
      default: "general",
    },
    updatedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    updatedAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true },
);

systemSettingsSchema.statics.getSetting = async function (
  key,
  defaultValue = null,
) {
  const setting = await this.findOne({ key });
  return setting ? setting.value : defaultValue;
};

systemSettingsSchema.statics.setSetting = async function (
  key,
  value,
  description = null,
  updatedBy = null,
) {
  const update = { value, updatedAt: new Date() };
  if (description) update.description = description;
  if (updatedBy) update.updatedBy = updatedBy;

  return this.findOneAndUpdate(
    { key },
    { $set: update, $setOnInsert: { key } },
    { upsert: true, new: true },
  );
};

systemSettingsSchema.statics.getMultipleSettings = async function (keys) {
  const settings = await this.find({ key: { $in: keys } });
  const map = {};
  settings.forEach((s) => {
    map[s.key] = s.value;
  });
  return map;
};

systemSettingsSchema.statics.getSettingsByCategory = async function (category) {
  return this.find({ category }).select("-__v").lean();
};

systemSettingsSchema.statics.initializeDefaults = async function () {
  const defaults = [
    
    {
      key: "email_verification_mode",
      value: process.env.NODE_ENV === "production" ? "smtp" : "development",
      description:
        "Mode de vÃ©rification email: 'smtp' pour production, 'development' pour code statique 123456",
      category: "email",
    },
    {
      key: "verification_code_expiry_minutes",
      value: 15,
      description: "DurÃ©e de validitÃ© du code de vÃ©rification en minutes",
      category: "email",
    },

    
    {
      key: "max_cv_per_candidate",
      value: 3,
      description: "Nombre maximum de CV par candidat",
      category: "candidates",
    },

    
    {
      key: "skill_system_enabled",
      value: true,
      description: "Active ou dÃ©sactive tout le systÃ¨me de compÃ©tences",
      category: "skills",
    },
    {
      key: "max_skills_per_candidate",
      value: 6,
      description: "Nombre maximum de compÃ©tences par candidat",
      category: "skills",
    },
    {
      key: "skill_proposal_enabled",
      value: true,
      description:
        "Permet aux candidats d'ajouter des compÃ©tences en texte libre (non officielles)",
      category: "skills",
    },
    {
      key: "skill_suggestions_enabled",
      value: true,
      description:
        "Active les suggestions de compÃ©tences similaires lors de la saisie",
      category: "skills",
    },
    {
      key: "skill_suggestion_threshold",
      value: 0.6,
      description:
        "Seuil de confiance (0-1) pour afficher des suggestions de compÃ©tences similaires",
      category: "skills",
    },
    {
      key: "skill_level_enabled",
      value: true,
      description:
        "Permet aux candidats de dÃ©finir un niveau pour chaque compÃ©tence",
      category: "skills",
    },
    {
      key: "skill_feedback_enabled",
      value: true,
      description:
        "Permet aux candidats de signaler un mapping incorrect de compÃ©tence",
      category: "skills",
    },
    {
      key: "skill_feedback_max_per_week",
      value: 3,
      description:
        "Nombre maximum de feedbacks de compÃ©tences par candidat par semaine",
      category: "skills",
    },
    {
      key: "skill_feedback_max_per_skill",
      value: 1,
      description:
        "Nombre maximum de feedbacks actifs par compÃ©tence par candidat",
      category: "skills",
    },
    {
      key: "skill_abuse_detection_enabled",
      value: true,
      description:
        "Active la dÃ©tection automatique de compÃ©tences abusives/spam",
      category: "skills",
    },
    {
      key: "skill_abuse_max_flags_before_hide",
      value: 3,
      description:
        "Nombre de signalements avant de masquer une compÃ©tence des recruteurs",
      category: "skills",
    },
    {
      key: "skill_auto_migration_enabled",
      value: true,
      description:
        "Migration automatique des compÃ©tences utilisateur vers les officielles aprÃ¨s promotion",
      category: "skills",
    },
    {
      key: "skill_recruiter_search_expand_aliases",
      value: true,
      description:
        "La recherche recruteur inclut les alias et variantes historiques",
      category: "skills",
    },
    {
      key: "skill_trending_window_days",
      value: 30,
      description:
        "FenÃªtre en jours pour le calcul des compÃ©tences tendance (admin dashboard)",
      category: "skills",
    },
  ];

  for (const setting of defaults) {
    const exists = await this.findOne({ key: setting.key });
    if (!exists) {
      await this.create(setting);
    }
  }
};

export default mongoose.model("SystemSettings", systemSettingsSchema);


=== models\User.js ===
import mongoose from "mongoose";

const userSchema = new mongoose.Schema(
  {
    nom: { type: String },
    email: { type: String, required: true, unique: true },
    motDePasse: { type: String, required: true },
    role: {
      type: String,
      enum: ["candidat", "recruteur", "admin"],
      required: true,
    },

    emailVerified: {
      type: Boolean,
      default: false,
    },

    accountStatus: {
      type: String,
      enum: ["active", "suspended", "banned"],
      default: "active",
    },
    suspensionReason: String,
    suspendedUntil: Date,

    derniereConnexion: Date,
  },
  { timestamps: true },
);

userSchema.index({ email: 1 });
userSchema.index({ role: 1 });
userSchema.index({ createdAt: -1 });
userSchema.index({ accountStatus: 1 });

userSchema.methods.canLogin = function () {
  if (this.accountStatus === "banned") return false;
  if (this.accountStatus === "suspended") {
    if (this.suspendedUntil && new Date() > this.suspendedUntil) {
      return true;
    }
    return false;
  }
  return true;
};

export default mongoose.model("User", userSchema);


=== routes\adminRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { authRole } from "../middleware/roles.js";
import Admin from "../models/Admin.js";
import {
  getRecruiters,
  validateRecruiter,
  rejectRecruiter,
  requestRecruiterDocuments,
  requestMultipleValidationItems,
  cancelValidationRequest,
  getAllUsers,
  banUser,
  unBanUser,
  sendMessageToUser,
  getCandidateDetailsAdmin,
  createAdmin,
  deleteAdmin,
  getAllAdmins,
  suspendAdmin,
  updateAdminPermissions,
  updateAdminLabel,
  getPendingCompanies,
  validateCompany,
  rejectCompany,
  getCompanyDetailsAdmin,
  getAllCompanies,
  getPendingOffers,
  approveOffer,
  rejectOffer,
  deleteOfferAdmin,
  getManualSelectionOffers,
  proposeCandidateToOffer,
  toggleOfferVisibility,
  getGlobalStats,
  getTrends,
  getAdminLogs,
  createCompanyByAdmin,
  getCompanyRecruiters,
  assignCompanyAdmin,
  removeCompanyAdmin,
  updateCompanyByAdmin,
  getOfferDetailsAdmin,
  updateOfferByAdmin,
} from "../controllers/adminController.js";

import {
  getSkills,
  createSkill,
  updateSkill,
  deleteSkill,
  
  getTrendingClusters,
  getDuplicateClusters,
  getOrphanClusters,
  getFlaggedClusters,
  getClusterDetail,
  promoteCluster,
  dismissCluster,
  flagCluster,
  unflagCluster,
  
  getSkillFeedback,
  reviewSkillFeedback,
  
  getSkillSystemStats,
  getSkillSettings,
  updateSkillSettings,
} from "../controllers/skillController.js";

import {
  createAnnouncement,
  getAllAnnouncements,
  updateAnnouncement,
  deleteAnnouncement,
} from "../controllers/announcementController.js";

import {
  getTicketsByLabel,
  getTicketById,
  respondToTicket,
  reassignTicket,
  closeTicket,
} from "../controllers/adminSupportController.js";

import {
  toggleEmailVerificationMode,
  getEmailVerificationMode,
  toggleSkillProposal,
  getAllSettings,
  getSettingsByCategory,
  updateSettingsBulk,
} from "../controllers/adminSettingsController.js";

import { uploadAttachments } from "../config/multer.js";

const router = express.Router();

router.use(auth, authRole(["admin"]));

const requirePermission = (permission) => async (req, res, next) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin) {
      return res.status(403).json({ msg: "Admin introuvable" });
    }

    if (admin.status !== "active") {
      return res.status(403).json({ msg: "Compte admin suspendu" });
    }

    if (!admin.hasPermission(permission)) {
      return res.status(403).json({
        msg: `Permission "${permission}" requise`,
        code: "PERMISSION_DENIED",
      });
    }

    req.admin = admin;
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

router.get("/stats/global", requirePermission("viewStats"), getGlobalStats);
router.get("/stats/trends", requirePermission("viewStats"), getTrends);

router.get(
  "/recruteurs",
  requirePermission("validateRecruiters"),
  getRecruiters,
);
router.put(
  "/recruteurs/valider/:id",
  requirePermission("validateRecruiters"),
  validateRecruiter,
);
router.put(
  "/recruteurs/rejeter/:id",
  requirePermission("validateRecruiters"),
  rejectRecruiter,
);
router.post(
  "/recruteurs/:recruiterId/request-documents",
  requirePermission("validateRecruiters"),
  requestRecruiterDocuments,
);
router.post(
  "/recruteurs/:recruiterId/request-multiple",
  requirePermission("validateRecruiters"),
  requestMultipleValidationItems,
);

router.put(
  "/recruteurs/:id/cancel-request",
  requirePermission("validateRecruiters"),
  cancelValidationRequest,
);

router.get("/users", getAllUsers);
router.put("/users/ban/:id", requirePermission("banUsers"), banUser);
router.put("/users/unban/:id", requirePermission("banUsers"), unBanUser);
router.post(
  "/users/message/:id",
  requirePermission("sendNotifications"),
  sendMessageToUser,
);

router.get("/admins", requirePermission("viewStats"), getAllAdmins);
router.post("/admins", requirePermission("createAdmin"), createAdmin);
router.delete("/admins/:id", requirePermission("deleteAdmin"), deleteAdmin);
router.put(
  "/admins/:id/suspend",
  requirePermission("deleteAdmin"),
  suspendAdmin,
);
router.put(
  "/admins/:id/permissions",
  requirePermission("editAdminPermissions"),
  updateAdminPermissions,
);
router.put(
  "/admins/:id/label",
  requirePermission("assignAdminLabels"),
  updateAdminLabel,
);

router.get(
  "/entreprises/all",
  requirePermission("validateCompanies"),
  getAllCompanies,
);

router.get(
  "/entreprises/en-attente",
  requirePermission("validateCompanies"),
  getPendingCompanies,
);
router.put(
  "/entreprises/valider/:id",
  requirePermission("validateCompanies"),
  validateCompany,
);
router.put(
  "/entreprises/rejeter/:id",
  requirePermission("validateCompanies"),
  rejectCompany,
);

router.get(
  "/entreprises/:companyId",
  requirePermission("validateCompanies"),
  getCompanyDetailsAdmin,
);

router.put(
  "/entreprises/:id",
  requirePermission("validateCompanies"),
  updateCompanyByAdmin,
);

router.get(
  "/offres/en-attente",
  requirePermission("validateOffers"),
  getPendingOffers,
);
router.put(
  "/offres/:id/approve",
  requirePermission("validateOffers"),
  approveOffer,
);
router.put(
  "/offres/:id/reject",
  requirePermission("validateOffers"),
  rejectOffer,
);
router.delete(
  "/offres/:id",
  requirePermission("validateOffers"),
  deleteOfferAdmin,
);
router.get(
  "/offres/manuelles",
  requirePermission("proposeCandidates"),
  getManualSelectionOffers,
);
router.post(
  "/offres/proposer",
  requirePermission("proposeCandidates"),
  proposeCandidateToOffer,
);

router.get(
  "/offres/:id/details",
  requirePermission("validateOffers"),
  getOfferDetailsAdmin,
);
router.put(
  "/offres/:id/update",
  requirePermission("validateOffers"),
  updateOfferByAdmin,
);
router.put(
  "/offres/:id/visibility",
  requirePermission("validateOffers"),
  toggleOfferVisibility,
);

router.get(
  "/candidates/:id",
  requirePermission("viewStats"),
  getCandidateDetailsAdmin,
);

router.get(
  "/announcements",
  requirePermission("manageAnnouncements"),
  getAllAnnouncements,
);
router.post(
  "/announcements",
  requirePermission("manageAnnouncements"),
  createAnnouncement,
);
router.put(
  "/announcements/:id",
  requirePermission("manageAnnouncements"),
  updateAnnouncement,
);
router.delete(
  "/announcements/:id",
  requirePermission("manageAnnouncements"),
  deleteAnnouncement,
);

router.get(
  "/tickets",
  requirePermission("handleSupportTickets"),
  getTicketsByLabel,
);
router.get(
  "/tickets/:ticketId",
  requirePermission("handleSupportTickets"),
  getTicketById,
);
router.post(
  "/tickets/:ticketId/respond",
  requirePermission("handleSupportTickets"),
  uploadAttachments.array("attachments", 3),
  respondToTicket,
);
router.put(
  "/tickets/:ticketId/reassign",
  requirePermission("handleSupportTickets"),
  reassignTicket,
);
router.put(
  "/tickets/:ticketId/close",
  requirePermission("handleSupportTickets"),
  closeTicket,
);

router.get("/logs", requirePermission("viewLogs"), getAdminLogs);

router.post(
  "/entreprises/create",
  requirePermission("validateCompanies"),
  createCompanyByAdmin,
);

router.get(
  "/entreprises/:companyId/recruiters",
  requirePermission("validateCompanies"),
  getCompanyRecruiters,
);

router.post(
  "/entreprises/assign-admin",
  requirePermission("validateCompanies"),
  assignCompanyAdmin,
);

router.delete(
  "/entreprises/remove-admin/:recruiterId",
  requirePermission("validateCompanies"),
  removeCompanyAdmin,
);


router.get("/settings", getAllSettings);
router.get("/settings/category/:category", getSettingsByCategory);
router.put(
  "/settings/bulk",
  requirePermission("editAdminPermissions"),
  updateSettingsBulk,
);
router.get("/settings/email-verification-mode", getEmailVerificationMode);
router.post("/settings/email-verification-mode", toggleEmailVerificationMode);
router.post("/settings/skill-proposal", toggleSkillProposal);


router.get("/skills", requirePermission("viewStats"), getSkills);
router.post("/skills", requirePermission("validateOffers"), createSkill);
router.delete("/skills/:id", requirePermission("validateOffers"), deleteSkill);


router.get(
  "/skills/stats",
  requirePermission("viewStats"),
  getSkillSystemStats,
);
router.get(
  "/skills/settings",
  requirePermission("viewStats"),
  getSkillSettings,
);
router.put(
  "/skills/settings",
  requirePermission("editAdminPermissions"),
  updateSkillSettings,
);


router.get("/skills", requirePermission("viewStats"), getSkills);
router.post("/skills", requirePermission("validateOffers"), createSkill);
router.put("/skills/:id", requirePermission("validateOffers"), updateSkill);
router.delete("/skills/:id", requirePermission("validateOffers"), deleteSkill);


router.get(
  "/skills/clusters/trending",
  requirePermission("validateOffers"),
  getTrendingClusters,
);
router.get(
  "/skills/clusters/duplicates",
  requirePermission("validateOffers"),
  getDuplicateClusters,
);
router.get(
  "/skills/clusters/orphans",
  requirePermission("validateOffers"),
  getOrphanClusters,
);
router.get(
  "/skills/clusters/flagged",
  requirePermission("validateOffers"),
  getFlaggedClusters,
);
router.get(
  "/skills/clusters/:clusterId",
  requirePermission("validateOffers"),
  getClusterDetail,
);
router.post(
  "/skills/clusters/:clusterId/promote",
  requirePermission("validateOffers"),
  promoteCluster,
);
router.post(
  "/skills/clusters/:clusterId/dismiss",
  requirePermission("validateOffers"),
  dismissCluster,
);
router.post(
  "/skills/clusters/:clusterId/flag",
  requirePermission("validateOffers"),
  flagCluster,
);
router.post(
  "/skills/clusters/:clusterId/unflag",
  requirePermission("validateOffers"),
  unflagCluster,
);


router.get(
  "/skills/feedback",
  requirePermission("validateOffers"),
  getSkillFeedback,
);
router.post(
  "/skills/feedback/:feedbackId/review",
  requirePermission("validateOffers"),
  reviewSkillFeedback,
);

export default router;


=== routes\candidateRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { authRole } from "../middleware/roles.js";
import { requireEmailVerification } from "../middleware/requireEmailVerification.js";
import { uploadRateLimiter } from "../middleware/security.js";
import { validators } from "../middleware/validate.js";
import {
  uploadCV,
  uploadImage,
  uploadAttachments,
  handleMulterError,
} from "../config/multer.js";

import {
  updateProfile,
  uploadProfilePicture,
  uploadCandidateCV,
  deleteCV,
  applyToOffer,
  updateAccount,
  getProfile,
  addToFavorites,
  removeFromFavorites,
  getFavorites,
  addSkill,
  updateSkill,
  deleteSkill,
  addExperience,
  updateExperience,
  deleteExperience,
  addEducation,
  updateEducation,
  deleteEducation,
  getCandidateStats,
  getActivityTimeline,
  getRecommendedOffers,
} from "../controllers/candidateController.js";

import {
  getSkillDetails,
  submitSkillFeedback,
} from "../controllers/skillController.js";

import {
  getMyApplications,
  getApplicationDetail,
  withdrawApplication,
  cancelApplication,
  checkApplicationStatus,
} from "../controllers/candidateApplicationController.js";

import {
  getCandidateInterviews,
  acceptInterview,
  declineInterview,
  proposeAlternativeDate,
} from "../controllers/interviewController.js";

import {
  getCandidateConversations,
  getConversationMessages,
  sendMessageAsCandidate,
} from "../controllers/conversationController.js";

const router = express.Router();

router.use(auth, authRole(["candidat"]));


router.get("/profil", getProfile);
router.put("/profil", validators.updateProfile, updateProfile);
router.put("/compte", updateAccount);
router.get("/stats", getCandidateStats);
router.get("/activity", getActivityTimeline);


router.post(
  "/upload-photo",
  uploadRateLimiter,
  uploadImage.single("photo"),
  handleMulterError,
  uploadProfilePicture,
);
router.post(
  "/upload-cv",
  uploadRateLimiter,
  uploadCV.single("cv"),
  handleMulterError,
  uploadCandidateCV,
);
router.delete("/delete-cv/:cvId", validators.mongoId("cvId"), deleteCV);


router.post("/profil/skills", validators.addSkill, addSkill);
router.put(
  "/profil/skills/:skillId",
  validators.mongoId("skillId"),
  updateSkill,
);
router.delete(
  "/profil/skills/:skillId",
  validators.mongoId("skillId"),
  deleteSkill,
);

router.get(
  "/profil/skills/:skillId/details",
  validators.mongoId("skillId"),
  getSkillDetails,
);
router.post(
  "/profil/skills/:skillId/feedback",
  validators.mongoId("skillId"),
  submitSkillFeedback,
);


router.post("/profil/experiences", validators.addExperience, addExperience);
router.put(
  "/profil/experiences/:experienceId",
  validators.mongoId("experienceId"),
  updateExperience,
);
router.delete(
  "/profil/experiences/:experienceId",
  validators.mongoId("experienceId"),
  deleteExperience,
);


router.post("/profil/education", validators.addEducation, addEducation);
router.put(
  "/profil/education/:educationId",
  validators.mongoId("educationId"),
  updateEducation,
);
router.delete(
  "/profil/education/:educationId",
  validators.mongoId("educationId"),
  deleteEducation,
);


router.get("/favorites", getFavorites);
router.post(
  "/favorites/:offerId",
  validators.mongoId("offerId"),
  addToFavorites,
);
router.delete(
  "/favorites/:offerId",
  validators.mongoId("offerId"),
  removeFromFavorites,
);


router.get("/recommended-offers", getRecommendedOffers);


router.post(
  "/postuler",
  requireEmailVerification,
  validators.applyToOffer,
  applyToOffer,
);
router.get(
  "/applications/check/:offerId",
  validators.mongoId("offerId"),
  checkApplicationStatus,
);
router.get("/applications", validators.pagination, getMyApplications);
router.get(
  "/applications/:applicationId",
  validators.mongoId("applicationId"),
  getApplicationDetail,
);
router.delete(
  "/applications/:applicationId",
  validators.mongoId("applicationId"),
  withdrawApplication,
);
router.delete(
  "/applications/:applicationId/cancel",
  validators.mongoId("applicationId"),
  cancelApplication,
);


router.get("/interviews", getCandidateInterviews);
router.put(
  "/interviews/:interviewId/accept",
  validators.mongoId("interviewId"),
  acceptInterview,
);
router.put(
  "/interviews/:interviewId/decline",
  validators.mongoId("interviewId"),
  declineInterview,
);
router.put(
  "/interviews/:interviewId/propose-date",
  validators.mongoId("interviewId"),
  proposeAlternativeDate,
);


router.get("/conversations", getCandidateConversations);
router.get(
  "/conversations/:conversationId",
  validators.mongoId("conversationId"),
  getConversationMessages,
);
router.post(
  "/conversations/:conversationId/messages",
  validators.mongoId("conversationId"),
  uploadAttachments.array("attachments", 3),
  handleMulterError,
  sendMessageAsCandidate,
);

export default router;


=== routes\skillRoutes.js ===
import express from "express";
import {
  getSkills,
  getSkillProposalStatus,
  suggestSkills,
} from "../controllers/skillController.js";
import auth from "../middleware/auth.js";

const router = express.Router();

router.get("/", auth, getSkills);
router.get("/suggest", auth, suggestSkills);
router.get("/proposal-status", auth, getSkillProposalStatus);

export default router;


=== utils\profileCompletion.js ===
export const calculateProfileCompletion = (candidate, user) => {
  const checks = {
    nom: !!user?.nom,
    telephone: !!candidate?.telephone,
    residence: !!candidate?.residence?.wilaya,

    bio: !!candidate?.bio,
    dateOfBirth: !!candidate?.dateOfBirth,
    gender: !!candidate?.gender,
    profilePicture: !!candidate?.profilePicture,

    desiredPosition: !!candidate?.desiredPosition,
    cv: candidate?.cvs?.length > 0,
    skills: candidate?.skills?.length > 0,
    experiences: candidate?.experiences?.length > 0,
    education: candidate?.education?.length > 0,
  };

  const completed = Object.values(checks).filter(Boolean).length;
  const total = Object.keys(checks).length;

  const minimumRequiredForApplication = {
    telephone: !!candidate?.telephone,
    residence: !!candidate?.residence?.wilaya,
    cv: candidate?.cvs?.length > 0,
    skills: candidate?.skills?.length > 0,
  };

  const canApply = Object.values(minimumRequiredForApplication).every(Boolean);
  const missingForApplication = Object.entries(minimumRequiredForApplication)
    .filter(([_, v]) => !v)
    .map(([k]) => {
      const labels = {
        telephone: "NumÃ©ro de tÃ©lÃ©phone",
        residence: "Localisation (wilaya)",
        cv: "CV",
        skills: "Au moins une compÃ©tence",
      };
      return labels[k] || k;
    });

  return {
    percentage: Math.round((completed / total) * 100),
    missing: Object.entries(checks)
      .filter(([_, v]) => !v)
      .map(([k]) => k),
    isComplete: completed === total,
    canApply,
    missingForApplication,
  };
};
