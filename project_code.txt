

=== package.json ===
{
  "name": "refresh_project",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "node server.js"
  },
  "engines": {
    "node": ">=18"
  },
  "dependencies": {
    "bcryptjs": "2.4.3",
    "cloudinary": "^2.9.0",
    "cors": "2.8.5",
    "dotenv": "16.4.5",
    "express": "4.21.2",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^8.2.1",
    "express-validator": "^7.3.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "9.0.2",
    "mongoose": "8.9.5",
    "morgan": "1.10.1",
    "multer": "1.4.5-lts.1",
    "nodemailer": "^7.0.13",
    "validator": "^13.15.26"
  }
}


=== server.js ===
import dotenv from "dotenv";
dotenv.config();
import express from "express";
import cors from "cors";
import morgan from "morgan";
import connectDB from "./config/db.js";
import setupFolders from "./startup/setupFolders.js";
import { seedAdmin } from "./startup/seedAdmin.js";
import { setupSecurity } from "./middleware/security.js";
import SystemSettings from "./models/SystemSettings.js";
import { verifySmtpConnection } from "./services/emailService.js";

import authRoutes from "./routes/authRoutes.js";
import candidateRoutes from "./routes/candidateRoutes.js";
import offerRoutes from "./routes/offerRoutes.js";
import notificationRoutes from "./routes/notificationRoutes.js";
import skillRoutes from "./routes/skillRoutes.js";
import supportRoutes from "./routes/supportRoutes.js";
import announcementRoutes from "./routes/announcementRoutes.js";

import recruiterRoutes from "./routes/recruiterRoutes.js";
import adminRoutes from "./routes/adminRoutes.js";
import anemRoutes from "./routes/anemRoutes.js";
import candidateAnemRoutes from "./routes/candidateAnemRoutes.js";

const app = express();

try {
  setupSecurity(app);
} catch (err) {
  console.warn("âš ï¸ setupSecurity not found or failed, skipping...");
}

app.use(
  cors({
    origin: "*",
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
    allowedHeaders: [
      "Content-Type",
      "Authorization",
      "ngrok-skip-browser-warning",
    ],
  }),
);

app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

if (process.env.NODE_ENV !== "test") {
  app.use(morgan(process.env.NODE_ENV === "production" ? "combined" : "dev"));
}

app.use("/uploads", express.static("uploads"));

app.use((err, req, res, next) => {
  if (err instanceof SyntaxError && err.status === 400 && "body" in err) {
    return res.status(400).json({ msg: "JSON invalide" });
  }
  next(err);
});

async function startServer() {
  try {
    
    console.log("ðŸ”§ Environment check:");
    console.log("   NODE_ENV:", process.env.NODE_ENV || "development");
    console.log("   SMTP_HOST:", process.env.SMTP_HOST || "NOT SET");
    console.log("   SMTP_PORT:", process.env.SMTP_PORT || "NOT SET");
    console.log("   SMTP_USER:", process.env.SMTP_USER || "NOT SET");
    console.log("   SMTP_PASS:", process.env.SMTP_PASS ? "SET" : "NOT SET");

    await connectDB();
    setupFolders();

    await seedAdmin();

    await SystemSettings.initializeDefaults();
    console.log("âš™ï¸ ParamÃ¨tres systÃ¨me initialisÃ©s");

    
    const emailMode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );
    console.log(`ðŸ“§ Email verification mode: ${emailMode}`);

    if (emailMode === "smtp") {
      console.log("ðŸ“§ Verifying SMTP connection...");
      const smtpOk = await verifySmtpConnection();
      if (smtpOk) {
        console.log("âœ… SMTP ready for sending emails");
      } else {
        console.warn("âš ï¸ SMTP connection failed - emails may not be sent");
        console.warn("   Falling back to development mode for safety");
        
        
      }
    } else {
      console.log("ðŸ“§ Development mode: Use code 123456 for verification");
    }

    
    app.use("/api/auth", authRoutes);
    app.use("/api/skills", skillRoutes);
    app.use("/api/offers", offerRoutes);
    app.use("/api/candidates", candidateRoutes);
    app.use("/api/notifications", notificationRoutes);
    app.use("/api/support", supportRoutes);
    app.use("/api/announcements", announcementRoutes);
    app.use("/api/candidate-anem", candidateAnemRoutes);

    app.use("/api/recruiters", recruiterRoutes);
    app.use("/api/admin", adminRoutes);
    app.use("/api/anem", anemRoutes);

    
    app.get("/", (req, res) =>
      res.json({
        status: "ok",
        message: "âœ… API Recrutement opÃ©rationnelle !",
        timestamp: new Date().toISOString(),
      }),
    );

    app.get("/health", (req, res) =>
      res.json({
        status: "healthy",
        uptime: process.uptime(),
        timestamp: new Date().toISOString(),
      }),
    );

    
    if (process.env.NODE_ENV !== "production") {
      app.get("/debug/smtp", async (req, res) => {
        try {
          const smtpOk = await verifySmtpConnection();
          const emailMode = await SystemSettings.getSetting(
            "email_verification_mode",
            "development",
          );
          res.json({
            smtpConnection: smtpOk,
            emailMode,
            config: {
              host: process.env.SMTP_HOST,
              port: process.env.SMTP_PORT,
              user: process.env.SMTP_USER,
              passSet: !!process.env.SMTP_PASS,
            },
          });
        } catch (err) {
          res.status(500).json({ error: err.message });
        }
      });
    }

    
    app.use((req, res) => {
      res.status(404).json({ msg: "Route non trouvÃ©e" });
    });

    
    app.use((err, req, res, next) => {
      console.error("âŒ Erreur serveur:", err);

      const message =
        process.env.NODE_ENV === "production"
          ? "Erreur interne du serveur"
          : err.message;

      res.status(err.status || 500).json({
        msg: message,
        ...(process.env.NODE_ENV !== "production" && { stack: err.stack }),
      });
    });

    const PORT = process.env.PORT || 5000;
    app.listen(PORT, () => {
      console.log(`ðŸš€ Serveur lancÃ© sur le port ${PORT}`);
      console.log(`ðŸ“Š Environnement: ${process.env.NODE_ENV || "development"}`);
    });
  } catch (error) {
    console.error("âŒ Erreur lors du dÃ©marrage du serveur :", error);
    process.exit(1);
  }
}

startServer();

process.on("uncaughtException", (err) => {
  console.error("âŒ Uncaught Exception:", err);
  process.exit(1);
});

process.on("unhandledRejection", (reason, promise) => {
  console.error("âŒ Unhandled Rejection at:", promise, "reason:", reason);
});

export default app;


=== config\cloudinary.js ===
import { v2 as cloudinary } from "cloudinary";
import { Readable } from "stream";


import "dotenv/config";

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});


export const uploadToCloudinary = (buffer, options = {}) => {
  return new Promise((resolve, reject) => {
    const uploadOptions = {
      resource_type: "auto",
      ...options,
    };

    const uploadStream = cloudinary.uploader.upload_stream(
      uploadOptions,
      (error, result) => {
        if (error) {
          reject(error);
        } else {
          resolve(result);
        }
      },
    );

    const readableStream = new Readable();
    readableStream.push(buffer);
    readableStream.push(null);
    readableStream.pipe(uploadStream);
  });
};


export const deleteFromCloudinary = async (
  publicId,
  resourceType = "image",
) => {
  try {
    const result = await cloudinary.uploader.destroy(publicId, {
      resource_type: resourceType,
    });
    return result;
  } catch (error) {
    console.error(`Failed to delete from Cloudinary: ${publicId}`, error);
    
    return { result: "error", error: error.message };
  }
};


export const getPublicIdFromUrl = (url) => {
  if (!url || !url.includes("cloudinary.com")) {
    return null;
  }

  try {
    
    
    
    const regex =
      /\/(?:image|raw|video)\/upload\/(?:v\d+\/)?(.+?)(?:\.[^.]+)?$/;
    const match = url.match(regex);
    return match ? match[1] : null;
  } catch {
    return null;
  }
};


export const uploadCV = async (buffer, filename, userId) => {
  const extension = filename.split(".").pop().toLowerCase();

  return uploadToCloudinary(buffer, {
    folder: `recruitment/cvs/${userId}`,
    resource_type: "raw",
    public_id: `cv_${Date.now()}`,
    format: extension,
    tags: ["cv", userId],
  });
};


export const uploadProfileImage = async (buffer, userId) => {
  return uploadToCloudinary(buffer, {
    folder: `recruitment/profiles/${userId}`,
    resource_type: "image",
    public_id: `profile_${Date.now()}`,
    transformation: [
      { width: 400, height: 400, crop: "fill", gravity: "face" },
      { quality: "auto:good" },
      { fetch_format: "auto" },
    ],
    tags: ["profile", userId],
  });
};


export const uploadAttachment = async (
  buffer,
  filename,
  folder = "attachments",
) => {
  const extension = filename.split(".").pop().toLowerCase();
  const isImage = ["jpg", "jpeg", "png", "webp", "gif"].includes(extension);

  return uploadToCloudinary(buffer, {
    folder: `recruitment/${folder}`,
    resource_type: isImage ? "image" : "raw",
    public_id: `attachment_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    format: isImage ? undefined : extension,
    tags: ["attachment"],
  });
};


export const deleteMultipleFromCloudinary = async (urls) => {
  const deletePromises = urls.map(async (url) => {
    const publicId = getPublicIdFromUrl(url);
    if (publicId) {
      
      const resourceType = url.includes("/raw/") ? "raw" : "image";
      return deleteFromCloudinary(publicId, resourceType);
    }
  });

  await Promise.allSettled(deletePromises);
};

export default {
  uploadToCloudinary,
  deleteFromCloudinary,
  getPublicIdFromUrl,
  uploadCV,
  uploadProfileImage,
  uploadAttachment,
  deleteMultipleFromCloudinary,
};


=== config\db.js ===
import mongoose from "mongoose";

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI);
    console.log("ðŸŸ¢ ConnectÃ© Ã  MongoDB");
  } catch (err) {
    console.error("âŒ Erreur MongoDB :", err.message);
    process.exit(1);
  }
};

export default connectDB;


=== config\email.js ===
import nodemailer from "nodemailer";

export const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});


=== config\multer.js ===
import multer from "multer";
import path from "path";


const memoryStorage = multer.memoryStorage();


const fileFilterCV = (req, file, cb) => {
  const allowed = [".pdf", ".doc", ".docx"];
  const ext = path.extname(file.originalname).toLowerCase();

  if (!allowed.includes(ext)) {
    return cb(new Error("Seulement PDF, DOC ou DOCX autorisÃ©s"));
  }
  cb(null, true);
};


const fileFilterImage = (req, file, cb) => {
  const allowed = [".jpg", ".jpeg", ".png", ".webp"];
  const ext = path.extname(file.originalname).toLowerCase();

  if (!allowed.includes(ext)) {
    return cb(new Error("Seulement JPG, JPEG, PNG ou WEBP autorisÃ©s"));
  }
  cb(null, true);
};


const fileFilterAttachments = (req, file, cb) => {
  const allowed = [".pdf", ".doc", ".docx", ".jpg", ".jpeg", ".png", ".webp"];
  const ext = path.extname(file.originalname).toLowerCase();

  if (!allowed.includes(ext)) {
    return cb(new Error("Type de fichier non autorisÃ©"));
  }
  cb(null, true);
};


export const uploadCV = multer({
  storage: memoryStorage,
  fileFilter: fileFilterCV,
  limits: { fileSize: 5 * 1024 * 1024 }, 
});


export const uploadImage = multer({
  storage: memoryStorage,
  fileFilter: fileFilterImage,
  limits: { fileSize: 5 * 1024 * 1024 }, 
});


export const uploadAttachments = multer({
  storage: memoryStorage,
  fileFilter: fileFilterAttachments,
  limits: { fileSize: 10 * 1024 * 1024 }, 
});


export const handleMulterError = (err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    if (err.code === "LIMIT_FILE_SIZE") {
      return res.status(400).json({ msg: "Fichier trop volumineux" });
    }
    if (err.code === "LIMIT_FILE_COUNT") {
      return res.status(400).json({ msg: "Trop de fichiers" });
    }
    return res.status(400).json({ msg: err.message });
  }
  if (err) {
    return res.status(400).json({ msg: err.message });
  }
  next();
};

export default { uploadCV, uploadImage, uploadAttachments, handleMulterError };


=== controllers\adminController.js ===
import User from "../models/User.js";
import Recruiter from "../models/Recruiter.js";
import Candidate from "../models/Candidate.js";
import Offer from "../models/Offer.js";
import Admin from "../models/Admin.js";
import Notification from "../models/Notification.js";
import Application from "../models/Application.js";
import Company from "../models/Company.js";
import bcrypt from "bcryptjs";
import SupportTicket from "../models/SupportTicket.js";
import AdminLog, { logAdminAction } from "../models/AdminLog.js";
import AnemRegistration from "../models/AnemRegistration.js";
import CandidateAnemRegistration from "../models/CandidateAnemRegistration.js";

export const getRecruiters = async (req, res) => {
  try {
    const { status, page = 1, limit = 20, search } = req.query;

    let query = {};

    if (status === "pending") {
      query.status = { $in: ["pending_validation", "pending_revalidation"] };
    } else if (status === "requests_sent") {
      query.status = {
        $in: [
          "pending_info",
          "pending_documents",
          "pending_info_and_documents",
        ],
      };
    } else if (status === "decision_made") {
      query.status = { $in: ["validated", "rejected"] };
    } else if (status) {
      query.status = status;
    }

    if (search) {
      const users = await User.find({
        $or: [
          { nom: { $regex: search, $options: "i" } },
          { email: { $regex: search, $options: "i" } },
        ],
      }).select("_id");

      const userIds = users.map((u) => u._id);

      const companies = await Company.find({
        name: { $regex: search, $options: "i" },
      }).select("_id");
      const companyIds = companies.map((c) => c._id);

      query.$or = [
        { userId: { $in: userIds } },
        { companyId: { $in: companyIds } },
      ];
    }

    const skip = (page - 1) * limit;

    const recruiters = await Recruiter.find(query)
      .populate({
        path: "userId",
        select: "nom email createdAt",
      })
      .populate("companyId", "name status logo")
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Recruiter.countDocuments(query);

    const enriched = recruiters
      .filter((r) => r.userId !== null)
      .map((r) => ({
        _id: r._id,
        userId: r.userId._id,
        nom: r.userId.nom,
        email: r.userId.email,
        createdAt: r.userId.createdAt,

        entrepriseId: r.companyId?._id,
        entreprise: r.companyId?.name || "Inconnue",
        entrepriseStatus: r.companyId?.status,
        entrepriseLogo: r.companyId?.logo,
        entrepriseDetails: r.companyId,

        position: r.position,
        telephone: r.telephone || "Non renseignÃ©",
        recruiterStatus: r.status,
        isAdmin: r.isAdmin,
        rejectionReason: r.rejectionReason,

        anem: {
          status: r.anem?.status || "not_started",
          anemId: r.anem?.anemId,
          isRegistered: r.anem?.status === "registered",
        },

        validationRequests: r.validationRequests,

        lastRequestDate:
          r.validationRequests.length > 0
            ? r.validationRequests[r.validationRequests.length - 1].createdAt
            : null,
      }));

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const cancelValidationRequest = async (req, res) => {
  try {
    const { id } = req.params;

    const recruiter = await Recruiter.findById(id);
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    recruiter.status = "pending_validation";

    recruiter.validationRequests = recruiter.validationRequests.filter(
      (req) => req.status !== "pending",
    );

    await recruiter.save();

    await logAdminAction(
      req.user.id,
      "recruiter_request_canceled",
      { type: "recruiter", id: recruiter._id },
      {},
      req,
    );

    res.json({ msg: "Demande annulÃ©e, recruteur replacÃ© en attente âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanyDetailsAdmin = async (req, res) => {
  try {
    const { companyId } = req.params;
    const company = await Company.findById(companyId);

    if (!company)
      return res.status(404).json({ msg: "Entreprise introuvable" });

    const recruiterCount = await Recruiter.countDocuments({ companyId });
    const offerCount = await Offer.countDocuments({ companyId });

    res.json({
      ...company.toObject(),
      stats: {
        recruiters: recruiterCount,
        offers: offerCount,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const validateRecruiter = async (req, res) => {
  try {
    const { id } = req.params;

    let recruiter = await Recruiter.findById(id).populate("companyId");
    if (!recruiter) {
      recruiter = await Recruiter.findOne({ userId: id }).populate("companyId");
    }

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    const user = await User.findById(recruiter.userId);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable" });
    }

    recruiter.status = "validated";

    const existingAdmins = await Recruiter.countDocuments({
      companyId: recruiter.companyId._id,
      status: "validated",
      isAdmin: true,
    });

    if (existingAdmins === 0 && recruiter.companyId.status === "active") {
      recruiter.isAdmin = true;
      recruiter.permissions.editCompany = true;
      recruiter.permissions.manageTeam = true;

      await Notification.create({
        userId: user._id,
        message: `FÃ©licitations ! Vous Ãªtes le premier recruteur validÃ© de "${recruiter.companyId.name}" et devenez automatiquement administrateur de l'entreprise.`,
        type: "validation",
      });
    }

    await recruiter.save();

    await Notification.create({
      userId: user._id,
      message:
        "FÃ©licitations ! Votre compte recruteur a Ã©tÃ© validÃ©. Vous pouvez maintenant publier des offres.",
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_validated",
      { type: "recruiter", id: recruiter._id },
      { isFirstAdmin: recruiter.isAdmin },
      req,
    );

    res.json({
      msg: "Recruteur validÃ© avec succÃ¨s âœ…",
      isCompanyAdmin: recruiter.isAdmin,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectRecruiter = async (req, res) => {
  try {
    const { id } = req.params;
    const { message } = req.body;

    let recruiter = await Recruiter.findById(id);
    if (!recruiter) {
      recruiter = await Recruiter.findOne({ userId: id });
    }

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    recruiter.status = "rejected";
    recruiter.rejectionReason = message || "Non spÃ©cifiÃ©e";
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId,
      message: `Votre compte recruteur a Ã©tÃ© rejetÃ©. Raison : ${
        message || "Non spÃ©cifiÃ©e"
      }`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_rejected",
      { type: "recruiter", id: recruiter._id },
      { reason: message },
      req,
    );

    res.json({ msg: "Recruteur rejetÃ© âŒ" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllAdmins = async (req, res) => {
  try {
    const admins = await Admin.find()
      .populate("userId", "nom email createdAt")
      .populate("createdBy", "nom")
      .sort({ createdAt: -1 });

    res.json(admins);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const suspendAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason, until } = req.body;

    if (id === req.user.id) {
      return res
        .status(400)
        .json({ msg: "Vous ne pouvez pas vous suspendre vous-mÃªme." });
    }

    const targetAdmin = await Admin.findOne({ userId: id });
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin introuvable" });
    }

    if (targetAdmin.label === "super_admin") {
      return res
        .status(403)
        .json({ msg: "Impossible de suspendre un super admin" });
    }

    targetAdmin.status = "suspended";
    targetAdmin.suspensionReason = reason;
    targetAdmin.suspendedUntil = until ? new Date(until) : null;
    await targetAdmin.save();

    await logAdminAction(
      req.user.id,
      "admin_suspended",
      { type: "admin", id: targetAdmin._id },
      { reason, until },
      req,
    );

    res.json({ msg: "Administrateur suspendu â›”" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getPendingCompanies = async (req, res) => {
  try {
    const companies = await Company.find({ status: "pending" }).sort({
      createdAt: -1,
    });
    res.json(companies);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const validateCompany = async (req, res) => {
  try {
    const { id } = req.params;
    const company = await Company.findByIdAndUpdate(
      id,
      { status: "active" },
      { new: true },
    );

    if (!company)
      return res.status(404).json({ msg: "Entreprise introuvable" });

    res.json({ msg: "Entreprise validÃ©e avec succÃ¨s âœ…", company });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectCompany = async (req, res) => {
  try {
    const { id } = req.params;
    const company = await Company.findByIdAndUpdate(
      id,
      { status: "rejected" },
      { new: true },
    );

    if (!company)
      return res.status(404).json({ msg: "Entreprise introuvable" });

    res.json({ msg: "Entreprise rejetÃ©e âŒ", company });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const createAdmin = async (req, res) => {
  try {
    const { nom, email, motDePasse, forceVerify } = req.body;

    const exist = await User.findOne({ email });
    if (exist) return res.status(400).json({ msg: "Email dÃ©jÃ  utilisÃ©" });

    const hash = await bcrypt.hash(motDePasse, 10);

    const emailVerified = forceVerify !== undefined ? forceVerify : true;

    const user = await User.create({
      nom,
      email,
      motDePasse: hash,
      role: "admin",
      statutValidation: "validÃ©",
      emailVerified: emailVerified,
    });

    await Admin.create({ userId: user._id });

    res.status(201).json({ msg: "Nouvel administrateur crÃ©Ã© âœ…", admin: user });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteAdmin = async (req, res) => {
  try {
    const { id } = req.params;

    if (id === req.user.id)
      return res
        .status(400)
        .json({ msg: "Vous ne pouvez pas vous supprimer vous-mÃªme." });

    const adminUser = await User.findById(id);
    if (!adminUser || adminUser.role !== "admin")
      return res.status(404).json({ msg: "Admin introuvable" });

    await User.findByIdAndDelete(id);
    await Admin.findOneAndDelete({ userId: id });

    res.json({ msg: "Administrateur supprimÃ© ðŸ—‘ï¸" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const banUser = async (req, res) => {
  try {
    const { id } = req.params;
    const { raison } = req.body;

    const user = await User.findById(id);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });
    if (user.role === "admin")
      return res.status(403).json({ msg: "Impossible de bannir un admin." });

    user.accountStatus = "banned";
    user.suspensionReason = raison || "Non respect des conditions.";
    await user.save();

    await Notification.create({
      userId: user._id,
      message: `Votre compte a Ã©tÃ© dÃ©sactivÃ©. Raison : ${
        raison || "Non respect des conditions."
      }`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "user_banned",
      { type: "user", id: user._id },
      { reason: raison },
      req,
    );

    res.json({ msg: `Utilisateur ${user.nom} a Ã©tÃ© banni â›”` });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const unBanUser = async (req, res) => {
  try {
    const { id } = req.params;

    const user = await User.findById(id);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });

    if (user.role === "admin") {
      return res.status(400).json({ msg: "Action inutile sur un admin." });
    }

    if (user.accountStatus === "active") {
      return res.status(400).json({ msg: "Cet utilisateur n'est pas banni." });
    }

    user.accountStatus = "active";
    user.suspensionReason = undefined;
    user.suspendedUntil = undefined;
    await user.save();

    await Notification.create({
      userId: user._id,
      message:
        "Bonne nouvelle ! Votre compte a Ã©tÃ© rÃ©activÃ© par l'administration. Vous pouvez Ã  nouveau vous connecter.",
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "user_unbanned",
      { type: "user", id: user._id },
      {},
      req,
    );

    res.json({ msg: `L'utilisateur ${user.nom} a Ã©tÃ© dÃ©banni et rÃ©activÃ© âœ…` });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllUsers = async (req, res) => {
  try {
    const {
      role,
      status,
      search,
      wilaya,
      proposable,
      emailVerified,
      page = 1,
      limit = 20,
    } = req.query;

    let query = {};
    if (role) query.role = role;
    if (status) query.accountStatus = status;
    if (emailVerified) query.emailVerified = emailVerified === "true";

    if (search) {
      query.$or = [
        { nom: { $regex: search, $options: "i" } },
        { email: { $regex: search, $options: "i" } },
      ];
    }

    const skip = (page - 1) * limit;

    const [users, total] = await Promise.all([
      User.find(query)
        .select("-motDePasse")
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean(),
      User.countDocuments(query),
    ]);

    const userIds = users.map((u) => u._id);

    const [candidates, recruiters] = await Promise.all([
      Candidate.find({ userId: { $in: userIds } })
        .select(
          "userId telephone residence autoriserProposition desiredPosition",
        )
        .lean(),
      Recruiter.find({ userId: { $in: userIds } })
        .populate("companyId", "name")
        .select("userId status companyId")
        .lean(),
    ]);

    const candidateMap = new Map(
      candidates.map((c) => [c.userId.toString(), c]),
    );
    const recruiterMap = new Map(
      recruiters.map((r) => [r.userId.toString(), r]),
    );

    const recruiterIds = recruiters.map((r) => r._id);
    const offerCounts = await Offer.aggregate([
      { $match: { recruteurId: { $in: recruiterIds } } },
      { $group: { _id: "$recruteurId", count: { $sum: 1 } } },
    ]);

    const offerCountMap = new Map(
      offerCounts.map((o) => [o._id.toString(), o.count]),
    );

    let enriched = users.map((u) => {
      const userId = u._id.toString();
      let details = {};

      if (u.role === "candidat") {
        const cand = candidateMap.get(userId);
        if (cand) {
          details = {
            telephone: cand.telephone,
            wilaya: cand.residence?.wilaya || null,
            autoriserProposition: cand.autoriserProposition,
            poste: cand.desiredPosition,
          };
        }
      }

      if (u.role === "recruteur") {
        const rec = recruiterMap.get(userId);
        if (rec) {
          details = {
            entreprise: rec.companyId?.name || "Inconnue",
            recruiterStatus: rec.status,
            offres: offerCountMap.get(rec._id.toString()) || 0,
          };
        }
      }

      return {
        ...u,
        accountStatus: u.accountStatus,
        details,
      };
    });

    if (wilaya) {
      enriched = enriched.filter(
        (u) =>
          u.details?.wilaya &&
          u.details.wilaya.toLowerCase() === wilaya.toLowerCase(),
      );
    }

    if (proposable === "true") {
      enriched = enriched.filter(
        (u) => u.details?.autoriserProposition === true,
      );
    }

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const sendMessageToUser = async (req, res) => {
  try {
    const { id } = req.params;
    const { message } = req.body;

    await Notification.create({
      userId: id,
      message: `Message de l'administration : ${message}`,
      type: "info",
    });

    res.json({ msg: "Notification envoyÃ©e âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteOfferAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const { motif } = req.body;

    const offer = await Offer.findById(id).populate("recruteurId");
    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    if (offer.recruteurId && offer.recruteurId.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Votre offre "${offer.titre}" a Ã©tÃ© supprimÃ©e. Motif : ${
          motif || "Non conforme"
        }`,
        type: "alerte",
      });
    }

    await Offer.findByIdAndDelete(id);

    res.json({ msg: "Offre supprimÃ©e et recruteur notifiÃ© ðŸ—‘ï¸" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getGlobalStats = async (req, res) => {
  try {
    const now = new Date();
    const fifteenMinutesAgo = new Date(now - 15 * 60 * 1000);
    const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);

    const [
      onlineUsers,
      totalUsers,
      newUsersThisMonth,
      usersByRole,
      totalOffres,
      offresActives,
      pendingOffers,
      newOffersThisMonth,
      applicationStats,
      pendingRecruiters,
      pendingCompanies,
      openTickets,
      pendingAnem,
      pendingCandidateAnem,
      recentAdminActions,
    ] = await Promise.all([
      User.countDocuments({ derniereConnexion: { $gt: fifteenMinutesAgo } }),
      User.countDocuments(),
      User.countDocuments({ createdAt: { $gte: thirtyDaysAgo } }),
      User.aggregate([{ $group: { _id: "$role", count: { $sum: 1 } } }]),
      Offer.countDocuments(),
      Offer.countDocuments({ actif: true, validationStatus: "approved" }),
      Offer.countDocuments({ validationStatus: "pending" }),
      Offer.countDocuments({ createdAt: { $gte: thirtyDaysAgo } }),
      Application.aggregate([
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),

      Recruiter.countDocuments({
        status: { $in: ["pending_validation", "pending_revalidation"] },
      }),
      Company.countDocuments({ status: "pending" }),
      SupportTicket.countDocuments({
        status: { $in: ["open", "in_progress"] },
      }),
      AnemRegistration.countDocuments({
        status: { $in: ["pending", "pending_verification"] },
      }),
      
      CandidateAnemRegistration.countDocuments({
        status: { $in: ["pending", "pending_verification"] },
      }),
      AdminLog.find()
        .populate("adminId", "nom")
        .sort({ createdAt: -1 })
        .limit(10),
    ]);

    const roleMap = {};
    usersByRole.forEach((r) => {
      roleMap[r._id] = r.count;
    });

    const statsCandidatures = {};
    applicationStats.forEach((s) => {
      statsCandidatures[s._id] = s.count;
    });

    const pendingTasks = {
      recruiters: pendingRecruiters,
      companies: 0,
      offers: pendingOffers,
      tickets: openTickets,
      anemCandidates: pendingCandidateAnem, 
      total:
        pendingRecruiters +
        pendingOffers +
        openTickets +
        pendingAnem +
        pendingCandidateAnem,
    };

    res.json({
      users: {
        online: onlineUsers,
        total: totalUsers,
        newThisMonth: newUsersThisMonth,
        byRole: roleMap,
      },
      offres: {
        total: totalOffres,
        actives: offresActives,
        pending: pendingOffers,
        newThisMonth: newOffersThisMonth,
      },
      candidatures: statsCandidatures,
      pendingTasks,
      recentAdminActions,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getTrends = async (req, res) => {
  try {
    const { period = "30" } = req.query;
    const days = parseInt(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const [rawUsers, rawOffers, rawApplications] = await Promise.all([
      User.aggregate([
        { $match: { createdAt: { $gte: startDate } } },
        {
          $group: {
            _id: {
              date: {
                $dateToString: { format: "%Y-%m-%d", date: "$createdAt" },
              },
            },
            count: { $sum: 1 },
          },
        },
      ]),

      Offer.aggregate([
        { $match: { createdAt: { $gte: startDate } } },
        {
          $group: {
            _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
            count: { $sum: 1 },
          },
        },
      ]),

      Application.aggregate([
        { $match: { datePostulation: { $gte: startDate } } },
        {
          $group: {
            _id: {
              $dateToString: { format: "%Y-%m-%d", date: "$datePostulation" },
            },
            count: { $sum: 1 },
          },
        },
      ]),
    ]);

    const statsMap = new Map();
    for (let i = 0; i < days; i++) {
      const d = new Date();
      d.setDate(d.getDate() - i);
      const dateStr = d.toISOString().split("T")[0];

      statsMap.set(dateStr, {
        date: dateStr,
        users: 0,
        offers: 0,
        applications: 0,
      });
    }

    rawUsers.forEach((u) => {
      const date = u._id.date;
      if (statsMap.has(date)) {
        statsMap.get(date).users += u.count;
      }
    });

    rawOffers.forEach((o) => {
      const date = o._id;
      if (statsMap.has(date)) {
        statsMap.get(date).offers += o.count;
      }
    });

    rawApplications.forEach((a) => {
      const date = a._id;
      if (statsMap.has(date)) {
        statsMap.get(date).applications += a.count;
      }
    });

    const chartData = Array.from(statsMap.values()).sort(
      (a, b) => new Date(a.date) - new Date(b.date),
    );

    res.json({
      data: chartData,
      period: days,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getManualSelectionOffers = async (req, res) => {
  try {
    const {
      minProposals,
      maxProposals,
      startDate,
      endDate,
      sortBy = "datePublication",
    } = req.query;

    const pipeline = [
      {
        $match: {
          actif: true,
          candidateSearchMode: "manual",
          validationStatus: "approved",
        },
      },
    ];

    if (startDate || endDate) {
      const dateFilter = {};
      if (startDate) dateFilter.$gte = new Date(startDate);
      if (endDate) dateFilter.$lte = new Date(endDate);
      pipeline[0].$match.datePublication = dateFilter;
    }

    pipeline.push({
      $lookup: {
        from: "applications",
        let: { offerId: "$_id" },
        pipeline: [
          {
            $match: {
              $expr: {
                $and: [
                  { $eq: ["$offerId", "$$offerId"] },
                  { $eq: ["$recommandeParAdmin", true] },
                ],
              },
            },
          },
          { $count: "count" },
        ],
        as: "adminProposals",
      },
    });

    pipeline.push({
      $addFields: {
        proposalCount: {
          $ifNull: [{ $arrayElemAt: ["$adminProposals.count", 0] }, 0],
        },
      },
    });

    if (minProposals !== undefined || maxProposals !== undefined) {
      const countMatch = {};
      if (minProposals !== undefined) countMatch.$gte = parseInt(minProposals);
      if (maxProposals !== undefined) countMatch.$lte = parseInt(maxProposals);
      pipeline.push({ $match: { proposalCount: countMatch } });
    }

    pipeline.push(
      {
        $lookup: {
          from: "recruiters",
          localField: "recruteurId",
          foreignField: "_id",
          as: "recruteur",
        },
      },
      { $unwind: "$recruteur" },
      {
        $lookup: {
          from: "companies",
          localField: "companyId",
          foreignField: "_id",
          as: "company",
        },
      },
      { $unwind: "$company" },
    );

    let sortStage = {};
    if (sortBy === "lastModified") {
      sortStage = { updatedAt: -1 };
    } else {
      sortStage = { datePublication: -1 };
    }
    pipeline.push({ $sort: sortStage });

    const offers = await Offer.aggregate(pipeline);

    res.json(offers);
  } catch (err) {
    console.error("Erreur Manual Matching:", err);
    res.status(500).json({ msg: err.message });
  }
};

export const proposeCandidateToOffer = async (req, res) => {
  try {
    const { candidatId, offreId } = req.body;

    const offer = await Offer.findById(offreId).populate("recruteurId");
    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    let candidate = await Candidate.findById(candidatId).populate("userId");

    if (!candidate) {
      candidate = await Candidate.findOne({ userId: candidatId }).populate(
        "userId",
      );
    }

    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    if (!candidate.userId?.emailVerified) {
      return res.status(400).json({ msg: "Email candidat non vÃ©rifiÃ©." });
    }

    if (!candidate.autoriserProposition) {
      return res
        .status(403)
        .json({ msg: "Ce candidat refuse les propositions." });
    }

    if (!candidate.cvs || candidate.cvs.length === 0) {
      return res.status(400).json({
        msg: "Impossible de proposer ce candidat : il n'a pas de CV.",
      });
    }

    const existingApp = await Application.findOne({
      offerId: offreId,
      candidateId: candidate._id,
    });

    if (existingApp) {
      return res.status(400).json({ msg: "Candidat dÃ©jÃ  positionnÃ©." });
    }
    const lastCv = candidate.cvs[candidate.cvs.length - 1].url;

    await Application.create({
      offerId: offreId,
      candidateId: candidate._id,
      cvUrl: lastCv,

      candidateStatus: "envoyee",
      recruiterStatus: "nouvelle",

      source: "admin_proposal",
      proposedBy: req.user.id,
      proposedAt: new Date(),

      coverLetter:
        "Recommandation Admin : Ce profil correspond parfaitement aux critÃ¨res de lâ€™offre.",

      offerSnapshot: {
        titre: offer.titre,
        companyId: offer.companyId,
        type: offer.type,
      },
    });

    offer.nombreCandidatures += 1;
    await offer.save();

    if (offer.recruteurId?.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Un administrateur vous a proposÃ© un candidat recommandÃ© (${candidate.userId.nom}) pour votre offre "${offer.titre}".`,
        type: "validation",
      });
    }

    await Notification.create({
      userId: candidate.userId._id,
      message: `Bonne nouvelle ! Votre profil a Ã©tÃ© recommandÃ© par un administrateur pour l'offre "${offer.titre}".`,
      type: "info",
    });

    return res.json({ msg: "Candidat proposÃ© avec succÃ¨s âœ…" });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ msg: err.message });
  }
};

export const getAdminLogs = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 50,
      adminId,
      action,
      startDate,
      endDate,
    } = req.query;

    let query = {};
    if (adminId) query.adminId = adminId;
    if (action) query.action = action;
    if (startDate || endDate) {
      query.createdAt = {};
      if (startDate) query.createdAt.$gte = new Date(startDate);
      if (endDate) query.createdAt.$lte = new Date(endDate);
    }

    const logs = await AdminLog.find(query)
      .populate("adminId", "nom email")
      .sort({ createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await AdminLog.countDocuments(query);

    res.json({
      data: logs,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getPendingOffers = async (req, res) => {
  try {
    const { page = 1, limit = 20, sortBy = "createdAt" } = req.query;

    const offers = await Offer.find({ validationStatus: "pending" })
      .populate("companyId", "name logo")
      .populate({
        path: "recruteurId",
        select: "userId position",
        populate: { path: "userId", select: "nom email" },
      })
      .sort({ [sortBy]: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await Offer.countDocuments({ validationStatus: "pending" });

    res.json({
      data: offers,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const approveOffer = async (req, res) => {
  try {
    const { id } = req.params;

    const offer = await Offer.findById(id).populate("recruteurId");
    if (!offer) return res.status(404).json({ msg: "Offre introuvable." });

    offer.validationStatus = "approved";
    offer.actif = true;
    offer.datePublication = new Date();
    offer.validationHistory.push({
      status: "approved",
      adminId: req.user.id,
    });
    await offer.save();

    if (offer.recruteurId && offer.recruteurId.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Votre offre "${offer.titre}" a Ã©tÃ© approuvÃ©e et est maintenant visible.`,
        type: "validation",
      });
    }

    await logAdminAction(
      req.user.id,
      "offer_approved",
      { type: "offer", id: offer._id },
      {},
      req,
    );

    res.json({ msg: "Offre approuvÃ©e âœ…", offer });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectOffer = async (req, res) => {
  try {
    const { id } = req.params;
    const { reason, requestChanges } = req.body;

    const offer = await Offer.findById(id).populate("recruteurId");
    if (!offer) return res.status(404).json({ msg: "Offre introuvable." });

    offer.validationStatus = requestChanges ? "changes_requested" : "rejected";
    offer.rejectionReason = reason;
    offer.validationHistory.push({
      status: offer.validationStatus,
      message: reason,
      adminId: req.user.id,
    });
    await offer.save();

    const msgType = requestChanges
      ? `Des modifications sont demandÃ©es pour votre offre "${offer.titre}": ${reason}`
      : `Votre offre "${offer.titre}" a Ã©tÃ© refusÃ©e: ${reason}`;

    if (offer.recruteurId && offer.recruteurId.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: msgType,
        type: "alerte",
      });
    }

    await logAdminAction(
      req.user.id,
      requestChanges ? "offer_changes_requested" : "offer_rejected",
      { type: "offer", id: offer._id },
      { reason },
      req,
    );

    res.json({
      msg: requestChanges ? "Modifications demandÃ©es." : "Offre refusÃ©e.",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const requestRecruiterDocuments = async (req, res) => {
  try {
    const { recruiterId } = req.params;
    const { type, message, requiredDocuments, requiredFields } = req.body;

    const recruiter = await Recruiter.findById(recruiterId).populate("userId");
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    recruiter.status =
      type === "document" ? "pending_documents" : "pending_info";
    recruiter.validationRequests.push({
      type,
      message,
      requiredDocuments,
      requiredFields,
      status: "pending",
    });
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Action requise : ${message}`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_documents_requested",
      { type: "recruiter", id: recruiter._id },
      { requestType: type, message },
      req,
    );

    res.json({ msg: "Demande envoyÃ©e au recruteur âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAdminPermissions = async (req, res) => {
  try {
    const { id } = req.params;
    const { permissions } = req.body;

    const targetAdmin = await Admin.findOne({ userId: id });
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin introuvable" });
    }

    if (targetAdmin.label === "super_admin") {
      return res.status(403).json({
        msg: "Impossible de modifier les permissions d'un super admin",
      });
    }

    targetAdmin.permissions = { ...targetAdmin.permissions, ...permissions };
    await targetAdmin.save();

    await logAdminAction(
      req.user.id,
      "admin_permissions_updated",
      { type: "admin", id: targetAdmin._id },
      { newPermissions: permissions },
      req,
    );

    res.json({ msg: "Permissions mises Ã  jour âœ…", admin: targetAdmin });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAdminLabel = async (req, res) => {
  try {
    const { id } = req.params;
    const { label } = req.body;

    const validLabels = [
      "super_admin",
      "support",
      "technical",
      "operational",
      "recruitment",
      "moderation",
      "product",
    ];

    if (!validLabels.includes(label)) {
      return res.status(400).json({ msg: "Label invalide" });
    }

    const targetAdmin = await Admin.findOne({ userId: id });
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin introuvable" });
    }

    const oldLabel = targetAdmin.label;
    targetAdmin.label = label;
    await targetAdmin.save();

    await logAdminAction(
      req.user.id,
      "admin_label_changed",
      { type: "admin", id: targetAdmin._id },
      { oldLabel, newLabel: label },
      req,
    );

    res.json({ msg: "Label mis Ã  jour âœ…", admin: targetAdmin });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const createCompanyByAdmin = async (req, res) => {
  try {
    const { name, website, description, industry, location, size, logo } =
      req.body;

    if (!name) {
      return res
        .status(400)
        .json({ msg: "Le nom de l'entreprise est obligatoire." });
    }

    const existingCompany = await Company.findOne({
      name: { $regex: new RegExp(`^${name}$`, "i") },
    });

    if (existingCompany) {
      return res
        .status(400)
        .json({ msg: "Une entreprise avec ce nom existe dÃ©jÃ ." });
    }

    const company = await Company.create({
      name,
      website,
      description,
      industry,
      location,
      size,
      logo,
      status: "active",
    });

    await logAdminAction(
      req.user.id,
      "company_created_by_admin",
      { type: "company", id: company._id },
      { name },
      req,
    );

    res.status(201).json({
      msg: "Entreprise crÃ©Ã©e avec succÃ¨s âœ…",
      company,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanyRecruiters = async (req, res) => {
  try {
    const { companyId } = req.params;

    const company = await Company.findById(companyId);
    if (!company) {
      return res.status(404).json({ msg: "Entreprise introuvable." });
    }

    const recruiters = await Recruiter.find({ companyId })
      .populate("userId", "nom email createdAt")
      .sort({ isAdmin: -1, createdAt: 1 });

    res.json({
      company: {
        _id: company._id,
        name: company.name,
        status: company.status,
      },
      recruiters,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const assignCompanyAdmin = async (req, res) => {
  try {
    const { companyId, recruiterId } = req.body;

    const company = await Company.findById(companyId);
    if (!company) {
      return res.status(404).json({ msg: "Entreprise introuvable." });
    }

    const recruiter = await Recruiter.findById(recruiterId).populate("userId");
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    if (recruiter.companyId.toString() !== companyId) {
      return res.status(400).json({
        msg: "Ce recruteur n'appartient pas Ã  cette entreprise.",
      });
    }

    if (recruiter.status !== "validated") {
      return res.status(400).json({
        msg: "Le recruteur doit Ãªtre validÃ© avant de devenir administrateur.",
      });
    }

    recruiter.isAdmin = true;
    recruiter.permissions.editCompany = true;
    recruiter.permissions.manageTeam = true;
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Vous Ãªtes maintenant administrateur de l'entreprise "${company.name}".`,
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "company_admin_assigned",
      { type: "recruiter", id: recruiter._id },
      { companyId, companyName: company.name },
      req,
    );

    res.json({
      msg: `${recruiter.userId.nom} est maintenant administrateur de ${company.name} âœ…`,
      recruiter,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const removeCompanyAdmin = async (req, res) => {
  try {
    const { recruiterId } = req.params;

    const recruiter = await Recruiter.findById(recruiterId)
      .populate("userId")
      .populate("companyId");

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    if (!recruiter.isAdmin) {
      return res.status(400).json({
        msg: "Ce recruteur n'est pas administrateur d'entreprise.",
      });
    }

    recruiter.isAdmin = false;
    recruiter.permissions.editCompany = false;
    recruiter.permissions.manageTeam = false;
    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Vous n'Ãªtes plus administrateur de l'entreprise "${recruiter.companyId.name}".`,
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "company_admin_removed",
      { type: "recruiter", id: recruiter._id },
      {
        companyId: recruiter.companyId._id,
        companyName: recruiter.companyId.name,
      },
      req,
    );

    res.json({
      msg: `${recruiter.userId.nom} n'est plus administrateur âš ï¸`,
      recruiter,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateCompanyByAdmin = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, website, description, industry, location, size, logo } =
      req.body;

    const company = await Company.findByIdAndUpdate(
      id,
      { name, website, description, industry, location, size, logo },
      { new: true },
    );

    if (!company) {
      return res.status(404).json({ msg: "Entreprise introuvable." });
    }

    await logAdminAction(
      req.user.id,
      "company_updated_by_admin",
      { type: "company", id: company._id },
      { updates: req.body },
      req,
    );

    res.json({ msg: "Entreprise mise Ã  jour âœ…", company });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const requestMultipleValidationItems = async (req, res) => {
  try {
    const { recruiterId } = req.params;
    const { requests } = req.body;

    const recruiter = await Recruiter.findById(recruiterId).populate("userId");
    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable." });
    }

    requests.forEach((request) => {
      recruiter.validationRequests.push({
        type: request.type,
        message: request.message,
        requiredDocuments: request.requiredDocuments || 0,
        requiredFields: request.requiredFields || [],
        status: "pending",
      });
    });

    const hasDocRequest = requests.some((r) => r.type === "document");
    const hasInfoRequest = requests.some((r) => r.type === "information");

    if (hasDocRequest && hasInfoRequest) {
      recruiter.status = "pending_info_and_documents";
    } else if (hasDocRequest) {
      recruiter.status = "pending_documents";
    } else if (hasInfoRequest) {
      recruiter.status = "pending_info";
    } else {
      return res.status(400).json({ msg: "Aucune demande valide reÃ§ue." });
    }

    await recruiter.save();

    await Notification.create({
      userId: recruiter.userId._id,
      message: `Action requise : Des informations ou documents vous sont demandÃ©s.`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "recruiter_multiple_requests",
      { type: "recruiter", id: recruiter._id },
      { requestCount: requests.length, newStatus: recruiter.status },
      req,
    );

    res.json({
      msg: `Demandes envoyÃ©es. Statut mis Ã  jour vers : ${recruiter.status} âœ…`,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllCompanies = async (req, res) => {
  try {
    const { page = 1, limit = 20, search, status } = req.query;

    let query = {};

    if (status) {
      query.status = status;
    }

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: "i" } },
        { industry: { $regex: search, $options: "i" } },
      ];
    }

    const skip = (page - 1) * limit;

    const companies = await Company.find(query)
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(parseInt(limit));

    const total = await Company.countDocuments(query);

    const enrichedCompanies = await Promise.all(
      companies.map(async (company) => {
        const recruitersCount = await Recruiter.countDocuments({
          companyId: company._id,
        });
        return {
          ...company.toObject(),
          recruitersCount,
        };
      }),
    );

    res.json({
      data: enrichedCompanies,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const getOfferDetailsAdmin = async (req, res) => {
  try {
    const { id } = req.params;

    const offer = await Offer.findById(id)
      .populate("companyId", "name logo status website location")
      .populate({
        path: "recruteurId",
        select: "userId position status telephone",
        populate: { path: "userId", select: "nom email" },
      });

    if (!offer) return res.status(404).json({ msg: "Offre introuvable." });

    res.json(offer);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const updateOfferByAdmin = async (req, res) => {
  try {
    const { id } = req.params;

    const offer = await Offer.findByIdAndUpdate(
      id,
      { $set: req.body },
      { new: true },
    );

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    await logAdminAction(
      req.user.id,
      "offer_updated_by_admin",
      { type: "offer", id: offer._id },
      { updates: req.body },
      req,
    );

    res.json({ msg: "Offre modifiÃ©e par l'admin âœ…", offer });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const toggleOfferVisibility = async (req, res) => {
  try {
    const { id } = req.params;
    const { actif } = req.body;

    const offer = await Offer.findByIdAndUpdate(
      id,
      { actif: actif },
      { new: true },
    );

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    await logAdminAction(
      req.user.id,
      actif ? "offer_activated_admin" : "offer_deactivated_admin",
      { type: "offer", id: offer._id },
      {},
      req,
    );

    res.json({
      msg: `Offre ${actif ? "activÃ©e" : "dÃ©sactivÃ©e"} avec succÃ¨s`,
      offer,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateDetailsAdmin = async (req, res) => {
  const candidate = await Candidate.findById(req.params.id).populate("userId");
  res.json(candidate);
};


=== controllers\adminSettingsController.js ===
import SystemSettings from "../models/SystemSettings.js";
import { verifySmtpConnection } from "../services/emailService.js";


export const toggleEmailVerificationMode = async (req, res) => {
  try {
    const { mode } = req.body;

    if (!["smtp", "development"].includes(mode)) {
      return res.status(400).json({
        msg: "Mode invalide. Utilisez 'smtp' ou 'development'.",
      });
    }

    
    if (mode === "smtp") {
      const isConnected = await verifySmtpConnection();
      if (!isConnected) {
        return res.status(400).json({
          msg: "Impossible d'activer le mode SMTP : connexion SMTP Ã©chouÃ©e. VÃ©rifiez les variables d'environnement SMTP.",
        });
      }
    }

    await SystemSettings.setSetting(
      "email_verification_mode",
      mode,
      "Mode de vÃ©rification email",
      req.user.id,
    );

    res.json({
      msg: `Mode de vÃ©rification email changÃ© en : ${mode}`,
      mode,
      description:
        mode === "smtp"
          ? "Les emails de vÃ©rification seront envoyÃ©s via SMTP"
          : "Mode dÃ©veloppement actif : le code 123456 sera acceptÃ© pour tous les utilisateurs",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getEmailVerificationMode = async (req, res) => {
  try {
    const mode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );

    res.json({
      mode,
      description:
        mode === "smtp"
          ? "Les emails de vÃ©rification sont envoyÃ©s via SMTP"
          : "Mode dÃ©veloppement : le code 123456 est acceptÃ©",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const toggleSkillProposal = async (req, res) => {
  try {
    const { enabled } = req.body;

    if (typeof enabled !== "boolean") {
      return res
        .status(400)
        .json({ msg: "Valeur 'enabled' requise (boolean)" });
    }

    await SystemSettings.setSetting(
      "skill_proposal_enabled",
      enabled,
      "Permet aux candidats de proposer de nouvelles compÃ©tences",
      req.user.id,
    );

    res.json({
      msg: enabled
        ? "Proposition de compÃ©tences activÃ©e"
        : "Proposition de compÃ©tences dÃ©sactivÃ©e",
      enabled,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getAllSettings = async (req, res) => {
  try {
    const settings = await SystemSettings.find({})
      .select("-__v")
      .populate("updatedBy", "nom email");

    res.json(settings);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getSettingsByCategory = async (req, res) => {
  try {
    const { category } = req.params;
    const validCategories = [
      "general",
      "email",
      "skills",
      "candidates",
      "recruiters",
      "security",
    ];

    if (!validCategories.includes(category)) {
      return res.status(400).json({ msg: "CatÃ©gorie invalide." });
    }

    const settings = await SystemSettings.getSettingsByCategory(category);
    res.json(settings);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateSettingsBulk = async (req, res) => {
  try {
    const { settings } = req.body;

    if (!settings || typeof settings !== "object") {
      return res.status(400).json({ msg: "Settings object requis." });
    }

    const results = [];
    for (const [key, value] of Object.entries(settings)) {
      const updated = await SystemSettings.setSetting(
        key,
        value,
        null,
        req.user.id,
      );
      results.push({ key, value: updated.value });
    }

    res.json({
      msg: "ParamÃ¨tres mis Ã  jour",
      updated: results,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\adminSupportController.js ===
import SupportTicket from "../models/SupportTicket.js";
import Admin from "../models/Admin.js";
import Notification from "../models/Notification.js";
import { logAdminAction } from "../models/AdminLog.js";

export const getTicketsByLabel = async (req, res) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin) {
      return res.status(403).json({ msg: "Admin introuvable." });
    }

    const { status, priority, page = 1, limit = 20 } = req.query;

    let query = {};

    if (admin.label !== "super_admin") {
      query.assignedToLabel = admin.label;
    }

    if (status) query.status = status;
    if (priority) query.priority = priority;

    const tickets = await SupportTicket.find(query)
      .populate("userId", "nom email role")
      .populate("assignedTo", "label")
      .sort({ priority: -1, createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await SupportTicket.countDocuments(query);

    res.json({
      data: tickets,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getTicketById = async (req, res) => {
  try {
    const { ticketId } = req.params;

    const ticket = await SupportTicket.findById(ticketId)
      .populate("userId", "nom email role")
      .populate("messages.adminId", "nom");

    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    res.json(ticket);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const respondToTicket = async (req, res) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });
    const { ticketId } = req.params;
    const { content, newStatus } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    if (!content) {
      return res.status(400).json({ msg: "Le contenu est obligatoire." });
    }

    const ticket = await SupportTicket.findById(ticketId);
    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    if (!ticket.assignedTo) {
      ticket.assignedTo = admin._id;
    }

    ticket.messages.push({
      from: "admin",
      content,
      adminId: req.user.id,
      attachments,
    });

    if (newStatus) {
      ticket.status = newStatus;
      if (newStatus === "resolved") ticket.resolvedAt = new Date();
      if (newStatus === "closed") ticket.closedAt = new Date();
    }

    await ticket.save();

    await Notification.create({
      userId: ticket.userId,
      message: `RÃ©ponse de l'administration sur votre ticket: "${ticket.subject}"`,
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "ticket_responded",
      { type: "ticket", id: ticket._id },
      { newStatus },
      req
    );

    res.json({ msg: "RÃ©ponse envoyÃ©e.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const reassignTicket = async (req, res) => {
  try {
    const { ticketId } = req.params;
    const { newLabel, newAdminId } = req.body;

    const ticket = await SupportTicket.findById(ticketId);
    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    if (newLabel) ticket.assignedToLabel = newLabel;
    if (newAdminId) {
      const targetAdmin = await Admin.findById(newAdminId);
      if (!targetAdmin) {
        return res.status(404).json({ msg: "Admin cible introuvable." });
      }
      ticket.assignedTo = newAdminId;
    }

    await ticket.save();

    await logAdminAction(
      req.user.id,
      "ticket_reassigned",
      { type: "ticket", id: ticket._id },
      { newLabel, newAdminId },
      req
    );

    res.json({ msg: "Ticket rÃ©assignÃ©.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const closeTicket = async (req, res) => {
  try {
    const { ticketId } = req.params;
    const { resolution } = req.body;

    const ticket = await SupportTicket.findById(ticketId);
    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    ticket.status = "closed";
    ticket.closedAt = new Date();

    if (resolution) {
      ticket.messages.push({
        from: "admin",
        content: `Ticket fermÃ©. RÃ©solution: ${resolution}`,
        adminId: req.user.id,
      });
    }

    await ticket.save();

    await Notification.create({
      userId: ticket.userId,
      message: `Votre ticket "${ticket.subject}" a Ã©tÃ© fermÃ©.`,
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "ticket_closed",
      { type: "ticket", id: ticket._id },
      { resolution },
      req
    );

    res.json({ msg: "Ticket fermÃ©.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\anemController.js ===
import AnemRegistration from "../models/AnemRegistration.js";
import AnemOffer from "../models/AnemOffer.js";
import Recruiter from "../models/Recruiter.js";
import Offer from "../models/Offer.js";
import User from "../models/User.js";
import Admin from "../models/Admin.js";
import Notification from "../models/Notification.js";
import AdminLog, { logAdminAction } from "../models/AdminLog.js";





const getRecruiterWithAnem = async (userId) => {
  const recruiter = await Recruiter.findOne({ userId })
    .populate("companyId")
    .populate("anem.registrationId");

  if (!recruiter) {
    throw new Error("Profil recruteur introuvable");
  }

  return recruiter;
};

const syncRecruiterAnemStatus = async (recruiterId, registration) => {
  const updateData = {
    "anem.status": registration.status,
    "anem.lastStatusUpdate": new Date(),
    "anem.registrationId": registration._id,
  };

  if (registration.status === "registered" && registration.verifiedAnemId) {
    updateData["anem.anemId"] = registration.verifiedAnemId;
    updateData["anem.registeredAt"] = registration.verifiedAt || new Date();
  }

  await Recruiter.findByIdAndUpdate(recruiterId, updateData);
};

const notifyAdminsNewDemande = async (registration, recruiterName, type) => {
  const admins = await Admin.find({
    status: "active",
    $or: [{ label: "super_admin" }, { "permissions.validateRecruiters": true }],
  }).populate("userId", "_id");

  const message =
    type === "self_declared"
      ? `Nouvel ID ANEM Ã  vÃ©rifier de ${recruiterName}`
      : `Nouvelle demande d'inscription ANEM de ${recruiterName}`;

  const notifPromises = admins.map((admin) =>
    Notification.create({
      userId: admin.userId._id,
      message,
      type: "info",
    }),
  );

  await Promise.all(notifPromises);
};






export const getAnemStatus = async (req, res) => {
  try {
    const recruiter = await getRecruiterWithAnem(req.user.id);

    const offerCount = await Offer.countDocuments({
      recruteurId: recruiter._id,
    });

    
    const [anemOfferCount, totalActiveOffers] = await Promise.all([
      AnemOffer.countDocuments({
        recruiterId: recruiter._id,
        anemEnabled: true,
      }),
      Offer.countDocuments({
        recruteurId: recruiter._id,
        actif: true,
        validationStatus: "approved",
      }),
    ]);

    let registration = null;
    let latestPublicNote = null;

    if (recruiter.anem.registrationId) {
      registration = await AnemRegistration.findById(
        recruiter.anem.registrationId,
      )
        .select("-auditLog")
        .populate("adminNotes.createdBy", "nom")
        .lean();

      if (registration) {
        
        const publicNotes = registration.adminNotes
          ?.filter((n) => n.isPublic)
          .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

        latestPublicNote = publicNotes?.[0] || null;
      }
    }

    
    let sidebarView = "not_started";
    let actionRequired = false;
    let statusMessage = "";

    switch (recruiter.anem.status) {
      case "not_started":
        sidebarView = "intro";
        statusMessage = "Vous n'Ãªtes pas encore inscrit Ã  l'ANEM";
        break;
      case "draft":
        sidebarView = "continue_form";
        actionRequired = true;
        statusMessage = "Inscription en cours - Continuez votre formulaire";
        break;
      case "pending":
        sidebarView = "pending";
        statusMessage = "Votre demande est en attente de traitement";
        break;
      case "pending_verification":
        sidebarView = "pending_verification";
        statusMessage = "Votre ID ANEM est en cours de vÃ©rification";
        break;
      case "in_progress":
        sidebarView = "in_progress";
        statusMessage =
          "Votre inscription est en cours de traitement par notre Ã©quipe";
        break;
      case "registered":
        sidebarView = "registered";
        statusMessage = `Vous Ãªtes inscrit Ã  l'ANEM (ID: ${recruiter.anem.anemId})`;
        break;
      case "failed":
        sidebarView = "failed";
        actionRequired = true;
        statusMessage = "Votre inscription a Ã©chouÃ© - Vous pouvez rÃ©essayer";
        break;
      case "rejected":
        sidebarView = "rejected";
        actionRequired = true;
        statusMessage =
          "Votre ID ANEM a Ã©tÃ© rejetÃ© - Vous pouvez soumettre un nouvel ID";
        break;
    }

    res.json({
      
      status: recruiter.anem.status,
      anemId: recruiter.anem.anemId,
      registeredAt: recruiter.anem.registeredAt,

      
      hasSeenAnemModal: recruiter.anem.hasSeenAnemModal,
      declinedAnem: recruiter.anem.declinedAnem,

      
      isFirstOffer: offerCount === 0,
      canCreateAnemOffer: recruiter.canCreateAnemOffer(),

      
      sidebarView,
      actionRequired,
      statusMessage,
      latestPublicNote: latestPublicNote
        ? {
            content: latestPublicNote.content,
            createdAt: latestPublicNote.createdAt,
            adminName: latestPublicNote.createdBy?.nom,
          }
        : null,

      
      registration: registration
        ? {
            _id: registration._id,
            registrationType: registration.registrationType,
            status: registration.status,
            currentStep: registration.currentStep,
            formCompleted: registration.formCompleted,
            formSubmittedAt: registration.formSubmittedAt,
            failureReason: registration.failureReason,
            rejectionReason: registration.rejectionReason,
            declaredAnemId: registration.declaredAnemId,
            verifiedAnemId: registration.verifiedAnemId,
            createdAt: registration.createdAt,
            updatedAt: registration.updatedAt,
            
            lastRejectedId:
              registration.anemIdHistory?.find((h) => h.status === "rejected")
                ?.anemId || null,
          }
        : null,

      
      stats: {
        totalOffers: offerCount,
        activeOffers: totalActiveOffers,
        anemOffers: anemOfferCount,
        offersWithoutAnem: totalActiveOffers - anemOfferCount,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const checkAnemModalRequired = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    const offerCount = await Offer.countDocuments({
      recruteurId: recruiter._id,
    });

    const isFirstOffer = offerCount === 0;
    const hasSeenModal = recruiter.anem.hasSeenAnemModal;
    const declinedAnem = recruiter.anem.declinedAnem;
    const isRegistered = recruiter.canCreateAnemOffer();

    
    let showModal = false;
    let modalReason = null;

    if (isFirstOffer && !hasSeenModal) {
      showModal = true;
      modalReason = "first_offer";
    }

    res.json({
      showModal,
      modalReason,
      isFirstOffer,
      hasSeenModal,
      declinedAnem,
      isRegistered,
      anemStatus: recruiter.anem.status,
      anemId: recruiter.anem.anemId,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const markAnemModalSeen = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOneAndUpdate(
      { userId: req.user.id },
      {
        "anem.hasSeenAnemModal": true,
        "anem.modalSeenAt": new Date(),
      },
      { new: true },
    );

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    res.json({
      msg: "Modal marquÃ© comme vu",
      hasSeenAnemModal: true,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const declineAnem = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOneAndUpdate(
      { userId: req.user.id },
      {
        "anem.hasSeenAnemModal": true,
        "anem.modalSeenAt": new Date(),
        "anem.declinedAnem": true,
        "anem.declinedAt": new Date(),
      },
      { new: true },
    );

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    res.json({
      msg: "Vous avez choisi de ne pas utiliser ANEM pour le moment",
      declinedAnem: true,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const resetAnemDecline = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOneAndUpdate(
      { userId: req.user.id },
      {
        "anem.declinedAnem": false,
        "anem.declinedAt": null,
      },
      { new: true },
    );

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    res.json({
      msg: "Vous pouvez maintenant vous inscrire Ã  l'ANEM",
      declinedAnem: false,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const submitAnemId = async (req, res) => {
  try {
    const { anemId } = req.body;

    if (!anemId || anemId.trim().length < 3) {
      return res.status(400).json({ msg: "ID ANEM invalide" });
    }

    const recruiter = await getRecruiterWithAnem(req.user.id);
    const user = await User.findById(req.user.id);

    
    if (recruiter.status !== "validated") {
      return res.status(403).json({
        msg: "Votre compte recruteur doit Ãªtre validÃ© avant de soumettre un ID ANEM",
        code: "RECRUITER_NOT_VALIDATED",
        recruiterStatus: recruiter.status,
      });
    }

    
    if (recruiter.anem.status === "registered") {
      return res.status(400).json({
        msg: "Vous Ãªtes dÃ©jÃ  enregistrÃ© ANEM",
        anemId: recruiter.anem.anemId,
      });
    }

    
    let registration = await AnemRegistration.findOne({
      recruiterId: recruiter._id,
    });

    const trimmedId = anemId.trim().toUpperCase();

    if (!registration) {
      
      registration = new AnemRegistration({
        recruiterId: recruiter._id,
        companyId: recruiter.companyId._id,
        userId: req.user.id,
        registrationType: "self_declared",
        declaredAnemId: trimmedId,
        declaredAt: new Date(),
        status: "pending_verification",
        anemIdHistory: [
          {
            anemId: trimmedId,
            submittedAt: new Date(),
            status: "pending",
          },
        ],
      });

      registration.addAuditEntry(
        "created",
        req.user.id,
        { newValue: { registrationType: "self_declared", anemId: trimmedId } },
        req,
      );
    } else {
      
      const previousId = registration.declaredAnemId;

      
      const lastHistory =
        registration.anemIdHistory[registration.anemIdHistory.length - 1];
      if (!lastHistory || lastHistory.anemId !== trimmedId) {
        registration.anemIdHistory.push({
          anemId: trimmedId,
          submittedAt: new Date(),
          status: "pending",
        });
      } else if (lastHistory.status === "rejected") {
        
        registration.anemIdHistory.push({
          anemId: trimmedId,
          submittedAt: new Date(),
          status: "pending",
        });
      }

      registration.registrationType = "self_declared";
      registration.declaredAnemId = trimmedId;
      registration.declaredAt = new Date();
      registration.status = "pending_verification";
      registration.rejectionReason = undefined;

      registration.addAuditEntry(
        "anem_id_updated",
        req.user.id,
        { previousValue: previousId, newValue: trimmedId },
        req,
      );
    }

    await registration.save();
    await syncRecruiterAnemStatus(recruiter._id, registration);

    
    await Recruiter.findByIdAndUpdate(recruiter._id, {
      "anem.hasSeenAnemModal": true,
      "anem.modalSeenAt": new Date(),
    });

    
    await notifyAdminsNewDemande(registration, user.nom, "self_declared");

    res.status(201).json({
      msg: "ID ANEM soumis pour vÃ©rification. Vous serez notifiÃ© du rÃ©sultat.",
      status: "pending_verification",
      registrationId: registration._id,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const startRegistration = async (req, res) => {
  try {
    const recruiter = await getRecruiterWithAnem(req.user.id);
    const user = await User.findById(req.user.id);

    
    if (recruiter.status !== "validated") {
      return res.status(403).json({
        msg: "Votre compte recruteur doit Ãªtre validÃ© avant de soumettre un ID ANEM",
        code: "RECRUITER_NOT_VALIDATED",
        recruiterStatus: recruiter.status,
      });
    }

    
    if (recruiter.anem.status === "registered") {
      return res.status(400).json({
        msg: "Vous Ãªtes dÃ©jÃ  enregistrÃ© ANEM",
        anemId: recruiter.anem.anemId,
      });
    }

    
    let registration = await AnemRegistration.findOne({
      recruiterId: recruiter._id,
    });

    if (registration) {
      
      if (["failed", "rejected"].includes(registration.status)) {
        registration.registrationType = "site_registration";
        registration.status = "draft";
        registration.currentStep = 1;
        registration.formCompleted = false;
        registration.failureReason = undefined;
        registration.rejectionReason = undefined;

        registration.addAuditEntry(
          "created",
          req.user.id,
          { newValue: { action: "restart_after_failure" } },
          req,
        );

        await registration.save();
      } else if (registration.registrationType === "self_declared") {
        
        registration.registrationType = "site_registration";
        registration.status = "draft";
        registration.currentStep = 1;
        registration.formCompleted = false;

        registration.addAuditEntry(
          "created",
          req.user.id,
          { newValue: { action: "convert_to_site_registration" } },
          req,
        );

        await registration.save();
      }
      
    } else {
      
      registration = new AnemRegistration({
        recruiterId: recruiter._id,
        companyId: recruiter.companyId._id,
        userId: req.user.id,
        registrationType: "site_registration",
        status: "draft",
        currentStep: 1,
        
        step4: {
          email: user.email,
        },
      });

      registration.addAuditEntry(
        "created",
        req.user.id,
        { newValue: { registrationType: "site_registration" } },
        req,
      );

      await registration.save();
    }

    await syncRecruiterAnemStatus(recruiter._id, registration);

    
    await Recruiter.findByIdAndUpdate(recruiter._id, {
      "anem.hasSeenAnemModal": true,
      "anem.modalSeenAt": new Date(),
    });

    res.json({
      msg: "Inscription dÃ©marrÃ©e",
      registration: {
        _id: registration._id,
        currentStep: registration.currentStep,
        formCompleted: registration.formCompleted,
        step1: registration.step1 || {},
        step2: registration.step2 || {},
        step3: registration.step3 || {},
        step4: {
          email: registration.step4?.email || user.email,
          consentementRgpd: registration.step4?.consentementRgpd || false,
        },
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const saveRegistrationStep = async (req, res) => {
  try {
    const { step, data } = req.body;

    if (!step || step < 1 || step > 4) {
      return res.status(400).json({ msg: "Ã‰tape invalide (1-4)" });
    }

    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    const registration = await AnemRegistration.findOne({
      recruiterId: recruiter._id,
      registrationType: "site_registration",
      status: "draft",
    });

    if (!registration) {
      return res.status(404).json({
        msg: "Aucune inscription en cours. Veuillez recommencer.",
        code: "NO_DRAFT_REGISTRATION",
      });
    }

    
    const stepKey = `step${step}`;
    registration[stepKey] = { ...registration[stepKey], ...data };

    
    if (
      step === 4 &&
      data.consentementRgpd &&
      !registration.step4?.consentementAt
    ) {
      registration.step4.consentementAt = new Date();
    }

    
    if (step >= registration.currentStep) {
      registration.currentStep = step;
    }

    registration.addAuditEntry(
      "step_saved",
      req.user.id,
      { newValue: { step } },
      req,
    );

    await registration.save();

    res.json({
      msg: `Ã‰tape ${step} enregistrÃ©e`,
      currentStep: registration.currentStep,
      savedData: registration[stepKey],
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const submitRegistration = async (req, res) => {
  try {
    const recruiter = await getRecruiterWithAnem(req.user.id);
    const user = await User.findById(req.user.id);

    const registration = await AnemRegistration.findOne({
      recruiterId: recruiter._id,
      registrationType: "site_registration",
      status: "draft",
    });

    if (!registration) {
      return res.status(404).json({
        msg: "Aucune inscription en cours trouvÃ©e",
        code: "NO_DRAFT_REGISTRATION",
      });
    }

    
    const validation = {
      step1: {
        valid: true,
        missing: [],
      },
      step2: {
        valid: true,
        missing: [],
      },
      step3: {
        valid: true,
        missing: [],
      },
      step4: {
        valid: true,
        missing: [],
      },
    };

    
    const step1Required = [
      "numeroCnas",
      "raisonSociale",
      "denominationCommerciale",
      "nif",
    ];
    step1Required.forEach((field) => {
      if (
        !registration.step1?.[field] ||
        registration.step1[field].toString().trim() === ""
      ) {
        validation.step1.valid = false;
        validation.step1.missing.push(field);
      }
    });

    
    const step2Required = [
      "secteurActivite",
      "brancheActivite",
      "secteurJuridique",
      "statutJuridique",
      "adresse",
      "wilaya",
      "commune",
    ];
    step2Required.forEach((field) => {
      if (
        !registration.step2?.[field] ||
        registration.step2[field].toString().trim() === ""
      ) {
        validation.step2.valid = false;
        validation.step2.missing.push(field);
      }
    });

    
    if (
      registration.step3?.effectifDeclare === undefined ||
      registration.step3?.effectifDeclare === null
    ) {
      validation.step3.valid = false;
      validation.step3.missing.push("effectifDeclare");
    }
    if (
      registration.step3?.dontInseresCta === undefined ||
      registration.step3?.dontInseresCta === null
    ) {
      validation.step3.valid = false;
      validation.step3.missing.push("dontInseresCta");
    }
    if (
      registration.step3?.nombreInseresDaip === undefined ||
      registration.step3?.nombreInseresDaip === null
    ) {
      validation.step3.valid = false;
      validation.step3.missing.push("nombreInseresDaip");
    }

    
    if (!registration.step4?.email || registration.step4.email.trim() === "") {
      validation.step4.valid = false;
      validation.step4.missing.push("email");
    }
    if (!registration.step4?.consentementRgpd) {
      validation.step4.valid = false;
      validation.step4.missing.push("consentementRgpd");
    }

    const allValid = Object.values(validation).every((v) => v.valid);

    if (!allValid) {
      return res.status(400).json({
        msg: "Veuillez complÃ©ter tous les champs obligatoires",
        validation,
      });
    }

    
    registration.formCompleted = true;
    registration.formCompletedAt = new Date();
    registration.formSubmittedAt = new Date();
    registration.status = "pending";
    registration.currentStep = 4;

    registration.addAuditEntry(
      "form_submitted",
      req.user.id,
      { newValue: { status: "pending" } },
      req,
    );

    await registration.save();
    await syncRecruiterAnemStatus(recruiter._id, registration);

    
    await notifyAdminsNewDemande(registration, user.nom, "site_registration");

    res.json({
      msg: "Votre demande d'inscription ANEM a Ã©tÃ© soumise avec succÃ¨s. Vous serez notifiÃ© du rÃ©sultat.",
      status: "pending",
      registrationId: registration._id,
      submittedAt: registration.formSubmittedAt,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getRegistrationForm = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    const registration = await AnemRegistration.findOne({
      recruiterId: recruiter._id,
    })
      .select("-auditLog")
      .populate("adminNotes.createdBy", "nom");

    if (!registration) {
      return res.status(404).json({
        msg: "Aucune inscription trouvÃ©e",
        code: "NO_REGISTRATION",
      });
    }

    const user = await User.findById(req.user.id);

    res.json({
      registration: {
        _id: registration._id,
        registrationType: registration.registrationType,
        status: registration.status,
        currentStep: registration.currentStep,
        formCompleted: registration.formCompleted,
        formSubmittedAt: registration.formSubmittedAt,

        
        step1: registration.step1 || {},
        step2: registration.step2 || {},
        step3: registration.step3 || {},
        step4: {
          email: registration.step4?.email || user.email,
          consentementRgpd: registration.step4?.consentementRgpd || false,
          consentementAt: registration.step4?.consentementAt,
        },

        
        declaredAnemId: registration.declaredAnemId,
        verifiedAnemId: registration.verifiedAnemId,

        
        failureReason: registration.failureReason,
        rejectionReason: registration.rejectionReason,

        
        publicNotes: registration.adminNotes
          ?.filter((n) => n.isPublic)
          .map((n) => ({
            content: n.content,
            createdAt: n.createdAt,
            adminName: n.createdBy?.nom,
          }))
          .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)),

        
        anemIdHistory: registration.anemIdHistory?.map((h) => ({
          anemId: h.anemId,
          submittedAt: h.submittedAt,
          status: h.status,
          rejectionReason: h.rejectionReason,
        })),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};






export const getAnemDemandes = async (req, res) => {
  try {
    const {
      status,
      registrationType,
      wilaya,
      search,
      assignedTo,
      unassigned,
      dateFrom,
      dateTo,
      sortBy = "createdAt",
      sortOrder = "desc",
      page = 1,
      limit = 20,
    } = req.query;

    let query = {
      status: { $ne: "draft" }, 
    };

    
    if (status) {
      if (status === "new") {
        query.status = { $in: ["pending", "pending_verification"] };
      } else if (status === "active") {
        query.status = {
          $in: ["pending", "pending_verification", "in_progress"],
        };
      } else {
        query.status = status;
      }
    }

    
    if (registrationType) {
      query.registrationType = registrationType;
    }

    
    if (wilaya) {
      query["step2.wilaya"] = { $regex: new RegExp(wilaya, "i") };
    }

    
    if (assignedTo) {
      query.assignedTo = assignedTo;
    }
    if (unassigned === "true") {
      query.assignedTo = { $exists: false };
    }

    
    if (dateFrom || dateTo) {
      query.createdAt = {};
      if (dateFrom) query.createdAt.$gte = new Date(dateFrom);
      if (dateTo) {
        const endDate = new Date(dateTo);
        endDate.setHours(23, 59, 59, 999);
        query.createdAt.$lte = endDate;
      }
    }

    
    if (search) {
      const searchRegex = { $regex: search, $options: "i" };

      
      const matchingUsers = await User.find({
        $or: [{ nom: searchRegex }, { email: searchRegex }],
      }).select("_id");
      const userIds = matchingUsers.map((u) => u._id);

      query.$or = [
        { userId: { $in: userIds } },
        { "step1.raisonSociale": searchRegex },
        { "step1.numeroCnas": searchRegex },
        { "step1.nif": searchRegex },
        { declaredAnemId: searchRegex },
        { verifiedAnemId: searchRegex },
      ];
    }

    const skip = (page - 1) * limit;
    const sort = { [sortBy]: sortOrder === "desc" ? -1 : 1 };

    const [demandes, total, statusCounts] = await Promise.all([
      AnemRegistration.find(query)
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit))
        .populate("userId", "nom email")
        .populate("companyId", "name logo")
        .populate("recruiterId", "position telephone")
        .populate("assignedTo", "userId label")
        .lean(),
      AnemRegistration.countDocuments(query),
      AnemRegistration.aggregate([
        { $match: { status: { $ne: "draft" } } },
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),
    ]);

    
    const enrichedDemandes = await Promise.all(
      demandes.map(async (d) => {
        let assignedAdminName = null;
        if (d.assignedTo?.userId) {
          const adminUser = await User.findById(d.assignedTo.userId).select(
            "nom",
          );
          assignedAdminName = adminUser?.nom;
        }

        return {
          _id: d._id,
          registrationType: d.registrationType,
          status: d.status,
          currentStep: d.currentStep,
          formCompleted: d.formCompleted,
          formSubmittedAt: d.formSubmittedAt,

          
          declaredAnemId: d.declaredAnemId,
          verifiedAnemId: d.verifiedAnemId,

          
          recruiter: {
            _id: d.recruiterId?._id,
            nom: d.userId?.nom,
            email: d.userId?.email,
            telephone: d.recruiterId?.telephone,
          },
          company: {
            _id: d.companyId?._id,
            name: d.companyId?.name,
            logo: d.companyId?.logo,
          },

          
          wilaya: d.step2?.wilaya,
          raisonSociale: d.step1?.raisonSociale,

          
          assignedTo: d.assignedTo
            ? {
                _id: d.assignedTo._id,
                name: assignedAdminName,
                label: d.assignedTo.label,
              }
            : null,
          assignedAt: d.assignedAt,

          
          pdfDownloadCount: d.pdfDownloads?.length || 0,
          lastPdfDownload: d.pdfDownloads?.slice(-1)[0]?.downloadedAt,

          
          failureReason: d.failureReason,
          rejectionReason: d.rejectionReason,

          
          createdAt: d.createdAt,
          updatedAt: d.updatedAt,
        };
      }),
    );

    
    const countsMap = {};
    statusCounts.forEach((s) => {
      countsMap[s._id] = s.count;
    });

    res.json({
      data: enrichedDemandes,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
      statusCounts: countsMap,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getDemandeDetails = async (req, res) => {
  try {
    const { demandeId } = req.params;

    const demande = await AnemRegistration.findById(demandeId)
      .populate("userId", "nom email createdAt")
      .populate("companyId", "name logo website location status")
      .populate("recruiterId", "position telephone status")
      .populate("assignedTo", "userId label")
      .populate("verifiedBy", "nom")
      .populate("assignedBy", "nom")
      .populate("adminNotes.createdBy", "nom")
      .populate("auditLog.performedBy", "nom")
      .populate("anemIdHistory.reviewedBy", "nom")
      .populate("pdfDownloads.downloadedBy", "nom");

    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    
    let assignedAdminName = null;
    if (demande.assignedTo?.userId) {
      const adminUser = await User.findById(demande.assignedTo.userId).select(
        "nom",
      );
      assignedAdminName = adminUser?.nom;
    }

    
    await logAdminAction(
      req.user.id,
      "anem_demande_viewed",
      { type: "anem_registration", id: demande._id },
      {},
      req,
    );

    res.json({
      ...demande.toObject(),
      assignedAdminName,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getPendingAnemIds = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      sortBy = "declaredAt",
      sortOrder = "desc",
    } = req.query;
    const skip = (page - 1) * limit;
    const sort = { [sortBy]: sortOrder === "desc" ? -1 : 1 };

    const [demandes, total] = await Promise.all([
      AnemRegistration.find({
        registrationType: "self_declared",
        status: "pending_verification",
      })
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit))
        .populate("userId", "nom email")
        .populate("companyId", "name logo")
        .populate("recruiterId", "position")
        .lean(),
      AnemRegistration.countDocuments({
        registrationType: "self_declared",
        status: "pending_verification",
      }),
    ]);

    const enriched = demandes.map((d) => ({
      _id: d._id,
      declaredAnemId: d.declaredAnemId,
      declaredAt: d.declaredAt,
      recruiter: {
        _id: d.recruiterId?._id,
        nom: d.userId?.nom,
        email: d.userId?.email,
      },
      company: {
        _id: d.companyId?._id,
        name: d.companyId?.name,
        logo: d.companyId?.logo,
      },
      
      previousSubmissions: d.anemIdHistory
        ?.filter((h) => h.status === "rejected")
        .map((h) => ({
          anemId: h.anemId,
          submittedAt: h.submittedAt,
          rejectionReason: h.rejectionReason,
        })),
      createdAt: d.createdAt,
    }));

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const assignDemande = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { adminId } = req.body;

    const demande = await AnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    let targetAdminId = adminId;

    
    if (!adminId) {
      const selfAdmin = await Admin.findOne({ userId: req.user.id });
      if (!selfAdmin) {
        return res.status(400).json({ msg: "Admin ID requis" });
      }
      targetAdminId = selfAdmin._id;
    }

    const targetAdmin = await Admin.findById(targetAdminId).populate(
      "userId",
      "nom",
    );
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin cible introuvable" });
    }

    const previousAssigned = demande.assignedTo;

    demande.assignedTo = targetAdminId;
    demande.assignedAt = new Date();
    demande.assignedBy = req.user.id;

    demande.addAuditEntry(
      "assigned",
      req.user.id,
      { previousValue: previousAssigned, newValue: targetAdminId },
      req,
    );

    await demande.save();

    await logAdminAction(
      req.user.id,
      "anem_demande_assigned",
      { type: "anem_registration", id: demande._id },
      { assignedTo: targetAdminId, adminName: targetAdmin.userId.nom },
      req,
    );

    res.json({
      msg: `Demande assignÃ©e Ã  ${targetAdmin.userId.nom}`,
      assignedTo: {
        _id: targetAdmin._id,
        name: targetAdmin.userId.nom,
        label: targetAdmin.label,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const markInProgress = async (req, res) => {
  try {
    const { demandeId } = req.params;

    const demande = await AnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (!["pending", "pending_verification"].includes(demande.status)) {
      return res.status(400).json({
        msg: "Seules les demandes en attente peuvent Ãªtre marquÃ©es en cours",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    demande.status = "in_progress";

    
    if (!demande.assignedTo) {
      const selfAdmin = await Admin.findOne({ userId: req.user.id });
      if (selfAdmin) {
        demande.assignedTo = selfAdmin._id;
        demande.assignedAt = new Date();
        demande.assignedBy = req.user.id;
      }
    }

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      { previousValue: previousStatus, newValue: "in_progress" },
      req,
    );

    await demande.save();
    await syncRecruiterAnemStatus(demande.recruiterId, demande);

    
    await Notification.create({
      userId: demande.userId,
      message:
        "Votre demande d'inscription ANEM est en cours de traitement par notre Ã©quipe.",
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "anem_demande_in_progress",
      { type: "anem_registration", id: demande._id },
      { previousStatus },
      req,
    );

    res.json({
      msg: "Demande marquÃ©e en cours de traitement",
      status: "in_progress",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getPdfData = async (req, res) => {
  try {
    const { demandeId } = req.params;

    const demande = await AnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    
    demande.pdfDownloads.push({
      downloadedBy: req.user.id,
      downloadedAt: new Date(),
      ip: req.ip || req.connection?.remoteAddress,
    });

    demande.addAuditEntry("pdf_downloaded", req.user.id, {}, req);

    await demande.save();

    
    const pdfData = await demande.generatePdfData();

    await logAdminAction(
      req.user.id,
      "anem_pdf_downloaded",
      { type: "anem_registration", id: demande._id },
      {},
      req,
    );

    res.json(pdfData);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const approveAnemId = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { comment } = req.body;

    const demande = await AnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (demande.status !== "pending_verification") {
      return res.status(400).json({
        msg: "Seuls les IDs en attente de vÃ©rification peuvent Ãªtre approuvÃ©s",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    demande.status = "registered";
    demande.verifiedAnemId = demande.declaredAnemId;
    demande.verifiedAt = new Date();
    demande.verifiedBy = req.user.id;

    
    const lastHistory = demande.anemIdHistory[demande.anemIdHistory.length - 1];
    if (lastHistory && lastHistory.status === "pending") {
      lastHistory.status = "approved";
      lastHistory.reviewedBy = req.user.id;
      lastHistory.reviewedAt = new Date();
      lastHistory.adminComment = comment;
    }

    
    if (comment) {
      demande.adminNotes.push({
        content: comment,
        createdBy: req.user.id,
        isPublic: true,
      });
    }

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      { previousValue: previousStatus, newValue: "registered" },
      req,
    );

    await demande.save();
    await syncRecruiterAnemStatus(demande.recruiterId, demande);

    
    await Notification.create({
      userId: demande.userId,
      message: `FÃ©licitations ! Votre ID ANEM (${demande.verifiedAnemId}) a Ã©tÃ© vÃ©rifiÃ© avec succÃ¨s. Vous pouvez maintenant publier des offres via ANEM.`,
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "anem_id_approved",
      { type: "anem_registration", id: demande._id },
      { anemId: demande.verifiedAnemId },
      req,
    );

    res.json({
      msg: "ID ANEM approuvÃ© avec succÃ¨s",
      status: "registered",
      anemId: demande.verifiedAnemId,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const rejectAnemId = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { reason, publicMessage } = req.body;

    if (!reason || reason.trim().length === 0) {
      return res.status(400).json({ msg: "Raison de rejet requise" });
    }

    const demande = await AnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (demande.status !== "pending_verification") {
      return res.status(400).json({
        msg: "Seuls les IDs en attente de vÃ©rification peuvent Ãªtre rejetÃ©s",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    demande.status = "rejected";
    demande.rejectionReason = reason;

    
    const lastHistory = demande.anemIdHistory[demande.anemIdHistory.length - 1];
    if (lastHistory && lastHistory.status === "pending") {
      lastHistory.status = "rejected";
      lastHistory.reviewedBy = req.user.id;
      lastHistory.reviewedAt = new Date();
      lastHistory.rejectionReason = reason;
    }

    
    demande.adminNotes.push({
      content: publicMessage || `ID ANEM rejetÃ©: ${reason}`,
      createdBy: req.user.id,
      isPublic: true,
    });

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      { previousValue: previousStatus, newValue: "rejected" },
      req,
    );

    await demande.save();
    await syncRecruiterAnemStatus(demande.recruiterId, demande);

    
    await Notification.create({
      userId: demande.userId,
      message: `Votre ID ANEM n'a pas pu Ãªtre vÃ©rifiÃ©. Raison: ${reason}. Vous pouvez soumettre un nouvel ID ou vous inscrire via notre site.`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "anem_id_rejected",
      { type: "anem_registration", id: demande._id },
      { reason, rejectedId: demande.declaredAnemId },
      req,
    );

    res.json({
      msg: "ID ANEM rejetÃ©",
      status: "rejected",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const markRegistered = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { anemId, message } = req.body;

    if (!anemId || anemId.trim().length < 3) {
      return res.status(400).json({ msg: "ID ANEM valide requis" });
    }

    const demande = await AnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (!["pending", "in_progress"].includes(demande.status)) {
      return res.status(400).json({
        msg: "Seules les demandes en attente ou en cours peuvent Ãªtre marquÃ©es comme enregistrÃ©es",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    const trimmedId = anemId.trim().toUpperCase();

    demande.status = "registered";
    demande.verifiedAnemId = trimmedId;
    demande.verifiedAt = new Date();
    demande.verifiedBy = req.user.id;

    
    const publicMsg =
      message || `Inscription ANEM rÃ©ussie. Votre ID ANEM: ${trimmedId}`;
    demande.adminNotes.push({
      content: publicMsg,
      createdBy: req.user.id,
      isPublic: true,
    });

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      {
        previousValue: previousStatus,
        newValue: "registered",
        anemId: trimmedId,
      },
      req,
    );

    await demande.save();
    await syncRecruiterAnemStatus(demande.recruiterId, demande);

    
    await Notification.create({
      userId: demande.userId,
      message: `FÃ©licitations ! Vous Ãªtes maintenant enregistrÃ© auprÃ¨s de l'ANEM. Votre ID ANEM: ${trimmedId}`,
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "anem_registration_success",
      { type: "anem_registration", id: demande._id },
      { anemId: trimmedId },
      req,
    );

    res.json({
      msg: "Inscription ANEM enregistrÃ©e avec succÃ¨s",
      status: "registered",
      anemId: trimmedId,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const markFailed = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { reason, publicMessage } = req.body;

    if (!reason || reason.trim().length === 0) {
      return res.status(400).json({ msg: "Raison de l'Ã©chec requise" });
    }

    const demande = await AnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (!["pending", "in_progress"].includes(demande.status)) {
      return res.status(400).json({
        msg: "Seules les demandes en attente ou en cours peuvent Ãªtre marquÃ©es comme Ã©chouÃ©es",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    demande.status = "failed";
    demande.failureReason = reason;

    
    demande.adminNotes.push({
      content: publicMessage || `Inscription Ã©chouÃ©e: ${reason}`,
      createdBy: req.user.id,
      isPublic: true,
    });

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      { previousValue: previousStatus, newValue: "failed" },
      req,
    );

    await demande.save();
    await syncRecruiterAnemStatus(demande.recruiterId, demande);

    
    await Notification.create({
      userId: demande.userId,
      message: `Nous n'avons pas pu finaliser votre inscription ANEM. Raison: ${reason}. Vous pouvez rÃ©essayer en soumettant une nouvelle demande.`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "anem_registration_failed",
      { type: "anem_registration", id: demande._id },
      { reason },
      req,
    );

    res.json({
      msg: "Inscription marquÃ©e comme Ã©chouÃ©e",
      status: "failed",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const addAdminNote = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { note, isPublic = false } = req.body;

    if (!note || note.trim().length === 0) {
      return res.status(400).json({ msg: "Note requise" });
    }

    const demande = await AnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    demande.adminNotes.push({
      content: note.trim(),
      createdBy: req.user.id,
      isPublic: isPublic,
    });

    demande.addAuditEntry(
      "note_added",
      req.user.id,
      { newValue: { note, isPublic } },
      req,
    );

    await demande.save();

    
    if (isPublic) {
      await Notification.create({
        userId: demande.userId,
        message: `Mise Ã  jour concernant votre demande ANEM: ${note.substring(0, 100)}${note.length > 100 ? "..." : ""}`,
        type: "info",
      });
    }

    await logAdminAction(
      req.user.id,
      "anem_note_added",
      { type: "anem_registration", id: demande._id },
      { isPublic },
      req,
    );

    const user = await User.findById(req.user.id).select("nom");

    res.json({
      msg: "Note ajoutÃ©e",
      note: {
        content: note.trim(),
        createdAt: new Date(),
        createdBy: { nom: user.nom },
        isPublic,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const bulkUpdateStatus = async (req, res) => {
  try {
    const { demandeIds, status, reason, anemId, message } = req.body;

    if (!demandeIds || !Array.isArray(demandeIds) || demandeIds.length === 0) {
      return res.status(400).json({ msg: "IDs de demandes requis" });
    }

    if (!["in_progress", "registered", "failed"].includes(status)) {
      return res.status(400).json({
        msg: "Statut invalide. Utilisez: in_progress, registered, failed",
      });
    }

    if (status === "registered" && (!anemId || anemId.trim().length < 3)) {
      return res.status(400).json({
        msg: "ID ANEM valide requis pour marquer comme enregistrÃ©",
      });
    }

    if (status === "failed" && (!reason || reason.trim().length === 0)) {
      return res.status(400).json({
        msg: "Raison requise pour marquer comme Ã©chouÃ©",
      });
    }

    const results = {
      success: [],
      failed: [],
    };

    for (const demandeId of demandeIds) {
      try {
        const demande = await AnemRegistration.findById(demandeId);

        if (!demande) {
          results.failed.push({ id: demandeId, reason: "Demande introuvable" });
          continue;
        }

        
        if (status === "registered" || status === "failed") {
          if (!["pending", "in_progress"].includes(demande.status)) {
            results.failed.push({
              id: demandeId,
              reason: `Transition invalide de ${demande.status} vers ${status}`,
            });
            continue;
          }
        } else if (status === "in_progress") {
          if (!["pending", "pending_verification"].includes(demande.status)) {
            results.failed.push({
              id: demandeId,
              reason: `Transition invalide de ${demande.status} vers ${status}`,
            });
            continue;
          }
        }

        const previousStatus = demande.status;
        demande.status = status;

        if (status === "registered") {
          const trimmedId = anemId.trim().toUpperCase();
          demande.verifiedAnemId = trimmedId;
          demande.verifiedAt = new Date();
          demande.verifiedBy = req.user.id;

          demande.adminNotes.push({
            content: message || `Inscription ANEM rÃ©ussie. ID: ${trimmedId}`,
            createdBy: req.user.id,
            isPublic: true,
          });

          await Notification.create({
            userId: demande.userId,
            message: `FÃ©licitations ! Vous Ãªtes enregistrÃ© ANEM. ID: ${trimmedId}`,
            type: "validation",
          });
        } else if (status === "failed") {
          demande.failureReason = reason;

          demande.adminNotes.push({
            content: message || `Inscription Ã©chouÃ©e: ${reason}`,
            createdBy: req.user.id,
            isPublic: true,
          });

          await Notification.create({
            userId: demande.userId,
            message: `Votre inscription ANEM a Ã©chouÃ©. Raison: ${reason}`,
            type: "alerte",
          });
        } else if (status === "in_progress") {
          
          if (!demande.assignedTo) {
            const selfAdmin = await Admin.findOne({ userId: req.user.id });
            if (selfAdmin) {
              demande.assignedTo = selfAdmin._id;
              demande.assignedAt = new Date();
              demande.assignedBy = req.user.id;
            }
          }

          await Notification.create({
            userId: demande.userId,
            message: "Votre demande ANEM est en cours de traitement.",
            type: "info",
          });
        }

        demande.addAuditEntry(
          "status_changed",
          req.user.id,
          { previousValue: previousStatus, newValue: status },
          req,
        );

        await demande.save();
        await syncRecruiterAnemStatus(demande.recruiterId, demande);

        results.success.push(demandeId);
      } catch (err) {
        results.failed.push({ id: demandeId, reason: err.message });
      }
    }

    await logAdminAction(
      req.user.id,
      "anem_bulk_status_update",
      { type: "anem_registration", id: demandeIds.join(",") },
      {
        status,
        successCount: results.success.length,
        failedCount: results.failed.length,
      },
      req,
    );

    res.json({
      msg: `${results.success.length} demande(s) mise(s) Ã  jour avec succÃ¨s`,
      results,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getAnemStats = async (req, res) => {
  try {
    const now = new Date();
    const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
    const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);

    const [
      statusCounts,
      newDemandesThisWeek,
      newDemandesThisMonth,
      pendingOlderThan7Days,
      registrationsByType,
      processingTimes,
      anemOffersStats,
      dailyDemandes,
      wilayaDistribution,
    ] = await Promise.all([
      
      AnemRegistration.aggregate([
        { $match: { status: { $ne: "draft" } } },
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),

      
      AnemRegistration.countDocuments({
        status: { $ne: "draft" },
        createdAt: { $gte: sevenDaysAgo },
      }),

      
      AnemRegistration.countDocuments({
        status: { $ne: "draft" },
        createdAt: { $gte: thirtyDaysAgo },
      }),

      
      AnemRegistration.countDocuments({
        status: { $in: ["pending", "pending_verification"] },
        createdAt: { $lt: sevenDaysAgo },
      }),

      
      AnemRegistration.aggregate([
        { $match: { status: { $ne: "draft" } } },
        { $group: { _id: "$registrationType", count: { $sum: 1 } } },
      ]),

      
      AnemRegistration.aggregate([
        {
          $match: {
            status: "registered",
            verifiedAt: { $exists: true },
            formSubmittedAt: { $exists: true },
          },
        },
        {
          $project: {
            processingDays: {
              $divide: [
                { $subtract: ["$verifiedAt", "$formSubmittedAt"] },
                1000 * 60 * 60 * 24,
              ],
            },
          },
        },
        {
          $group: {
            _id: null,
            avgDays: { $avg: "$processingDays" },
            minDays: { $min: "$processingDays" },
            maxDays: { $max: "$processingDays" },
            count: { $sum: 1 },
          },
        },
      ]),

      
      Promise.all([
        AnemOffer.countDocuments({ anemEnabled: true }),
        Offer.countDocuments({ actif: true, validationStatus: "approved" }),
      ]),

      
      AnemRegistration.aggregate([
        {
          $match: {
            status: { $ne: "draft" },
            createdAt: { $gte: thirtyDaysAgo },
          },
        },
        {
          $group: {
            _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
            total: { $sum: 1 },
            siteRegistrations: {
              $sum: {
                $cond: [
                  { $eq: ["$registrationType", "site_registration"] },
                  1,
                  0,
                ],
              },
            },
            selfDeclared: {
              $sum: {
                $cond: [{ $eq: ["$registrationType", "self_declared"] }, 1, 0],
              },
            },
          },
        },
        { $sort: { _id: 1 } },
      ]),

      
      AnemRegistration.aggregate([
        {
          $match: {
            status: { $ne: "draft" },
            "step2.wilaya": { $exists: true },
          },
        },
        { $group: { _id: "$step2.wilaya", count: { $sum: 1 } } },
        { $sort: { count: -1 } },
        { $limit: 10 },
      ]),
    ]);

    
    const countsMap = {};
    statusCounts.forEach((s) => {
      countsMap[s._id] = s.count;
    });

    
    const typeMap = {};
    registrationsByType.forEach((t) => {
      typeMap[t._id] = t.count;
    });

    
    const totalDemandes = Object.values(countsMap).reduce((a, b) => a + b, 0);
    const successfulRegistrations = countsMap["registered"] || 0;
    const successRate =
      totalDemandes > 0
        ? Math.round((successfulRegistrations / totalDemandes) * 100)
        : 0;

    
    const [anemOffersCount, totalActiveOffers] = anemOffersStats;
    const anemOfferPercentage =
      totalActiveOffers > 0
        ? Math.round((anemOffersCount / totalActiveOffers) * 100)
        : 0;

    res.json({
      overview: {
        total: totalDemandes,
        pending:
          (countsMap["pending"] || 0) +
          (countsMap["pending_verification"] || 0),
        inProgress: countsMap["in_progress"] || 0,
        registered: countsMap["registered"] || 0,
        failed: countsMap["failed"] || 0,
        rejected: countsMap["rejected"] || 0,
      },

      trends: {
        newThisWeek: newDemandesThisWeek,
        newThisMonth: newDemandesThisMonth,
        pendingOlderThan7Days,
      },

      byType: {
        siteRegistration: typeMap["site_registration"] || 0,
        selfDeclared: typeMap["self_declared"] || 0,
      },

      performance: {
        successRate: `${successRate}%`,
        avgProcessingDays: processingTimes[0]?.avgDays?.toFixed(1) || "N/A",
        minProcessingDays: processingTimes[0]?.minDays?.toFixed(1) || "N/A",
        maxProcessingDays: processingTimes[0]?.maxDays?.toFixed(1) || "N/A",
        totalCompleted: processingTimes[0]?.count || 0,
      },

      offers: {
        withAnem: anemOffersCount,
        withoutAnem: totalActiveOffers - anemOffersCount,
        total: totalActiveOffers,
        anemPercentage: `${anemOfferPercentage}%`,
      },

      charts: {
        dailyDemandes,
        wilayaDistribution,
      },

      statusCounts: countsMap,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getNewDemandesCount = async (req, res) => {
  try {
    const [pendingCount, unassignedCount] = await Promise.all([
      AnemRegistration.countDocuments({
        status: { $in: ["pending", "pending_verification"] },
      }),
      AnemRegistration.countDocuments({
        status: { $in: ["pending", "pending_verification"] },
        assignedTo: { $exists: false },
      }),
    ]);

    res.json({
      total: pendingCount,
      unassigned: unassignedCount,
      hasNew: pendingCount > 0,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getAdminsForAssignment = async (req, res) => {
  try {
    const admins = await Admin.find({
      status: "active",
      $or: [
        { label: "super_admin" },
        { "permissions.validateRecruiters": true },
      ],
    })
      .populate("userId", "nom email")
      .select("userId label");

    const adminList = admins.map((a) => ({
      _id: a._id,
      name: a.userId?.nom,
      email: a.userId?.email,
      label: a.label,
    }));

    res.json(adminList);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\anemOfferController.js ===
import AnemOffer from "../models/AnemOffer.js";
import AnemRegistration from "../models/AnemRegistration.js";
import Offer from "../models/Offer.js";
import Recruiter from "../models/Recruiter.js";


export const checkAnemEligibility = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    const offerCount = await Offer.countDocuments({
      recruteurId: recruiter._id,
    });

    const isFirstOffer = offerCount === 0;
    const isAnemRegistered = recruiter.canCreateAnemOffer();
    const hasSeenModal = recruiter.anem.hasSeenAnemModal;
    const declinedAnem = recruiter.anem.declinedAnem;
    const currentStatus = recruiter.anem.status;

    
    let showModal = false;
    let modalType = null;

    
    if (isFirstOffer && !hasSeenModal) {
      showModal = true;
      modalType = "first_offer";
    }

    res.json({
      
      isFirstOffer,
      offerCount,

      
      isAnemRegistered,
      anemId: recruiter.anem.anemId,
      anemStatus: currentStatus,

      
      hasSeenModal,
      declinedAnem,
      showModal,
      modalType,

      
      canEnableAnem: isAnemRegistered,
      canToggleAnem: isAnemRegistered, 
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const createAnemOffer = async (
  offerId,
  recruiterId,
  anemRegistrationId,
  anemId,
) => {
  try {
    const anemOffer = new AnemOffer({
      offerId,
      recruiterId,
      anemRegistrationId,
      anemEnabled: true,
      anemId,
      enabledAt: new Date(),
    });

    await anemOffer.save();
    return anemOffer;
  } catch (err) {
    console.error("Error creating ANEM offer:", err);
    throw err;
  }
};


export const enableAnemForOffer = async (req, res) => {
  try {
    const { offerId } = req.params;

    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    if (!recruiter.canCreateAnemOffer()) {
      return res.status(403).json({
        msg: "Vous devez Ãªtre enregistrÃ© ANEM pour activer cette fonctionnalitÃ©",
        anemStatus: recruiter.anem.status,
        needsRegistration: true,
      });
    }

    const offer = await Offer.findOne({
      _id: offerId,
      recruteurId: recruiter._id,
    });

    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    
    let anemOffer = await AnemOffer.findOne({ offerId });

    if (anemOffer) {
      if (anemOffer.anemEnabled) {
        return res
          .status(400)
          .json({ msg: "ANEM dÃ©jÃ  activÃ© pour cette offre" });
      }

      anemOffer.anemEnabled = true;
      anemOffer.anemId = recruiter.anem.anemId;
      anemOffer.enabledAt = new Date();
      anemOffer.disabledAt = undefined;
    } else {
      anemOffer = new AnemOffer({
        offerId,
        recruiterId: recruiter._id,
        anemRegistrationId: recruiter.anem.registrationId,
        anemEnabled: true,
        anemId: recruiter.anem.anemId,
        enabledAt: new Date(),
      });
    }

    await anemOffer.save();

    res.json({
      msg: "ANEM activÃ© pour cette offre",
      anemEnabled: true,
      anemId: anemOffer.anemId,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const disableAnemForOffer = async (req, res) => {
  try {
    const { offerId } = req.params;

    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    const offer = await Offer.findOne({
      _id: offerId,
      recruteurId: recruiter._id,
    });

    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    const anemOffer = await AnemOffer.findOne({ offerId });

    if (!anemOffer || !anemOffer.anemEnabled) {
      return res
        .status(400)
        .json({ msg: "ANEM n'est pas activÃ© pour cette offre" });
    }

    anemOffer.anemEnabled = false;
    anemOffer.disabledAt = new Date();
    await anemOffer.save();

    res.json({
      msg: "ANEM dÃ©sactivÃ© pour cette offre",
      anemEnabled: false,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getOfferAnemStatus = async (req, res) => {
  try {
    const { offerId } = req.params;

    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    const offer = await Offer.findOne({
      _id: offerId,
      recruteurId: recruiter._id,
    });

    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    const anemOffer = await AnemOffer.findOne({ offerId }).lean();

    res.json({
      hasAnem: anemOffer?.anemEnabled || false,
      anemEnabled: anemOffer?.anemEnabled || false,
      anemId: anemOffer?.anemId,
      enabledAt: anemOffer?.enabledAt,
      
      submittedToAnem: anemOffer?.submittedToAnem || false,
      anemReference: anemOffer?.anemReference,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getRecruiterAnemOffers = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    const offers = await Offer.find({ recruteurId: recruiter._id })
      .select("_id titre actif validationStatus datePublication")
      .lean();

    const offerIds = offers.map((o) => o._id);
    const anemOffers = await AnemOffer.find({
      offerId: { $in: offerIds },
    }).lean();
    const anemMap = new Map(anemOffers.map((a) => [a.offerId.toString(), a]));

    const enriched = offers.map((offer) => {
      const anem = anemMap.get(offer._id.toString());
      return {
        ...offer,
        anem: anem
          ? {
              enabled: anem.anemEnabled,
              anemId: anem.anemId,
              enabledAt: anem.enabledAt,
            }
          : null,
      };
    });

    res.json(enriched);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\announcementController.js ===
import Announcement from "../models/Announcement.js";
import User from "../models/User.js";
import Admin from "../models/Admin.js";
import { logAdminAction } from "../models/AdminLog.js";

export const createAnnouncement = async (req, res) => {
  try {
    const {
      title,
      content,
      targetAudience,
      status,
      publishAt,
      expiresAt,
      priority,
      displayType,
    } = req.body;

    let finalStatus = status || "draft";
    if (
      status === "published" &&
      publishAt &&
      new Date(publishAt) > new Date()
    ) {
      finalStatus = "scheduled";
    }

    const announcement = await Announcement.create({
      title,
      content,
      targetAudience: targetAudience || "all",
      status: finalStatus,
      publishAt: publishAt ? new Date(publishAt) : null,
      expiresAt: expiresAt ? new Date(expiresAt) : null,
      priority: priority || "normal",
      displayType: displayType || "inline",
      createdBy: req.user.id,
    });

    await logAdminAction(
      req.user.id,
      "announcement_created",
      { type: "announcement", id: announcement._id },
      { title },
      req
    );

    res.status(201).json({ msg: "Annonce crÃ©Ã©e âœ…", announcement });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getAllAnnouncements = async (req, res) => {
  try {
    const { status, targetAudience, page = 1, limit = 20 } = req.query;

    let query = {};
    if (status) query.status = status;
    if (targetAudience) query.targetAudience = targetAudience;

    const announcements = await Announcement.find(query)
      .populate("createdBy", "nom email")
      .sort({ createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await Announcement.countDocuments(query);

    res.json({
      data: announcements,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getActiveAnnouncements = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    const now = new Date();

    let audienceFilter = ["all"];
    if (user.role === "admin") audienceFilter.push("admins");
    if (user.role === "recruteur") audienceFilter.push("recruiters");
    if (user.role === "candidat") audienceFilter.push("candidates");

    const announcements = await Announcement.find({
      status: "published",
      targetAudience: { $in: audienceFilter },
      $or: [{ publishAt: null }, { publishAt: { $lte: now } }],
      dismissedBy: { $ne: req.user.id },
    })
      .and([
        {
          $or: [{ expiresAt: null }, { expiresAt: { $gt: now } }],
        },
      ])
      .sort({ priority: -1, createdAt: -1 });

    res.json(announcements);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAnnouncement = async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;

    const announcement = await Announcement.findByIdAndUpdate(
      id,
      {
        ...updates,
        updatedBy: req.user.id,
      },
      { new: true }
    );

    if (!announcement) {
      return res.status(404).json({ msg: "Annonce introuvable" });
    }

    await logAdminAction(
      req.user.id,
      "announcement_updated",
      { type: "announcement", id: announcement._id },
      { updates },
      req
    );

    res.json({ msg: "Annonce mise Ã  jour âœ…", announcement });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteAnnouncement = async (req, res) => {
  try {
    const { id } = req.params;

    const announcement = await Announcement.findByIdAndDelete(id);
    if (!announcement) {
      return res.status(404).json({ msg: "Annonce introuvable" });
    }

    await logAdminAction(
      req.user.id,
      "announcement_deleted",
      { type: "announcement", id },
      { title: announcement.title },
      req
    );

    res.json({ msg: "Annonce supprimÃ©e ðŸ—‘ï¸" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const dismissAnnouncement = async (req, res) => {
  try {
    const { announcementId } = req.params;

    await Announcement.findByIdAndUpdate(announcementId, {
      $addToSet: { dismissedBy: req.user.id },
    });

    res.json({ msg: "Annonce masquÃ©e." });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const publishScheduledAnnouncements = async () => {
  const now = new Date();

  const publishedResult = await Announcement.updateMany(
    { status: "scheduled", publishAt: { $lte: now } },
    { $set: { status: "published" } }
  );

  const expiredResult = await Announcement.updateMany(
    { status: "published", expiresAt: { $lte: now } },
    { $set: { status: "expired" } }
  );

  console.log(
    `ðŸ“¢ Annonces publiÃ©es: ${publishedResult.modifiedCount}, expirÃ©es: ${expiredResult.modifiedCount}`
  );
};


=== controllers\authController.js ===
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import User from "../models/User.js";
import Candidate from "../models/Candidate.js";
import Company from "../models/Company.js";
import Recruiter from "../models/Recruiter.js";
import VerificationToken from "../models/VerificationToken.js";
import SystemSettings from "../models/SystemSettings.js";
import {
  sendVerificationEmail,
  sendWelcomeEmail,
} from "../services/emailService.js";

const generateToken = (user) => {
  return jwt.sign(
    {
      id: user._id,
      role: user.role,
      emailVerified: user.emailVerified,
    },
    process.env.JWT_SECRET,
    { expiresIn: "1d" },
  );
};

function getRecruiterStatusMessage(status) {
  const messages = {
    pending_validation:
      "Votre compte est en attente de validation par un administrateur.",
    pending_documents:
      "Des documents vous ont Ã©tÃ© demandÃ©s. Veuillez les fournir.",
    pending_info: "Des informations complÃ©mentaires vous ont Ã©tÃ© demandÃ©es.",
    pending_info_and_documents:
      "Des informations et des documents vous ont Ã©tÃ© demandÃ©s.",
    pending_revalidation: "Vos rÃ©ponses sont en cours d'examen.",
  };
  return messages[status] || "Statut en attente.";
}

export const register = async (req, res) => {
  try {
    const {
      nom,
      email,
      motDePasse,
      role,
      companyId,
      nouveauNomEntreprise,
      nouveauSiteWeb,
    } = req.body;

    const exist = await User.findOne({ email: email.toLowerCase() });
    if (exist) {
      return res.status(400).json({ msg: "Email dÃ©jÃ  utilisÃ©" });
    }

    const hash = await bcrypt.hash(motDePasse, 12);

    const user = await User.create({
      nom,
      email: email.toLowerCase(),
      motDePasse: hash,
      role,
      emailVerified: false,
      accountStatus: "active",
    });

    try {
      if (role === "recruteur") {
        let finalCompanyId;

        if (companyId) {
          const comp = await Company.findById(companyId);
          if (!comp) {
            await User.findByIdAndDelete(user._id);
            return res.status(400).json({ msg: "Entreprise introuvable" });
          }
          finalCompanyId = comp._id;
        } else if (nouveauNomEntreprise) {
          const newComp = await Company.create({
            name: nouveauNomEntreprise,
            website: nouveauSiteWeb,
            status: "pending",
          });
          finalCompanyId = newComp._id;
        } else {
          await User.findByIdAndDelete(user._id);
          return res.status(400).json({
            msg: "Vous devez sÃ©lectionner ou crÃ©er une entreprise.",
          });
        }

        await Recruiter.create({
          userId: user._id,
          companyId: finalCompanyId,
          position: "Recruteur",
          status: "pending_validation",
          isAdmin: !companyId,
        });
      } else if (role === "candidat") {
        await Candidate.create({ userId: user._id });
      }

      
      const verificationMode = await SystemSettings.getSetting(
        "email_verification_mode",
        "development",
      );

      console.log(
        `ðŸ“§ Registration - Email verification mode: ${verificationMode}`,
      );

      if (verificationMode === "smtp") {
        try {
          const { code } = await VerificationToken.createVerificationToken(
            user._id,
            "email_verification",
            15,
          );
          
          console.log(`ðŸ“§ Sending verification email to ${user.email}`);
          await sendVerificationEmail(user.email, code, user.nom);
          console.log(`âœ… Verification email sent successfully`);
        } catch (emailError) {
          console.error("âŒ Failed to send verification email:", emailError);
          
          
        }
      } else {
        console.log(
          `ðŸ“¨ [DEV MODE] User Registered: ${user.email}. Use code: 123456`,
        );
      }

      const token = generateToken(user);

      res.status(201).json({
        msg: "Inscription rÃ©ussie. VÃ©rifiez votre email.",
        token,
        user: {
          id: user._id,
          email: user.email,
          role: user.role,
          emailVerified: false,
        },
        needsEmailVerification: true,
      });
    } catch (err) {
      await User.findByIdAndDelete(user._id);
      throw err;
    }
  } catch (err) {
    console.error("Registration error:", err);
    res.status(500).json({ msg: err.message });
  }
};

export const login = async (req, res) => {
  try {
    const { email, motDePasse } = req.body;

    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur non trouvÃ©" });
    }

    const ok = await bcrypt.compare(motDePasse, user.motDePasse);
    if (!ok) {
      return res.status(401).json({ msg: "Mot de passe incorrect" });
    }

    if (!user.canLogin()) {
      if (user.accountStatus === "banned") {
        return res.status(403).json({
          msg: "Votre compte a Ã©tÃ© banni. Veuillez contacter l'administrateur.",
          code: "ACCOUNT_BANNED",
        });
      }
      if (user.accountStatus === "suspended") {
        return res.status(403).json({
          msg: `Votre compte est suspendu${
            user.suspendedUntil
              ? ` jusqu'au ${user.suspendedUntil.toLocaleDateString("fr-FR")}`
              : ""
          }.`,
          code: "ACCOUNT_SUSPENDED",
          reason: user.suspensionReason,
        });
      }
    }

    if (user.role === "recruteur") {
      if (!user.emailVerified) {
        return res.status(403).json({
          msg: "Veuillez confirmer votre email avant de vous connecter.",
          code: "EMAIL_NOT_VERIFIED",
          needEmailVerification: true,
        });
      }

      const recruiter = await Recruiter.findOne({ userId: user._id });
      if (recruiter) {
        if (recruiter.status === "rejected") {
          return res.status(403).json({
            msg: "Votre compte recruteur a Ã©tÃ© refusÃ©.",
            code: "RECRUITER_REJECTED",
            reason: recruiter.rejectionReason,
          });
        }

        if (recruiter.status !== "validated") {
          const token = generateToken(user);
          user.derniereConnexion = new Date();
          await user.save();

          return res.json({
            msg: "Connexion rÃ©ussie (accÃ¨s limitÃ©)",
            token,
            user: {
              id: user._id,
              nom: user.nom,
              email: user.email,
              role: user.role,
              emailVerified: user.emailVerified,
            },
            recruiterStatus: recruiter.status,
            limitedAccess: true,
            statusMessage: getRecruiterStatusMessage(recruiter.status),
          });
        }
      }
    }

    const token = generateToken(user);
    user.derniereConnexion = new Date();
    await user.save();

    res.json({
      msg: "Connexion rÃ©ussie âœ…",
      token,
      user: {
        id: user._id,
        nom: user.nom,
        email: user.email,
        role: user.role,
        emailVerified: user.emailVerified,
      },
      needsEmailVerification: !user.emailVerified,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const resendConfirmationCode = async (req, res) => {
  try {
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable" });
    }

    if (user.emailVerified) {
      return res.status(400).json({ msg: "Email dÃ©jÃ  vÃ©rifiÃ©" });
    }

    const verificationMode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );

    console.log(
      `ðŸ“§ Resend code - Email verification mode: ${verificationMode}`,
    );

    if (verificationMode === "smtp") {
      try {
        const { code, expiresAt } =
          await VerificationToken.createVerificationToken(
            user._id,
            "email_verification",
            15,
          );

        console.log(
          `ðŸ“§ Sending new verification code to ${user.email}: ${code}`,
        );
        await sendVerificationEmail(user.email, code, user.nom);

        res.json({
          msg: "Code de confirmation envoyÃ© ðŸ“¨",
          expiresAt,
        });
      } catch (emailError) {
        console.error("âŒ Failed to send verification email:", emailError);
        res.status(500).json({
          msg: "Erreur lors de l'envoi de l'email. Veuillez rÃ©essayer.",
          error:
            process.env.NODE_ENV !== "production"
              ? emailError.message
              : undefined,
        });
      }
    } else {
      console.log(
        `ðŸ“¨ [DEV MODE] Code de confirmation pour ${user.email}: 123456`,
      );
      res.json({
        msg: "Code de confirmation envoyÃ© (Mode dÃ©veloppement: utilisez 123456) ðŸ“¨",
      });
    }
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const verifyEmail = async (req, res) => {
  try {
    const { code } = req.body;
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable" });
    }

    if (user.emailVerified) {
      return res.status(400).json({ msg: "Email dÃ©jÃ  vÃ©rifiÃ©" });
    }

    const verificationMode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );

    console.log(
      `ðŸ“§ Verify email - Mode: ${verificationMode}, Code received: ${code}`,
    );

    let isValid = false;

    if (verificationMode === "development") {
      isValid = code === "123456";
      if (!isValid) {
        return res.status(400).json({
          msg: "Code incorrect. Utilisez 123456 en mode dÃ©veloppement.",
        });
      }
    } else {
      const result = await VerificationToken.verifyCode(
        userId,
        code,
        "email_verification",
      );

      if (!result.valid) {
        return res.status(400).json({
          msg: result.error,
          attemptsRemaining: result.attemptsRemaining,
        });
      }
      isValid = true;
    }

    if (isValid) {
      user.emailVerified = true;
      await user.save();

      
      try {
        await sendWelcomeEmail(user.email, user.nom);
      } catch (emailErr) {
        console.error("Failed to send welcome email:", emailErr);
      }

      const newToken = generateToken(user);

      return res.json({
        msg: "E-mail confirmÃ© avec succÃ¨s ! ðŸŽ‰",
        token: newToken,
        user: {
          id: user._id,
          nom: user.nom,
          email: user.email,
          role: user.role,
          emailVerified: true,
        },
      });
    }
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const changeEmail = async (req, res) => {
  try {
    const { newEmail } = req.body;
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable" });
    }

    if (user.emailVerified) {
      return res.status(400).json({
        msg: "Impossible de changer l'email car il est dÃ©jÃ  vÃ©rifiÃ©.",
      });
    }

    const normalizedEmail = newEmail.toLowerCase();
    const exist = await User.findOne({
      email: normalizedEmail,
      _id: { $ne: userId },
    });
    if (exist) {
      return res.status(400).json({ msg: "Cet email est dÃ©jÃ  utilisÃ©." });
    }

    user.email = normalizedEmail;
    await user.save();

    await VerificationToken.deleteMany({ userId, type: "email_verification" });

    res.json({
      msg: `Email mis Ã  jour vers ${normalizedEmail}. Veuillez confirmer ce nouvel email.`,
      email: normalizedEmail,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanies = async (req, res) => {
  try {
    const companies = await Company.find({ status: "active" })
      .select("_id name")
      .sort({ name: 1 })
      .lean();

    res.json(companies);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export default {
  register,
  login,
  verifyEmail,
  resendConfirmationCode,
  changeEmail,
  getCompanies,
};


=== controllers\candidateAnemController.js ===
import CandidateAnemRegistration from "../models/CandidateAnemRegistration.js";
import Candidate from "../models/Candidate.js";
import User from "../models/User.js";
import Admin from "../models/Admin.js";
import Notification from "../models/Notification.js";
import { logAdminAction } from "../models/AdminLog.js";



const syncCandidateAnemStatus = async (candidateId, registration) => {
  const updateData = {
    "anem.status": registration.status,
    "anem.lastStatusUpdate": new Date(),
    "anem.registrationId": registration._id,
  };

  if (registration.status === "registered" && registration.verifiedAnemId) {
    updateData["anem.anemId"] = registration.verifiedAnemId;
    updateData["anem.registeredAt"] = registration.verifiedAt || new Date();
  }

  await Candidate.findByIdAndUpdate(candidateId, updateData);
};

const notifyAdminsNewCandidateDemande = async (
  registration,
  candidateName,
  type,
) => {
  const admins = await Admin.find({
    status: "active",
    $or: [{ label: "super_admin" }, { "permissions.validateRecruiters": true }],
  }).populate("userId", "_id");

  const message =
    type === "self_declared"
      ? `Nouvel ID ANEM candidat Ã  vÃ©rifier de ${candidateName}`
      : `Nouvelle demande d'inscription ANEM candidat de ${candidateName}`;

  const notifPromises = admins.map((admin) =>
    Notification.create({
      userId: admin.userId._id,
      message,
      type: "info",
    }),
  );

  await Promise.all(notifPromises);
};



export const getCandidateAnemStatus = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    let registration = null;
    let latestPublicNote = null;

    if (candidate.anem.registrationId) {
      registration = await CandidateAnemRegistration.findById(
        candidate.anem.registrationId,
      )
        .select("-auditLog")
        .populate("adminNotes.createdBy", "nom")
        .lean();

      if (registration) {
        const publicNotes = registration.adminNotes
          ?.filter((n) => n.isPublic)
          .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

        latestPublicNote = publicNotes?.[0] || null;
      }
    }

    let sidebarView = "not_started";
    let actionRequired = false;
    let statusMessage = "";

    switch (candidate.anem.status) {
      case "not_started":
        sidebarView = "intro";
        statusMessage = "Vous n'Ãªtes pas encore inscrit Ã  l'ANEM";
        break;
      case "draft":
        sidebarView = "continue_form";
        actionRequired = true;
        statusMessage = "Inscription en cours - Continuez votre formulaire";
        break;
      case "pending":
        sidebarView = "pending";
        statusMessage = "Votre demande est en attente de traitement";
        break;
      case "pending_verification":
        sidebarView = "pending_verification";
        statusMessage = "Votre ID ANEM est en cours de vÃ©rification";
        break;
      case "in_progress":
        sidebarView = "in_progress";
        statusMessage =
          "Votre inscription est en cours de traitement par notre Ã©quipe";
        break;
      case "registered":
        sidebarView = "registered";
        statusMessage = `Vous Ãªtes inscrit Ã  l'ANEM (ID: ${candidate.anem.anemId})`;
        break;
      case "failed":
        sidebarView = "failed";
        actionRequired = true;
        statusMessage = "Votre inscription a Ã©chouÃ© - Vous pouvez rÃ©essayer";
        break;
      case "rejected":
        sidebarView = "rejected";
        actionRequired = true;
        statusMessage =
          "Votre ID ANEM a Ã©tÃ© rejetÃ© - Vous pouvez soumettre un nouvel ID";
        break;
    }

    res.json({
      status: candidate.anem.status,
      anemId: candidate.anem.anemId,
      registeredAt: candidate.anem.registeredAt,
      hasSeenAnemInfo: candidate.anem.hasSeenAnemInfo,
      declinedAnem: candidate.anem.declinedAnem,

      sidebarView,
      actionRequired,
      statusMessage,
      latestPublicNote: latestPublicNote
        ? {
            content: latestPublicNote.content,
            createdAt: latestPublicNote.createdAt,
            adminName: latestPublicNote.createdBy?.nom,
          }
        : null,

      registration: registration
        ? {
            _id: registration._id,
            registrationType: registration.registrationType,
            status: registration.status,
            currentStep: registration.currentStep,
            formCompleted: registration.formCompleted,
            formSubmittedAt: registration.formSubmittedAt,
            failureReason: registration.failureReason,
            rejectionReason: registration.rejectionReason,
            declaredAnemId: registration.declaredAnemId,
            verifiedAnemId: registration.verifiedAnemId,
            createdAt: registration.createdAt,
            updatedAt: registration.updatedAt,
            lastRejectedId:
              registration.anemIdHistory?.find((h) => h.status === "rejected")
                ?.anemId || null,
          }
        : null,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const markAnemInfoSeen = async (req, res) => {
  try {
    const candidate = await Candidate.findOneAndUpdate(
      { userId: req.user.id },
      { "anem.hasSeenAnemInfo": true },
      { new: true },
    );

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    res.json({ msg: "Information ANEM marquÃ©e comme vue" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const declineCandidateAnem = async (req, res) => {
  try {
    const candidate = await Candidate.findOneAndUpdate(
      { userId: req.user.id },
      {
        "anem.hasSeenAnemInfo": true,
        "anem.declinedAnem": true,
        "anem.declinedAt": new Date(),
      },
      { new: true },
    );

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    res.json({
      msg: "Vous avez choisi de ne pas vous inscrire Ã  l'ANEM pour le moment",
      declinedAnem: true,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const resetCandidateAnemDecline = async (req, res) => {
  try {
    const candidate = await Candidate.findOneAndUpdate(
      { userId: req.user.id },
      {
        "anem.declinedAnem": false,
        "anem.declinedAt": null,
      },
      { new: true },
    );

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    res.json({
      msg: "Vous pouvez maintenant vous inscrire Ã  l'ANEM",
      declinedAnem: false,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const submitCandidateAnemId = async (req, res) => {
  try {
    const { anemId } = req.body;

    if (!anemId || anemId.trim().length < 3) {
      return res.status(400).json({ msg: "ID ANEM invalide" });
    }

    const candidate = await Candidate.findOne({ userId: req.user.id });
    const user = await User.findById(req.user.id);

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    if (!user.emailVerified) {
      return res.status(403).json({
        msg: "Veuillez vÃ©rifier votre email avant de soumettre un ID ANEM",
        code: "EMAIL_NOT_VERIFIED",
      });
    }

    if (candidate.anem.status === "registered") {
      return res.status(400).json({
        msg: "Vous Ãªtes dÃ©jÃ  enregistrÃ© ANEM",
        anemId: candidate.anem.anemId,
      });
    }

    let registration = await CandidateAnemRegistration.findOne({
      candidateId: candidate._id,
    });

    const trimmedId = anemId.trim().toUpperCase();

    if (!registration) {
      registration = new CandidateAnemRegistration({
        candidateId: candidate._id,
        userId: req.user.id,
        registrationType: "self_declared",
        declaredAnemId: trimmedId,
        declaredAt: new Date(),
        status: "pending_verification",
        anemIdHistory: [
          {
            anemId: trimmedId,
            submittedAt: new Date(),
            status: "pending",
          },
        ],
      });

      registration.addAuditEntry(
        "created",
        req.user.id,
        { newValue: { registrationType: "self_declared", anemId: trimmedId } },
        req,
      );
    } else {
      const previousId = registration.declaredAnemId;

      const lastHistory =
        registration.anemIdHistory[registration.anemIdHistory.length - 1];
      if (
        !lastHistory ||
        lastHistory.anemId !== trimmedId ||
        lastHistory.status === "rejected"
      ) {
        registration.anemIdHistory.push({
          anemId: trimmedId,
          submittedAt: new Date(),
          status: "pending",
        });
      }

      registration.registrationType = "self_declared";
      registration.declaredAnemId = trimmedId;
      registration.declaredAt = new Date();
      registration.status = "pending_verification";
      registration.rejectionReason = undefined;

      registration.addAuditEntry(
        "anem_id_updated",
        req.user.id,
        { previousValue: previousId, newValue: trimmedId },
        req,
      );
    }

    await registration.save();
    await syncCandidateAnemStatus(candidate._id, registration);

    await Candidate.findByIdAndUpdate(candidate._id, {
      "anem.hasSeenAnemInfo": true,
    });

    await notifyAdminsNewCandidateDemande(
      registration,
      user.nom,
      "self_declared",
    );

    res.status(201).json({
      msg: "ID ANEM soumis pour vÃ©rification. Vous serez notifiÃ© du rÃ©sultat.",
      status: "pending_verification",
      registrationId: registration._id,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const startCandidateRegistration = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const user = await User.findById(req.user.id);

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    if (!user.emailVerified) {
      return res.status(403).json({
        msg: "Veuillez vÃ©rifier votre email avant de vous inscrire Ã  l'ANEM",
        code: "EMAIL_NOT_VERIFIED",
      });
    }

    if (candidate.anem.status === "registered") {
      return res.status(400).json({
        msg: "Vous Ãªtes dÃ©jÃ  enregistrÃ© ANEM",
        anemId: candidate.anem.anemId,
      });
    }

    let registration = await CandidateAnemRegistration.findOne({
      candidateId: candidate._id,
    });

    
    const nameParts = user.nom ? user.nom.split(" ") : [];
    const prenom = nameParts[0] || "";
    const nom = nameParts.slice(1).join(" ") || "";

    const prefillStep1 = {
      civilite:
        candidate.gender === "homme"
          ? "monsieur"
          : candidate.gender === "femme"
            ? "madame"
            : undefined,
      nom: nom || undefined,
      prenom: prenom || undefined,
      dateNaissance: candidate.dateOfBirth || undefined,
    };

    const prefillStep2 = {
      mobile: candidate.telephone || undefined,
      wilayaResidence: candidate.residence?.wilaya || undefined,
      communeResidence: candidate.residence?.commune || undefined,
      adresse: candidate.residence?.address || undefined,
    };

    const prefillStep4 = {
      email: user.email,
    };

    if (registration) {
      if (["failed", "rejected"].includes(registration.status)) {
        registration.registrationType = "site_registration";
        registration.status = "draft";
        registration.currentStep = 1;
        registration.formCompleted = false;
        registration.failureReason = undefined;
        registration.rejectionReason = undefined;

        registration.addAuditEntry(
          "created",
          req.user.id,
          { newValue: { action: "restart_after_failure" } },
          req,
        );

        await registration.save();
      } else if (registration.registrationType === "self_declared") {
        registration.registrationType = "site_registration";
        registration.status = "draft";
        registration.currentStep = 1;
        registration.formCompleted = false;

        
        if (!registration.step1?.nom) {
          registration.step1 = { ...registration.step1, ...prefillStep1 };
        }
        if (!registration.step2?.mobile) {
          registration.step2 = { ...registration.step2, ...prefillStep2 };
        }
        if (!registration.step4?.email) {
          registration.step4 = { ...registration.step4, ...prefillStep4 };
        }

        registration.addAuditEntry(
          "created",
          req.user.id,
          { newValue: { action: "convert_to_site_registration" } },
          req,
        );

        await registration.save();
      }
      
    } else {
      registration = new CandidateAnemRegistration({
        candidateId: candidate._id,
        userId: req.user.id,
        registrationType: "site_registration",
        status: "draft",
        currentStep: 1,
        step1: prefillStep1,
        step2: prefillStep2,
        step4: prefillStep4,
      });

      registration.addAuditEntry(
        "created",
        req.user.id,
        { newValue: { registrationType: "site_registration" } },
        req,
      );

      await registration.save();
    }

    await syncCandidateAnemStatus(candidate._id, registration);

    await Candidate.findByIdAndUpdate(candidate._id, {
      "anem.hasSeenAnemInfo": true,
    });

    res.json({
      msg: "Inscription dÃ©marrÃ©e",
      registration: {
        _id: registration._id,
        currentStep: registration.currentStep,
        formCompleted: registration.formCompleted,
        step1: registration.step1 || {},
        step2: registration.step2 || {},
        step3: registration.step3 || {},
        step4: {
          email: registration.step4?.email || user.email,
          consentementRgpd: registration.step4?.consentementRgpd || false,
        },
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const saveCandidateRegistrationStep = async (req, res) => {
  try {
    const { step, data } = req.body;

    if (!step || step < 1 || step > 4) {
      return res.status(400).json({ msg: "Ã‰tape invalide (1-4)" });
    }

    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    const registration = await CandidateAnemRegistration.findOne({
      candidateId: candidate._id,
      registrationType: "site_registration",
      status: "draft",
    });

    if (!registration) {
      return res.status(404).json({
        msg: "Aucune inscription en cours. Veuillez recommencer.",
        code: "NO_DRAFT_REGISTRATION",
      });
    }

    const stepKey = `step${step}`;
    registration[stepKey] = { ...registration[stepKey], ...data };

    if (
      step === 4 &&
      data.consentementRgpd &&
      !registration.step4?.consentementAt
    ) {
      registration.step4.consentementAt = new Date();
    }

    if (step >= registration.currentStep) {
      registration.currentStep = step;
    }

    registration.addAuditEntry(
      "step_saved",
      req.user.id,
      { newValue: { step } },
      req,
    );

    await registration.save();

    res.json({
      msg: `Ã‰tape ${step} enregistrÃ©e`,
      currentStep: registration.currentStep,
      savedData: registration[stepKey],
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const submitCandidateRegistration = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const user = await User.findById(req.user.id);

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    const registration = await CandidateAnemRegistration.findOne({
      candidateId: candidate._id,
      registrationType: "site_registration",
      status: "draft",
    });

    if (!registration) {
      return res.status(404).json({
        msg: "Aucune inscription en cours trouvÃ©e",
        code: "NO_DRAFT_REGISTRATION",
      });
    }

    
    const validation = {
      step1: { valid: true, missing: [] },
      step2: { valid: true, missing: [] },
      step3: { valid: true, missing: [] },
      step4: { valid: true, missing: [] },
    };

    
    const step1Required = ["nom", "prenom", "dateNaissance", "wilayaNaissance"];
    step1Required.forEach((field) => {
      if (
        !registration.step1?.[field] ||
        registration.step1[field].toString().trim() === ""
      ) {
        validation.step1.valid = false;
        validation.step1.missing.push(field);
      }
    });

    
    const step2Required = ["mobile", "wilayaResidence", "communeResidence"];
    step2Required.forEach((field) => {
      if (
        !registration.step2?.[field] ||
        registration.step2[field].toString().trim() === ""
      ) {
        validation.step2.valid = false;
        validation.step2.missing.push(field);
      }
    });

    
    const step3Required = ["typePieceIdentite", "numeroPieceIdentite"];
    step3Required.forEach((field) => {
      if (
        !registration.step3?.[field] ||
        registration.step3[field].toString().trim() === ""
      ) {
        validation.step3.valid = false;
        validation.step3.missing.push(field);
      }
    });

    
    if (!registration.step4?.email || registration.step4.email.trim() === "") {
      validation.step4.valid = false;
      validation.step4.missing.push("email");
    }
    if (!registration.step4?.consentementRgpd) {
      validation.step4.valid = false;
      validation.step4.missing.push("consentementRgpd");
    }

    const allValid = Object.values(validation).every((v) => v.valid);

    if (!allValid) {
      return res.status(400).json({
        msg: "Veuillez complÃ©ter tous les champs obligatoires",
        validation,
      });
    }

    registration.formCompleted = true;
    registration.formCompletedAt = new Date();
    registration.formSubmittedAt = new Date();
    registration.status = "pending";
    registration.currentStep = 4;

    registration.addAuditEntry(
      "form_submitted",
      req.user.id,
      { newValue: { status: "pending" } },
      req,
    );

    await registration.save();
    await syncCandidateAnemStatus(candidate._id, registration);

    await notifyAdminsNewCandidateDemande(
      registration,
      user.nom,
      "site_registration",
    );

    res.json({
      msg: "Votre demande d'inscription ANEM a Ã©tÃ© soumise avec succÃ¨s. Vous serez notifiÃ© du rÃ©sultat.",
      status: "pending",
      registrationId: registration._id,
      submittedAt: registration.formSubmittedAt,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateRegistrationForm = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    const registration = await CandidateAnemRegistration.findOne({
      candidateId: candidate._id,
    })
      .select("-auditLog")
      .populate("adminNotes.createdBy", "nom");

    if (!registration) {
      return res.status(404).json({
        msg: "Aucune inscription trouvÃ©e",
        code: "NO_REGISTRATION",
      });
    }

    const user = await User.findById(req.user.id);

    res.json({
      registration: {
        _id: registration._id,
        registrationType: registration.registrationType,
        status: registration.status,
        currentStep: registration.currentStep,
        formCompleted: registration.formCompleted,
        formSubmittedAt: registration.formSubmittedAt,

        step1: registration.step1 || {},
        step2: registration.step2 || {},
        step3: registration.step3 || {},
        step4: {
          email: registration.step4?.email || user.email,
          consentementRgpd: registration.step4?.consentementRgpd || false,
          consentementAt: registration.step4?.consentementAt,
        },

        declaredAnemId: registration.declaredAnemId,
        verifiedAnemId: registration.verifiedAnemId,

        failureReason: registration.failureReason,
        rejectionReason: registration.rejectionReason,

        publicNotes: registration.adminNotes
          ?.filter((n) => n.isPublic)
          .map((n) => ({
            content: n.content,
            createdAt: n.createdAt,
            adminName: n.createdBy?.nom,
          }))
          .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)),

        anemIdHistory: registration.anemIdHistory?.map((h) => ({
          anemId: h.anemId,
          submittedAt: h.submittedAt,
          status: h.status,
          rejectionReason: h.rejectionReason,
        })),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const getCandidateAnemDemandes = async (req, res) => {
  try {
    const {
      status,
      registrationType,
      wilaya,
      search,
      assignedTo,
      unassigned,
      dateFrom,
      dateTo,
      sortBy = "createdAt",
      sortOrder = "desc",
      page = 1,
      limit = 20,
    } = req.query;

    let query = { status: { $ne: "draft" } };

    if (status) {
      if (status === "new") {
        query.status = { $in: ["pending", "pending_verification"] };
      } else if (status === "active") {
        query.status = {
          $in: ["pending", "pending_verification", "in_progress"],
        };
      } else {
        query.status = status;
      }
    }

    if (registrationType) {
      query.registrationType = registrationType;
    }

    if (wilaya) {
      query["step2.wilayaResidence"] = { $regex: new RegExp(wilaya, "i") };
    }

    if (assignedTo) {
      query.assignedTo = assignedTo;
    }
    if (unassigned === "true") {
      query.assignedTo = { $exists: false };
    }

    if (dateFrom || dateTo) {
      query.createdAt = {};
      if (dateFrom) query.createdAt.$gte = new Date(dateFrom);
      if (dateTo) {
        const endDate = new Date(dateTo);
        endDate.setHours(23, 59, 59, 999);
        query.createdAt.$lte = endDate;
      }
    }

    if (search) {
      const searchRegex = { $regex: search, $options: "i" };
      const matchingUsers = await User.find({
        $or: [{ nom: searchRegex }, { email: searchRegex }],
      }).select("_id");
      const userIds = matchingUsers.map((u) => u._id);

      query.$or = [
        { userId: { $in: userIds } },
        { "step1.nom": searchRegex },
        { "step1.prenom": searchRegex },
        { declaredAnemId: searchRegex },
        { verifiedAnemId: searchRegex },
      ];
    }

    const skip = (page - 1) * limit;
    const sort = { [sortBy]: sortOrder === "desc" ? -1 : 1 };

    const [demandes, total, statusCounts] = await Promise.all([
      CandidateAnemRegistration.find(query)
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit))
        .populate("userId", "nom email")
        .populate("candidateId", "telephone residence profilePicture")
        .populate("assignedTo", "userId label")
        .lean(),
      CandidateAnemRegistration.countDocuments(query),
      CandidateAnemRegistration.aggregate([
        { $match: { status: { $ne: "draft" } } },
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),
    ]);

    const enrichedDemandes = await Promise.all(
      demandes.map(async (d) => {
        let assignedAdminName = null;
        if (d.assignedTo?.userId) {
          const adminUser = await User.findById(d.assignedTo.userId).select(
            "nom",
          );
          assignedAdminName = adminUser?.nom;
        }

        return {
          _id: d._id,
          registrationType: d.registrationType,
          status: d.status,
          currentStep: d.currentStep,
          formCompleted: d.formCompleted,
          formSubmittedAt: d.formSubmittedAt,
          declaredAnemId: d.declaredAnemId,
          verifiedAnemId: d.verifiedAnemId,

          candidate: {
            _id: d.candidateId?._id,
            nom: d.userId?.nom,
            email: d.userId?.email,
            telephone: d.candidateId?.telephone,
            profilePicture: d.candidateId?.profilePicture,
          },

          wilaya: d.step2?.wilayaResidence,
          nomComplet: `${d.step1?.prenom || ""} ${d.step1?.nom || ""}`.trim(),

          assignedTo: d.assignedTo
            ? {
                _id: d.assignedTo._id,
                name: assignedAdminName,
                label: d.assignedTo.label,
              }
            : null,
          assignedAt: d.assignedAt,

          pdfDownloadCount: d.pdfDownloads?.length || 0,
          lastPdfDownload: d.pdfDownloads?.slice(-1)[0]?.downloadedAt,

          failureReason: d.failureReason,
          rejectionReason: d.rejectionReason,
          createdAt: d.createdAt,
          updatedAt: d.updatedAt,
        };
      }),
    );

    const countsMap = {};
    statusCounts.forEach((s) => {
      countsMap[s._id] = s.count;
    });

    res.json({
      data: enrichedDemandes,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
      statusCounts: countsMap,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateDemandeDetails = async (req, res) => {
  try {
    const { demandeId } = req.params;

    const demande = await CandidateAnemRegistration.findById(demandeId)
      .populate("userId", "nom email createdAt")
      .populate(
        "candidateId",
        "telephone residence profilePicture gender dateOfBirth bio skills experiences education",
      )
      .populate("assignedTo", "userId label")
      .populate("verifiedBy", "nom")
      .populate("assignedBy", "nom")
      .populate("adminNotes.createdBy", "nom")
      .populate("auditLog.performedBy", "nom")
      .populate("anemIdHistory.reviewedBy", "nom")
      .populate("pdfDownloads.downloadedBy", "nom");

    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    let assignedAdminName = null;
    if (demande.assignedTo?.userId) {
      const adminUser = await User.findById(demande.assignedTo.userId).select(
        "nom",
      );
      assignedAdminName = adminUser?.nom;
    }

    await logAdminAction(
      req.user.id,
      "candidate_anem_demande_viewed",
      { type: "candidate_anem_registration", id: demande._id },
      {},
      req,
    );

    res.json({
      ...demande.toObject(),
      assignedAdminName,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidatePendingAnemIds = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      sortBy = "declaredAt",
      sortOrder = "desc",
    } = req.query;
    const skip = (page - 1) * limit;
    const sort = { [sortBy]: sortOrder === "desc" ? -1 : 1 };

    const [demandes, total] = await Promise.all([
      CandidateAnemRegistration.find({
        registrationType: "self_declared",
        status: "pending_verification",
      })
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit))
        .populate("userId", "nom email")
        .populate("candidateId", "telephone profilePicture")
        .lean(),
      CandidateAnemRegistration.countDocuments({
        registrationType: "self_declared",
        status: "pending_verification",
      }),
    ]);

    const enriched = demandes.map((d) => ({
      _id: d._id,
      declaredAnemId: d.declaredAnemId,
      declaredAt: d.declaredAt,
      candidate: {
        _id: d.candidateId?._id,
        nom: d.userId?.nom,
        email: d.userId?.email,
        profilePicture: d.candidateId?.profilePicture,
      },
      previousSubmissions: d.anemIdHistory
        ?.filter((h) => h.status === "rejected")
        .map((h) => ({
          anemId: h.anemId,
          submittedAt: h.submittedAt,
          rejectionReason: h.rejectionReason,
        })),
      createdAt: d.createdAt,
    }));

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const assignCandidateDemande = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { adminId } = req.body;

    const demande = await CandidateAnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    let targetAdminId = adminId;

    if (!adminId) {
      const selfAdmin = await Admin.findOne({ userId: req.user.id });
      if (!selfAdmin) {
        return res.status(400).json({ msg: "Admin ID requis" });
      }
      targetAdminId = selfAdmin._id;
    }

    const targetAdmin = await Admin.findById(targetAdminId).populate(
      "userId",
      "nom",
    );
    if (!targetAdmin) {
      return res.status(404).json({ msg: "Admin cible introuvable" });
    }

    const previousAssigned = demande.assignedTo;

    demande.assignedTo = targetAdminId;
    demande.assignedAt = new Date();
    demande.assignedBy = req.user.id;

    demande.addAuditEntry(
      "assigned",
      req.user.id,
      { previousValue: previousAssigned, newValue: targetAdminId },
      req,
    );

    await demande.save();

    await logAdminAction(
      req.user.id,
      "candidate_anem_demande_assigned",
      { type: "candidate_anem_registration", id: demande._id },
      { assignedTo: targetAdminId, adminName: targetAdmin.userId.nom },
      req,
    );

    res.json({
      msg: `Demande assignÃ©e Ã  ${targetAdmin.userId.nom}`,
      assignedTo: {
        _id: targetAdmin._id,
        name: targetAdmin.userId.nom,
        label: targetAdmin.label,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const markCandidateDemandeInProgress = async (req, res) => {
  try {
    const { demandeId } = req.params;

    const demande = await CandidateAnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (!["pending", "pending_verification"].includes(demande.status)) {
      return res.status(400).json({
        msg: "Seules les demandes en attente peuvent Ãªtre marquÃ©es en cours",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    demande.status = "in_progress";

    if (!demande.assignedTo) {
      const selfAdmin = await Admin.findOne({ userId: req.user.id });
      if (selfAdmin) {
        demande.assignedTo = selfAdmin._id;
        demande.assignedAt = new Date();
        demande.assignedBy = req.user.id;
      }
    }

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      { previousValue: previousStatus, newValue: "in_progress" },
      req,
    );

    await demande.save();
    await syncCandidateAnemStatus(demande.candidateId, demande);

    await Notification.create({
      userId: demande.userId,
      message:
        "Votre demande d'inscription ANEM est en cours de traitement par notre Ã©quipe.",
      type: "info",
    });

    await logAdminAction(
      req.user.id,
      "candidate_anem_demande_in_progress",
      { type: "candidate_anem_registration", id: demande._id },
      { previousStatus },
      req,
    );

    res.json({
      msg: "Demande marquÃ©e en cours de traitement",
      status: "in_progress",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateAnemPdfData = async (req, res) => {
  try {
    const { demandeId } = req.params;

    const demande = await CandidateAnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    demande.pdfDownloads.push({
      downloadedBy: req.user.id,
      downloadedAt: new Date(),
      ip: req.ip || req.connection?.remoteAddress,
    });

    demande.addAuditEntry("pdf_downloaded", req.user.id, {}, req);
    await demande.save();

    const pdfData = await demande.generatePdfData();

    await logAdminAction(
      req.user.id,
      "candidate_anem_pdf_downloaded",
      { type: "candidate_anem_registration", id: demande._id },
      {},
      req,
    );

    res.json(pdfData);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const approveCandidateAnemId = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { comment } = req.body;

    const demande = await CandidateAnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (demande.status !== "pending_verification") {
      return res.status(400).json({
        msg: "Seuls les IDs en attente de vÃ©rification peuvent Ãªtre approuvÃ©s",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    demande.status = "registered";
    demande.verifiedAnemId = demande.declaredAnemId;
    demande.verifiedAt = new Date();
    demande.verifiedBy = req.user.id;

    const lastHistory = demande.anemIdHistory[demande.anemIdHistory.length - 1];
    if (lastHistory && lastHistory.status === "pending") {
      lastHistory.status = "approved";
      lastHistory.reviewedBy = req.user.id;
      lastHistory.reviewedAt = new Date();
      lastHistory.adminComment = comment;
    }

    if (comment) {
      demande.adminNotes.push({
        content: comment,
        createdBy: req.user.id,
        isPublic: true,
      });
    }

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      { previousValue: previousStatus, newValue: "registered" },
      req,
    );

    await demande.save();
    await syncCandidateAnemStatus(demande.candidateId, demande);

    await Notification.create({
      userId: demande.userId,
      message: `FÃ©licitations ! Votre ID ANEM (${demande.verifiedAnemId}) a Ã©tÃ© vÃ©rifiÃ© avec succÃ¨s. Vous Ãªtes maintenant inscrit Ã  l'ANEM.`,
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "candidate_anem_id_approved",
      { type: "candidate_anem_registration", id: demande._id },
      { anemId: demande.verifiedAnemId },
      req,
    );

    res.json({
      msg: "ID ANEM approuvÃ© avec succÃ¨s",
      status: "registered",
      anemId: demande.verifiedAnemId,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const rejectCandidateAnemId = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { reason, publicMessage } = req.body;

    if (!reason || reason.trim().length === 0) {
      return res.status(400).json({ msg: "Raison de rejet requise" });
    }

    const demande = await CandidateAnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (demande.status !== "pending_verification") {
      return res.status(400).json({
        msg: "Seuls les IDs en attente de vÃ©rification peuvent Ãªtre rejetÃ©s",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    demande.status = "rejected";
    demande.rejectionReason = reason;

    const lastHistory = demande.anemIdHistory[demande.anemIdHistory.length - 1];
    if (lastHistory && lastHistory.status === "pending") {
      lastHistory.status = "rejected";
      lastHistory.reviewedBy = req.user.id;
      lastHistory.reviewedAt = new Date();
      lastHistory.rejectionReason = reason;
    }

    demande.adminNotes.push({
      content: publicMessage || `ID ANEM rejetÃ©: ${reason}`,
      createdBy: req.user.id,
      isPublic: true,
    });

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      { previousValue: previousStatus, newValue: "rejected" },
      req,
    );

    await demande.save();
    await syncCandidateAnemStatus(demande.candidateId, demande);

    await Notification.create({
      userId: demande.userId,
      message: `Votre ID ANEM n'a pas pu Ãªtre vÃ©rifiÃ©. Raison: ${reason}. Vous pouvez soumettre un nouvel ID ou vous inscrire via notre formulaire.`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "candidate_anem_id_rejected",
      { type: "candidate_anem_registration", id: demande._id },
      { reason, rejectedId: demande.declaredAnemId },
      req,
    );

    res.json({
      msg: "ID ANEM rejetÃ©",
      status: "rejected",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const markCandidateRegistered = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { anemId, message } = req.body;

    if (!anemId || anemId.trim().length < 3) {
      return res.status(400).json({ msg: "ID ANEM valide requis" });
    }

    const demande = await CandidateAnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (!["pending", "in_progress"].includes(demande.status)) {
      return res.status(400).json({
        msg: "Seules les demandes en attente ou en cours peuvent Ãªtre marquÃ©es comme enregistrÃ©es",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    const trimmedId = anemId.trim().toUpperCase();

    demande.status = "registered";
    demande.verifiedAnemId = trimmedId;
    demande.verifiedAt = new Date();
    demande.verifiedBy = req.user.id;

    const publicMsg =
      message || `Inscription ANEM rÃ©ussie. Votre ID ANEM: ${trimmedId}`;
    demande.adminNotes.push({
      content: publicMsg,
      createdBy: req.user.id,
      isPublic: true,
    });

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      {
        previousValue: previousStatus,
        newValue: "registered",
        anemId: trimmedId,
      },
      req,
    );

    await demande.save();
    await syncCandidateAnemStatus(demande.candidateId, demande);

    await Notification.create({
      userId: demande.userId,
      message: `FÃ©licitations ! Vous Ãªtes maintenant enregistrÃ© auprÃ¨s de l'ANEM. Votre ID ANEM: ${trimmedId}`,
      type: "validation",
    });

    await logAdminAction(
      req.user.id,
      "candidate_anem_registration_success",
      { type: "candidate_anem_registration", id: demande._id },
      { anemId: trimmedId },
      req,
    );

    res.json({
      msg: "Inscription ANEM enregistrÃ©e avec succÃ¨s",
      status: "registered",
      anemId: trimmedId,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const markCandidateAnemFailed = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { reason, publicMessage } = req.body;

    if (!reason || reason.trim().length === 0) {
      return res.status(400).json({ msg: "Raison de l'Ã©chec requise" });
    }

    const demande = await CandidateAnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    if (!["pending", "in_progress"].includes(demande.status)) {
      return res.status(400).json({
        msg: "Seules les demandes en attente ou en cours peuvent Ãªtre marquÃ©es comme Ã©chouÃ©es",
        currentStatus: demande.status,
      });
    }

    const previousStatus = demande.status;
    demande.status = "failed";
    demande.failureReason = reason;

    demande.adminNotes.push({
      content: publicMessage || `Inscription Ã©chouÃ©e: ${reason}`,
      createdBy: req.user.id,
      isPublic: true,
    });

    demande.addAuditEntry(
      "status_changed",
      req.user.id,
      { previousValue: previousStatus, newValue: "failed" },
      req,
    );

    await demande.save();
    await syncCandidateAnemStatus(demande.candidateId, demande);

    await Notification.create({
      userId: demande.userId,
      message: `Nous n'avons pas pu finaliser votre inscription ANEM. Raison: ${reason}. Vous pouvez rÃ©essayer en soumettant une nouvelle demande.`,
      type: "alerte",
    });

    await logAdminAction(
      req.user.id,
      "candidate_anem_registration_failed",
      { type: "candidate_anem_registration", id: demande._id },
      { reason },
      req,
    );

    res.json({
      msg: "Inscription marquÃ©e comme Ã©chouÃ©e",
      status: "failed",
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const addCandidateAnemAdminNote = async (req, res) => {
  try {
    const { demandeId } = req.params;
    const { note, isPublic = false } = req.body;

    if (!note || note.trim().length === 0) {
      return res.status(400).json({ msg: "Note requise" });
    }

    const demande = await CandidateAnemRegistration.findById(demandeId);
    if (!demande) {
      return res.status(404).json({ msg: "Demande introuvable" });
    }

    demande.adminNotes.push({
      content: note.trim(),
      createdBy: req.user.id,
      isPublic: isPublic,
    });

    demande.addAuditEntry(
      "note_added",
      req.user.id,
      { newValue: { note, isPublic } },
      req,
    );

    await demande.save();

    if (isPublic) {
      await Notification.create({
        userId: demande.userId,
        message: `Mise Ã  jour concernant votre demande ANEM: ${note.substring(0, 100)}${note.length > 100 ? "..." : ""}`,
        type: "info",
      });
    }

    await logAdminAction(
      req.user.id,
      "candidate_anem_note_added",
      { type: "candidate_anem_registration", id: demande._id },
      { isPublic },
      req,
    );

    const user = await User.findById(req.user.id).select("nom");

    res.json({
      msg: "Note ajoutÃ©e",
      note: {
        content: note.trim(),
        createdAt: new Date(),
        createdBy: { nom: user.nom },
        isPublic,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateAnemStats = async (req, res) => {
  try {
    const now = new Date();
    const thirtyDaysAgo = new Date(now - 30 * 24 * 60 * 60 * 1000);
    const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);

    const [
      statusCounts,
      newDemandesThisWeek,
      newDemandesThisMonth,
      pendingOlderThan7Days,
      registrationsByType,
      processingTimes,
    ] = await Promise.all([
      CandidateAnemRegistration.aggregate([
        { $match: { status: { $ne: "draft" } } },
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),
      CandidateAnemRegistration.countDocuments({
        status: { $ne: "draft" },
        createdAt: { $gte: sevenDaysAgo },
      }),
      CandidateAnemRegistration.countDocuments({
        status: { $ne: "draft" },
        createdAt: { $gte: thirtyDaysAgo },
      }),
      CandidateAnemRegistration.countDocuments({
        status: { $in: ["pending", "pending_verification"] },
        createdAt: { $lt: sevenDaysAgo },
      }),
      CandidateAnemRegistration.aggregate([
        { $match: { status: { $ne: "draft" } } },
        { $group: { _id: "$registrationType", count: { $sum: 1 } } },
      ]),
      CandidateAnemRegistration.aggregate([
        {
          $match: {
            status: "registered",
            verifiedAt: { $exists: true },
            formSubmittedAt: { $exists: true },
          },
        },
        {
          $project: {
            processingDays: {
              $divide: [
                { $subtract: ["$verifiedAt", "$formSubmittedAt"] },
                1000 * 60 * 60 * 24,
              ],
            },
          },
        },
        {
          $group: {
            _id: null,
            avgDays: { $avg: "$processingDays" },
            minDays: { $min: "$processingDays" },
            maxDays: { $max: "$processingDays" },
            count: { $sum: 1 },
          },
        },
      ]),
    ]);

    const countsMap = {};
    statusCounts.forEach((s) => {
      countsMap[s._id] = s.count;
    });

    const typeMap = {};
    registrationsByType.forEach((t) => {
      typeMap[t._id] = t.count;
    });

    const totalDemandes = Object.values(countsMap).reduce((a, b) => a + b, 0);
    const successfulRegistrations = countsMap["registered"] || 0;
    const successRate =
      totalDemandes > 0
        ? Math.round((successfulRegistrations / totalDemandes) * 100)
        : 0;

    res.json({
      overview: {
        total: totalDemandes,
        pending:
          (countsMap["pending"] || 0) +
          (countsMap["pending_verification"] || 0),
        inProgress: countsMap["in_progress"] || 0,
        registered: countsMap["registered"] || 0,
        failed: countsMap["failed"] || 0,
        rejected: countsMap["rejected"] || 0,
      },
      trends: {
        newThisWeek: newDemandesThisWeek,
        newThisMonth: newDemandesThisMonth,
        pendingOlderThan7Days,
      },
      byType: {
        siteRegistration: typeMap["site_registration"] || 0,
        selfDeclared: typeMap["self_declared"] || 0,
      },
      performance: {
        successRate: `${successRate}%`,
        avgProcessingDays: processingTimes[0]?.avgDays?.toFixed(1) || "N/A",
        minProcessingDays: processingTimes[0]?.minDays?.toFixed(1) || "N/A",
        maxProcessingDays: processingTimes[0]?.maxDays?.toFixed(1) || "N/A",
        totalCompleted: processingTimes[0]?.count || 0,
      },
      statusCounts: countsMap,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateAnemNewCount = async (req, res) => {
  try {
    const [pendingCount, unassignedCount] = await Promise.all([
      CandidateAnemRegistration.countDocuments({
        status: { $in: ["pending", "pending_verification"] },
      }),
      CandidateAnemRegistration.countDocuments({
        status: { $in: ["pending", "pending_verification"] },
        assignedTo: { $exists: false },
      }),
    ]);

    res.json({
      total: pendingCount,
      unassigned: unassignedCount,
      hasNew: pendingCount > 0,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\candidateApplicationController.js ===
import Application from "../models/Application.js";
import Interview from "../models/Interview.js";
import Conversation from "../models/Conversation.js";
import Candidate from "../models/Candidate.js";
import Notification from "../models/Notification.js";
import Offer from "../models/Offer.js";


export const getMyApplications = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable" });
    }

    const { status, page = 1, limit = 20 } = req.query;
    const skip = (page - 1) * limit;

    let query = { candidateId: candidate._id };

    if (status && status !== "all") {
      query.candidateStatus = status;
    }

    const [applications, total] = await Promise.all([
      Application.find(query)
        .sort({ datePostulation: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .populate({
          path: "offerId",
          select: "titre actif companyId type wilaya",
          populate: { path: "companyId", select: "name logo" },
        })
        .lean(),
      Application.countDocuments(query),
    ]);

    
    const enriched = await Promise.all(
      applications.map(async (app) => {
        const [conversation, upcomingInterview, interviewCount] =
          await Promise.all([
            Conversation.findOne({ applicationId: app._id })
              .select("unreadByCandidate lastMessageAt status")
              .lean(),
            Interview.findOne({
              applicationId: app._id,
              status: {
                $in: ["proposed", "confirmed", "rescheduled_by_recruiter"],
              },
              scheduledAt: { $gte: new Date() },
            })
              .sort({ scheduledAt: 1 })
              .lean(),
            Interview.countDocuments({ applicationId: app._id }),
          ]);

        return {
          _id: app._id,
          status: app.candidateStatus,
          source: app.source,
          datePostulation: app.datePostulation,
          offer: app.offerId
            ? {
                _id: app.offerId._id,
                titre: app.offerId.titre,
                entreprise: app.offerId.companyId?.name,
                logo: app.offerId.companyId?.logo,
                type: app.offerId.type,
                wilaya: app.offerId.wilaya,
                actif: app.offerId.actif,
              }
            : {
                titre: app.offerSnapshot?.titre,
                entreprise: app.offerSnapshot?.entrepriseNom,
                actif: false,
                deleted: true,
              },
          hasConversation: !!conversation,
          unreadMessages: conversation?.unreadByCandidate || 0,
          upcomingInterview: upcomingInterview
            ? {
                _id: upcomingInterview._id,
                scheduledAt: upcomingInterview.scheduledAt,
                type: upcomingInterview.type,
                status: upcomingInterview.status,
                needsResponse: upcomingInterview.status === "proposed",
              }
            : null,
          totalInterviews: interviewCount,
        };
      }),
    );

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getApplicationDetail = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { applicationId } = req.params;

    
    const application = await Application.findOne({
      _id: applicationId,
      candidateId: candidate._id,
    })
      .populate({
        path: "offerId",
        select:
          "titre description type wilaya companyId requirements salaryMin salaryMax",
        populate: {
          path: "companyId",
          select: "name logo website location size description",
        },
      })
      .lean();

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    
    const [conversation, interviews] = await Promise.all([
      Conversation.findOne({ applicationId })
        .select("_id messages unreadByCandidate status lastMessageAt") 
        .lean(),
      Interview.find({ applicationId }).sort({ scheduledAt: -1 }).lean(),
    ]);

    
    res.json({
      application: {
        _id: application._id,
        status: application.candidateStatus,
        recruiterStatus: application.recruiterStatus, 
        source: application.source,
        cvUrl: application.cvUrl,
        coverLetter: application.coverLetter,
        datePostulation: application.datePostulation,
        dateDecision: application.dateDecision,
      },
      
      offer: application.offerId || application.offerSnapshot,

      
      conversation: conversation
        ? {
            exists: true,
            _id: conversation._id, 
            unreadCount: conversation.unreadByCandidate,
            messageCount: conversation.messages?.length || 0,
            status: conversation.status,
            lastMessageAt: conversation.lastMessageAt,
          }
        : { exists: false },

      interviews: interviews.map((i) => ({
        _id: i._id,
        type: i.type,
        scheduledAt: i.scheduledAt,
        duration: i.duration,
        location: i.location,
        meetingLink: i.meetingLink,
        status: i.status,
        proposedAlternative: i.proposedAlternative,
        preparationNotes: i.preparationNotes,
        
        canAccept:
          i.status === "proposed" || i.status === "rescheduled_by_recruiter",
        canCounter:
          i.status === "proposed" || i.status === "rescheduled_by_recruiter",
      })),

      statusHistory: application.statusHistory?.map((h) => ({
        status: h.candidateStatus,
        date: h.changedAt,
        note: h.note,
      })),
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const withdrawApplication = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { applicationId } = req.params;
    const { reason } = req.body;

    const application = await Application.findOne({
      _id: applicationId,
      candidateId: candidate._id,
    });

    if (!application)
      return res.status(404).json({ msg: "Candidature introuvable" });

    
    const terminalStatuses = ["retiree", "cancelled", "refusee"]; 
    if (terminalStatuses.includes(application.candidateStatus)) {
      return res
        .status(400)
        .json({ msg: "Action impossible pour le statut actuel." });
    }

    application.candidateStatus = "retiree";
    application.recruiterStatus = "retiree_par_candidat";
    application.withdrawnAt = new Date();
    application.withdrawReason = reason;

    application.statusHistory.push({
      candidateStatus: "retiree",
      recruiterStatus: "retiree_par_candidat",
      changedBy: req.user.id,
      note: "Retrait volontaire par le candidat",
    });

    await application.save();

    
    await Interview.updateMany(
      { applicationId, status: { $in: ["proposed", "confirmed"] } },
      { status: "cancelled_by_candidate" },
    );

    
    
    
    await Offer.findByIdAndUpdate(application.offerId, {
      $inc: { nombreCandidatures: -1 },
    });

    
    const offer = await Offer.findById(application.offerId).populate(
      "recruteurId",
    );
    if (offer?.recruteurId?.userId) {
      await Notification.create({
        userId: offer.recruteurId.userId,
        message: `Le candidat a retirÃ© sa candidature pour "${offer.titre}"`,
        type: "info",
      });
    }

    res.json({ msg: "Candidature retirÃ©e avec succÃ¨s" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const cancelApplication = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { applicationId } = req.params;

    const application = await Application.findOne({
      _id: applicationId,
      candidateId: candidate._id,
    });

    if (!application)
      return res.status(404).json({ msg: "Candidature introuvable" });

    
    if (
      application.candidateStatus !== "envoyee" ||
      application.seenByRecruiter
    ) {
      return res.status(403).json({
        msg: "Trop tard pour annuler. Utilisez l'option 'Retirer' si disponible.",
      });
    }

    application.candidateStatus = "cancelled";
    application.recruiterStatus = "annulee_par_candidat"; 

    application.statusHistory.push({
      candidateStatus: "cancelled",
      recruiterStatus: "annulee_par_candidat",
      changedBy: req.user.id,
      note: "Annulation par le candidat (avant lecture)",
    });

    await application.save();

    
    await Offer.findByIdAndUpdate(application.offerId, {
      $inc: { nombreCandidatures: -1 },
    });

    res.json({ msg: "Candidature annulÃ©e." });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const checkApplicationStatus = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) return res.status(404).json({ msg: "Profil introuvable" });

    const { offerId } = req.params;

    const application = await Application.findOne({
      offerId: offerId,
      candidateId: candidate._id,
    }).populate("offerId", "allowRepostulation"); 

    
    if (!application) {
      return res.json({
        hasApplied: false,
        status: null,
        canCancel: false,
        canWithdraw: false,
        canRepostulate: false, 
        action: "apply", 
      });
    }

    const { candidateStatus, seenByRecruiter, recruiterStatus } = application;

    
    let canCancel = false;
    let canWithdraw = false;
    let canRepostulate = false;
    let action = "none"; 

    
    if (
      candidateStatus === "envoyee" &&
      !seenByRecruiter &&
      recruiterStatus === "nouvelle"
    ) {
      canCancel = true;
      action = "cancel";
    }

    
    
    const isEnCours =
      ["en_cours"].includes(candidateStatus) ||
      (candidateStatus === "envoyee" && seenByRecruiter);
    if (isEnCours) {
      canWithdraw = true;
      action = "withdraw";
    }

    
    
    if (["retiree", "cancelled"].includes(candidateStatus)) {
      if (application.offerId.allowRepostulation !== false) {
        
        canRepostulate = true;
        action = candidateStatus === "cancelled" ? "apply" : "repostulate"; 
      } else {
        action = "disabled"; 
      }
    }

    
    if (["retenue", "non_retenue"].includes(candidateStatus)) {
      action = "finished";
    }

    res.json({
      hasApplied: true,
      applicationId: application._id,
      status: candidateStatus,
      recruiterStatus: recruiterStatus,
      seenByRecruiter: seenByRecruiter,
      canCancel,
      canWithdraw,
      canRepostulate,
      action, 
      allowRepostulation: application.offerId.allowRepostulation,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\candidateController.js ===
import Candidate from "../models/Candidate.js";
import Offer from "../models/Offer.js";
import User from "../models/User.js";
import Application from "../models/Application.js";
import Company from "../models/Company.js";
import Skill from "../models/Skills.js";
import ProposedSkill from "../models/ProposedSkill.js";
import SystemSettings from "../models/SystemSettings.js";
import Notification from "../models/Notification.js";
import CandidateAnemRegistration from "../models/CandidateAnemRegistration.js";
import Interview from "../models/Interview.js";
import {
  uploadCV as cloudinaryUploadCV,
  uploadProfileImage,
  deleteFromCloudinary,
  getPublicIdFromUrl,
  deleteMultipleFromCloudinary,
} from "../config/cloudinary.js";
import { calculateProfileCompletion } from "../utils/profileCompletion.js";

import {
  addSkillToCandidate as addSkill,
  updateCandidateSkill as updateSkill,
  deleteCandidateSkill as deleteSkill,
  getSkillDetails,
  submitSkillFeedback,
} from "./skillController.js";



export const getProfile = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id })
      .populate("userId", "nom email emailVerified")
      .populate("skills.officialSkillId", "name category");

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const user = await User.findById(req.user.id);
    const completion = calculateProfileCompletion(candidate, user);

    res.json({
      profil: candidate,
      completion,
      emailVerified: user.emailVerified,
      anem: {
        status: candidate.anem?.status || "not_started",
        anemId: candidate.anem?.anemId || null,
        isRegistered: candidate.anem?.status === "registered",
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const {
      telephone,
      residence,
      searchPreferences,
      desiredPosition,
      desiredJobTypes,
      dateOfBirth,
      bio,
      gender,
      autoriserProposition,
      links,
    } = req.body;

    let candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      candidate = new Candidate({ userId });
    }

    
    if (telephone !== undefined) candidate.telephone = telephone;
    if (residence !== undefined) candidate.residence = residence;
    if (searchPreferences !== undefined)
      candidate.searchPreferences = searchPreferences;
    if (desiredPosition !== undefined)
      candidate.desiredPosition = desiredPosition;
    if (desiredJobTypes !== undefined)
      candidate.desiredJobTypes = desiredJobTypes;
    if (dateOfBirth !== undefined) candidate.dateOfBirth = dateOfBirth;
    if (bio !== undefined) candidate.bio = bio;
    if (gender !== undefined) candidate.gender = gender;
    if (autoriserProposition !== undefined)
      candidate.autoriserProposition = autoriserProposition;
    if (links !== undefined) candidate.links = links;

    await candidate.save();

    const user = await User.findById(userId);
    const completion = calculateProfileCompletion(candidate, user);

    res.json({
      msg: "Profil mis Ã  jour âœ…",
      candidate,
      completion,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateAccount = async (req, res) => {
  try {
    const userId = req.user.id;
    const { nom, email, motDePasse } = req.body;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable." });
    }

    if (nom) user.nom = nom;

    if (email && email !== user.email) {
      const emailExists = await User.findOne({ email, _id: { $ne: userId } });
      if (emailExists) {
        return res.status(400).json({ msg: "Cet email est dÃ©jÃ  utilisÃ©." });
      }
      
      user.email = email;
    }

    if (motDePasse) {
      const bcrypt = await import("bcryptjs");
      user.motDePasse = await bcrypt.default.hash(motDePasse, 10);
    }

    await user.save();
    res.json({ msg: "Compte mis Ã  jour âœ…" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const uploadProfilePicture = async (req, res) => {
  try {
    const userId = req.user.id;
    const candidate = await Candidate.findOne({ userId });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    if (!req.file) {
      return res.status(400).json({ msg: "Aucune image fournie." });
    }

    
    if (candidate.profilePicture) {
      const publicId = getPublicIdFromUrl(candidate.profilePicture);
      if (publicId) {
        await deleteFromCloudinary(publicId, "image");
      }
    }

    
    const result = await uploadProfileImage(req.file.buffer, userId);

    candidate.profilePicture = result.secure_url;
    await candidate.save();

    res.json({
      msg: "Photo de profil mise Ã  jour ðŸ“¸",
      profilePicture: candidate.profilePicture,
    });
  } catch (err) {
    console.error("Profile picture upload error:", err);
    res.status(500).json({ msg: "Erreur lors du tÃ©lÃ©chargement de l'image" });
  }
};

export const uploadCandidateCV = async (req, res) => {
  try {
    const userId = req.user.id;
    const candidate = await Candidate.findOne({ userId });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const maxCVs = await SystemSettings.getSetting("max_cv_per_candidate", 3);
    if (candidate.cvs.length >= maxCVs) {
      return res.status(400).json({
        msg: `Vous ne pouvez pas ajouter plus de ${maxCVs} CV.`,
      });
    }

    if (!req.file) {
      return res.status(400).json({ msg: "Aucun fichier fourni." });
    }

    
    const result = await cloudinaryUploadCV(
      req.file.buffer,
      req.file.originalname,
      userId,
    );

    
    const fileSize = req.file.size;
    let score = 100;
    if (fileSize < 20 * 1024)
      score = 50; 
    else if (fileSize > 5 * 1024 * 1024) score = 70; 

    candidate.cvs.push({
      url: result.secure_url,
      dateDepot: new Date(),
      score,
    });

    await candidate.save();

    res.json({
      msg: "CV ajoutÃ© avec succÃ¨s âœ…",
      cv: {
        _id: candidate.cvs[candidate.cvs.length - 1]._id,
        url: result.secure_url,
        score,
      },
    });
  } catch (err) {
    console.error("CV upload error:", err);
    res.status(500).json({ msg: "Erreur lors du tÃ©lÃ©chargement du CV" });
  }
};

export const deleteCV = async (req, res) => {
  try {
    const userId = req.user.id;
    const { cvId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const cv = candidate.cvs.id(cvId);
    if (!cv) {
      return res.status(404).json({ msg: "CV introuvable." });
    }

    
    const publicId = getPublicIdFromUrl(cv.url);
    if (publicId) {
      await deleteFromCloudinary(publicId, "raw");
    }

    candidate.cvs.pull(cvId);
    await candidate.save();

    res.json({
      msg: "CV supprimÃ© avec succÃ¨s ðŸ—‘ï¸",
      cvs: candidate.cvs,
    });
  } catch (err) {
    console.error("CV deletion error:", err);
    res.status(500).json({ msg: err.message });
  }
};





export const addExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const { jobTitle, company, startDate, endDate, description } = req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    candidate.experiences.push({
      jobTitle,
      company,
      startDate,
      endDate: endDate || null,
      description,
    });

    await candidate.save();

    res.json({ msg: "ExpÃ©rience ajoutÃ©e", experiences: candidate.experiences });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const { experienceId } = req.params;
    const { jobTitle, company, startDate, endDate, description } = req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const experience = candidate.experiences.id(experienceId);
    if (!experience) {
      return res.status(404).json({ msg: "ExpÃ©rience introuvable." });
    }

    if (jobTitle) experience.jobTitle = jobTitle;
    if (company) experience.company = company;
    if (startDate) experience.startDate = startDate;
    if (endDate !== undefined) experience.endDate = endDate;
    if (description !== undefined) experience.description = description;

    await candidate.save();

    res.json({
      msg: "ExpÃ©rience mise Ã  jour",
      experiences: candidate.experiences,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteExperience = async (req, res) => {
  try {
    const userId = req.user.id;
    const { experienceId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    candidate.experiences.pull(experienceId);
    await candidate.save();

    res.json({
      msg: "ExpÃ©rience supprimÃ©e",
      experiences: candidate.experiences,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const addEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { institut, degree, fieldOfStudy, startDate, endDate, description } =
      req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    candidate.education.push({
      institut,
      degree,
      fieldOfStudy,
      startDate,
      endDate: endDate || null,
      description,
    });

    await candidate.save();

    res.json({
      msg: "Formation ajoutÃ©e avec succÃ¨s ðŸŽ“",
      education: candidate.education,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { educationId } = req.params;
    const { institut, degree, fieldOfStudy, startDate, endDate, description } =
      req.body;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const edu = candidate.education.id(educationId);
    if (!edu) {
      return res.status(404).json({ msg: "Formation introuvable." });
    }

    if (institut) edu.institut = institut;
    if (degree) edu.degree = degree;
    if (fieldOfStudy !== undefined) edu.fieldOfStudy = fieldOfStudy;
    if (startDate) edu.startDate = startDate;
    if (endDate !== undefined) edu.endDate = endDate;
    if (description !== undefined) edu.description = description;

    await candidate.save();

    res.json({
      msg: "Formation mise Ã  jour âœ…",
      education: candidate.education,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deleteEducation = async (req, res) => {
  try {
    const userId = req.user.id;
    const { educationId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    candidate.education.pull(educationId);
    await candidate.save();

    res.json({ msg: "Formation supprimÃ©e ðŸ—‘ï¸", education: candidate.education });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const getFavorites = async (req, res) => {
  try {
    const userId = req.user.id;

    const candidate = await Candidate.findOne({ userId }).populate({
      path: "favoris.offerId",
      select:
        "titre companyId type wilaya salaryMin salaryMax datePublication actif validationStatus",
      populate: {
        path: "companyId",
        select: "name logo location",
      },
    });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    
    const validFavorites = candidate.favoris
      .filter((f) => f.offerId !== null)
      .map((f) => ({
        _id: f._id,
        savedAt: f.savedAt,
        offer: {
          _id: f.offerId._id,
          titre: f.offerId.titre,
          type: f.offerId.type,
          wilaya: f.offerId.wilaya,
          salaryMin: f.offerId.salaryMin,
          salaryMax: f.offerId.salaryMax,
          datePublication: f.offerId.datePublication,
          isActive:
            f.offerId.actif && f.offerId.validationStatus === "approved",
          company: {
            name: f.offerId.companyId?.name,
            logo: f.offerId.companyId?.logo,
            location: f.offerId.companyId?.location,
          },
        },
      }));

    res.json(validFavorites);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const addToFavorites = async (req, res) => {
  try {
    const { offerId } = req.params;
    const userId = req.user.id;

    const offerExists = await Offer.exists({
      _id: offerId,
      actif: true,
      validationStatus: "approved",
    });
    if (!offerExists) {
      return res.status(404).json({ msg: "Offre introuvable ou inactive." });
    }

    const candidateCheck = await Candidate.findOne({
      userId,
      "favoris.offerId": offerId,
    });

    if (candidateCheck) {
      return res
        .status(400)
        .json({ msg: "Cette offre est dÃ©jÃ  dans vos favoris." });
    }

    const updatedCandidate = await Candidate.findOneAndUpdate(
      { userId },
      {
        $push: {
          favoris: {
            offerId: offerId,
            savedAt: new Date(),
          },
        },
      },
      { new: true },
    );

    if (!updatedCandidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable." });
    }

    res.json({
      msg: "Offre ajoutÃ©e aux favoris â¤ï¸",
      favorisCount: updatedCandidate.favoris.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const removeFromFavorites = async (req, res) => {
  try {
    const { offerId } = req.params;
    const userId = req.user.id;

    const updatedCandidate = await Candidate.findOneAndUpdate(
      { userId },
      {
        $pull: {
          favoris: { offerId: offerId },
        },
      },
      { new: true },
    );

    if (!updatedCandidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable." });
    }

    res.json({
      msg: "Offre retirÃ©e des favoris ðŸ’”",
      favorisCount: updatedCandidate.favoris.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const applyToOffer = async (req, res) => {
  try {
    const userId = req.user.id;
    const { offreId, cvUrl, coverLetter } = req.body;

    const candidate = await Candidate.findOne({ userId });
    const user = await User.findById(userId);

    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    if (!user.emailVerified) {
      return res.status(403).json({
        msg: "Email non vÃ©rifiÃ©.",
        code: "EMAIL_NOT_VERIFIED",
      });
    }

    const completion = calculateProfileCompletion(candidate, user);
    if (!completion.canApply) {
      return res.status(400).json({
        msg: "Profil incomplet.",
        missing: completion.missingForApplication,
      });
    }

    const cvExists = candidate.cvs.some((cv) => cv.url === cvUrl);
    if (!cvExists) {
      return res.status(400).json({ msg: "CV invalide." });
    }

    const offer = await Offer.findById(offreId);
    if (!offer || !offer.actif || offer.validationStatus !== "approved") {
      return res
        .status(400)
        .json({ msg: "Cette offre n'est plus disponible." });
    }

    
    const existingApp = await Application.findOne({
      offerId: offreId,
      candidateId: candidate._id,
    });

    if (existingApp) {
      const activeStatuses = ["envoyee", "en_cours", "retenue", "non_retenue"];

      if (activeStatuses.includes(existingApp.candidateStatus)) {
        return res.status(400).json({
          msg: "Vous avez dÃ©jÃ  une candidature active pour cette offre.",
        });
      }

      if (["cancelled", "retiree"].includes(existingApp.candidateStatus)) {
        if (offer.allowRepostulation === false) {
          return res.status(403).json({
            msg: "L'employeur n'accepte pas les repostulations pour cette offre.",
          });
        }

        const wasWithdrawn = existingApp.candidateStatus === "retiree";

        existingApp.candidateStatus = "envoyee";
        existingApp.recruiterStatus = "nouvelle";
        existingApp.cvUrl = cvUrl;
        existingApp.coverLetter = coverLetter || "";
        existingApp.seenByRecruiter = false;
        existingApp.seenAt = null;
        existingApp.datePostulation = new Date();
        existingApp.isRepostulation = true;
        existingApp.withdrawReason = undefined;
        existingApp.withdrawnAt = undefined;

        existingApp.statusHistory.push({
          candidateStatus: "envoyee",
          recruiterStatus: "nouvelle",
          changedBy: userId,
          note: wasWithdrawn
            ? "Repostulation aprÃ¨s retrait"
            : "Nouvelle postulation aprÃ¨s annulation",
        });

        await existingApp.save();

        await Offer.findByIdAndUpdate(offreId, {
          $inc: { nombreCandidatures: 1 },
        });

        return res.json({
          msg: "Candidature envoyÃ©e avec succÃ¨s âœ…",
          applicationId: existingApp._id,
          reactivated: true,
        });
      }
    }

    
    const company = await Company.findById(offer.companyId);

    const newApplication = await Application.create({
      offerId: offreId,
      candidateId: candidate._id,
      cvUrl,
      coverLetter: coverLetter || "",
      candidateStatus: "envoyee",
      recruiterStatus: "nouvelle",
      source: "direct",
      isRepostulation: false,
      offerSnapshot: {
        titre: offer.titre,
        entrepriseNom: company?.name || "Entreprise",
        companyId: offer.companyId,
        location: offer.wilaya,
        wilaya: offer.wilaya,
        salaryMin: offer.salaryMin,
        salaryMax: offer.salaryMax,
        type: offer.type,
        domaine: offer.domaine,
      },
    });

    await Offer.findByIdAndUpdate(offreId, {
      $inc: { nombreCandidatures: 1 },
    });

    res.json({
      msg: "Candidature envoyÃ©e avec succÃ¨s âœ…",
      applicationId: newApplication._id,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};



export const getCandidateStats = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const [
      totalApplications,
      applicationsByStatus,
      recentApplications,
      weeklyApplications,
      viewedApplications,
      upcomingInterviews,
      pendingInterviewResponses,
    ] = await Promise.all([
      Application.countDocuments({ candidateId: candidate._id }),
      Application.aggregate([
        { $match: { candidateId: candidate._id } },
        { $group: { _id: "$candidateStatus", count: { $sum: 1 } } },
      ]),
      Application.countDocuments({
        candidateId: candidate._id,
        datePostulation: { $gte: thirtyDaysAgo },
      }),
      Application.countDocuments({
        candidateId: candidate._id,
        datePostulation: { $gte: sevenDaysAgo },
      }),
      Application.countDocuments({
        candidateId: candidate._id,
        seenByRecruiter: true,
      }),
      Interview.countDocuments({
        candidateId: candidate._id,
        status: "confirmed",
        scheduledAt: { $gte: new Date() },
      }),
      Interview.countDocuments({
        candidateId: candidate._id,
        status: "proposed",
        scheduledAt: { $gte: new Date() },
      }),
    ]);

    const statusMap = {};
    applicationsByStatus.forEach((item) => {
      statusMap[item._id] = item.count;
    });

    const responded =
      (statusMap["retenue"] || 0) +
      (statusMap["non_retenue"] || 0) +
      (statusMap["en_cours"] || 0);

    const responseRate =
      totalApplications > 0
        ? Math.round((responded / totalApplications) * 100)
        : 0;

    const viewRate =
      totalApplications > 0
        ? Math.round((viewedApplications / totalApplications) * 100)
        : 0;

    const user = await User.findById(req.user.id);
    const profileCompletion = calculateProfileCompletion(candidate, user);

    
    const suggestions = [];

    if (!user.emailVerified) {
      suggestions.push({
        type: "critical",
        priority: 1,
        message: "Confirmez votre email pour postuler aux offres",
        action: "verify_email",
        icon: "mail",
      });
    }

    if (profileCompletion.percentage < 100) {
      suggestions.push({
        type: "important",
        priority: 2,
        message: `ComplÃ©tez votre profil (${profileCompletion.percentage}%)`,
        action: "complete_profile",
        missing: profileCompletion.missing,
        icon: "user",
      });
    }

    if (candidate.cvs.length === 0) {
      suggestions.push({
        type: "important",
        priority: 3,
        message: "Ajoutez votre CV pour augmenter vos chances",
        action: "upload_cv",
        icon: "file",
      });
    }

    if (candidate.skills.length < 3) {
      suggestions.push({
        type: "suggestion",
        priority: 4,
        message:
          "Ajoutez plus de compÃ©tences pour de meilleures recommandations",
        action: "add_skills",
        icon: "star",
      });
    }

    if (pendingInterviewResponses > 0) {
      suggestions.push({
        type: "urgent",
        priority: 0,
        message: `${pendingInterviewResponses} proposition(s) d'entretien en attente`,
        action: "view_interviews",
        icon: "calendar",
      });
    }

    
    suggestions.sort((a, b) => a.priority - b.priority);

    res.json({
      applications: {
        total: totalApplications,
        thisMonth: recentApplications,
        thisWeek: weeklyApplications,
        byStatus: statusMap,
      },
      interviews: {
        upcoming: upcomingInterviews,
        pendingResponse: pendingInterviewResponses,
      },
      favorites: candidate.favoris.length,
      rates: {
        response: responseRate,
        view: viewRate,
      },
      anem: {
        status: candidate.anem?.status || "not_started",
        anemId: candidate.anem?.anemId || null,
        isRegistered: candidate.anem?.status === "registered",
      },
      completion: profileCompletion,
      suggestions,
      cvCount: candidate.cvs.length,
      skillCount: candidate.skills.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getActivityTimeline = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    const { limit = 20 } = req.query;

    
    const recentApplications = await Application.find({
      candidateId: candidate._id,
    })
      .sort({ updatedAt: -1 })
      .limit(parseInt(limit))
      .populate({
        path: "offerId",
        select: "titre",
        populate: { path: "companyId", select: "name logo" },
      })
      .lean();

    
    const recentInterviews = await Interview.find({
      candidateId: candidate._id,
    })
      .sort({ updatedAt: -1 })
      .limit(10)
      .populate("offerId", "titre")
      .lean();

    
    const activities = [
      ...recentApplications.map((app) => ({
        type: "application",
        date: app.updatedAt,
        title:
          app.offerId?.titre || app.offerSnapshot?.titre || "Offre supprimÃ©e",
        company:
          app.offerId?.companyId?.name || app.offerSnapshot?.entrepriseNom,
        companyLogo: app.offerId?.companyId?.logo,
        status: app.candidateStatus,
        applicationId: app._id,
        icon: getApplicationIcon(app.candidateStatus),
      })),
      ...recentInterviews.map((interview) => ({
        type: "interview",
        date: interview.updatedAt,
        title: interview.offerId?.titre || "Offre supprimÃ©e",
        status: interview.status,
        scheduledAt: interview.scheduledAt,
        interviewType: interview.type,
        interviewId: interview._id,
        icon: getInterviewIcon(interview.status),
      })),
    ];

    
    activities.sort((a, b) => new Date(b.date) - new Date(a.date));

    res.json(activities.slice(0, parseInt(limit)));
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


function getApplicationIcon(status) {
  const icons = {
    envoyee: "send",
    en_cours: "clock",
    retenue: "check-circle",
    non_retenue: "x-circle",
    retiree: "arrow-left",
    cancelled: "x",
  };
  return icons[status] || "file";
}

function getInterviewIcon(status) {
  const icons = {
    proposed: "calendar-plus",
    confirmed: "calendar-check",
    completed: "check",
    cancelled_by_candidate: "x",
    cancelled_by_recruiter: "x",
  };
  return icons[status] || "calendar";
}



export const getRecommendedOffers = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });

    if (!candidate) {
      return res.status(404).json({ msg: "Profil candidat introuvable" });
    }

    
    const appliedOfferIds = await Application.find({
      candidateId: candidate._id,
    }).distinct("offerId");

    
    const baseQuery = {
      actif: true,
      validationStatus: "approved",
      _id: { $nin: appliedOfferIds },
    };

    const candidateSkills = [];

    for (const skill of candidate.skills || []) {
      if (!skill.isVisibleToRecruiters) continue;

      
      if (skill.normalizedText) {
        candidateSkills.push(skill.normalizedText);
      }

      
      if (skill.officialSkillName) {
        candidateSkills.push(skill.officialSkillName.toLowerCase());
      }

      
      if (skill.domain) {
        candidateSkills.push(skill.domain.toLowerCase());
      }
    }

    const candidateWilaya = candidate.residence?.wilaya;
    const desiredPosition = candidate.desiredPosition?.toLowerCase();
    const desiredJobTypes = candidate.desiredJobTypes || [];

    
    if (candidateSkills.length === 0 && !candidateWilaya && !desiredPosition) {
      const popularOffers = await Offer.find(baseQuery)
        .populate("companyId", "name logo location")
        .sort({ nombreCandidatures: -1 })
        .limit(10)
        .lean();

      return res.json(
        popularOffers.map((o) => ({
          ...o,
          matchScore: 0,
          matchReasons: ["Offres populaires"],
        })),
      );
    }

    
    const queryConditions = [];

    
    if (candidateSkills.length > 0) {
      queryConditions.push({
        skills: {
          $in: candidateSkills.map((s) => new RegExp(s, "i")),
        },
      });
    }

    
    if (candidateWilaya) {
      queryConditions.push({ wilaya: candidateWilaya });
    }

    
    if (desiredPosition) {
      queryConditions.push({
        titre: { $regex: desiredPosition, $options: "i" },
      });
    }

    
    if (desiredJobTypes.length > 0) {
      queryConditions.push({ type: { $in: desiredJobTypes } });
    }

    
    let offerQuery = { ...baseQuery };
    if (queryConditions.length > 0) {
      offerQuery.$or = queryConditions;
    }

    const offers = await Offer.find(offerQuery)
      .populate("companyId", "name logo location industry")
      .sort({ datePublication: -1 })
      .limit(50)
      .lean();

    
    const scoredOffers = offers.map((offer) => {
      let score = 0;
      const matchReasons = [];

      
      const offerSkills = (offer.skills || []).map((s) =>
        s.trim().toLowerCase(),
      );
      const matchingSkills = offerSkills.filter((skill) =>
        candidateSkills.some((cs) => skill.includes(cs) || cs.includes(skill)),
      );
      if (matchingSkills.length > 0) {
        const skillScore = Math.min(
          (matchingSkills.length / Math.max(offerSkills.length, 1)) * 40,
          40,
        );
        score += skillScore;
        matchReasons.push(
          `${matchingSkills.length} compÃ©tence(s) correspondante(s)`,
        );
      }

      
      if (candidateWilaya && offer.wilaya === candidateWilaya) {
        score += 25;
        matchReasons.push("MÃªme wilaya");
      }

      
      if (desiredJobTypes.length > 0 && desiredJobTypes.includes(offer.type)) {
        score += 20;
        matchReasons.push("Type de contrat souhaitÃ©");
      }

      
      if (
        desiredPosition &&
        offer.titre.toLowerCase().includes(desiredPosition)
      ) {
        score += 15;
        matchReasons.push("Correspond au poste recherchÃ©");
      }

      
      const isNew =
        new Date() - new Date(offer.datePublication) < 7 * 24 * 60 * 60 * 1000;
      if (isNew) {
        score += 5;
        matchReasons.push("Offre rÃ©cente");
      }

      return {
        ...offer,
        matchScore: Math.round(score),
        matchReasons,
        matchingSkills,
        isNew,
      };
    });

    
    scoredOffers.sort((a, b) => {
      if (b.matchScore !== a.matchScore) {
        return b.matchScore - a.matchScore;
      }
      return (
        new Date(b.datePublication).getTime() -
        new Date(a.datePublication).getTime()
      );
    });

    
    res.json(scoredOffers.slice(0, 10));
  } catch (err) {
    console.error("Recommendation error:", err);
    res.status(500).json({ msg: err.message });
  }
};
export {
  addSkill,
  updateSkill,
  deleteSkill,
  getSkillDetails,
  submitSkillFeedback,
};


=== controllers\conversationController.js ===
import Conversation from "../models/Conversation.js";
import Application from "../models/Application.js";
import Offer from "../models/Offer.js";
import Candidate from "../models/Candidate.js";
import Recruiter from "../models/Recruiter.js";
import Notification from "../models/Notification.js";
import { mapRecruiterToCandidate } from "../utils/statusMapping.js";




export const openConversation = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { applicationId } = req.params;
    const { initialMessage } = req.body;

    const application =
      await Application.findById(applicationId).populate("offerId");

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    if (
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(403).json({ msg: "Non autorisÃ©" });
    }

    
    let conversation = await Conversation.findOne({ applicationId });

    if (conversation) {
      return res.status(400).json({
        msg: "Une conversation existe dÃ©jÃ  pour cette candidature",
        conversationId: conversation._id,
      });
    }

    
    conversation = await Conversation.create({
      applicationId,
      offerId: application.offerId._id,
      candidateId: application.candidateId,
      recruiterId: recruiter._id,
      openedBy: req.user.id,
      messages: initialMessage
        ? [
            {
              senderId: req.user.id,
              senderType: "recruiter",
              content: initialMessage,
            },
          ]
        : [],
      unreadByCandidate: initialMessage ? 1 : 0,
      lastMessageAt: initialMessage ? new Date() : null,
    });

    
    if (
      application.recruiterStatus !== "en_discussion" &&
      ![
        "entretien_planifie",
        "entretien_termine",
        "retenue",
        "refusee",
      ].includes(application.recruiterStatus)
    ) {
      application.recruiterStatus = "en_discussion";
      application.candidateStatus = mapRecruiterToCandidate("en_discussion");
      application.statusHistory.push({
        candidateStatus: application.candidateStatus,
        recruiterStatus: "en_discussion",
        changedBy: req.user.id,
        note: "Conversation ouverte",
      });
      await application.save();
    }

    
    if (initialMessage) {
      const candidate = await Candidate.findById(application.candidateId);
      await Notification.create({
        userId: candidate.userId,
        message: `Nouveau message du recruteur pour "${application.offerId.titre}"`,
        type: "info",
      });
    }

    res.status(201).json({ msg: "Conversation ouverte", conversation });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const sendMessageAsRecruiter = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { conversationId } = req.params;
    const { content } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    const conversation = await Conversation.findOne({
      _id: conversationId,
      recruiterId: recruiter._id,
      status: "active",
    });

    if (!conversation) {
      return res
        .status(404)
        .json({ msg: "Conversation introuvable ou fermÃ©e" });
    }

    conversation.messages.push({
      senderId: req.user.id,
      senderType: "recruiter",
      content,
      attachments,
    });
    conversation.unreadByCandidate += 1;
    conversation.lastMessageAt = new Date();
    await conversation.save();

    
    const candidate = await Candidate.findById(conversation.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `Nouveau message du recruteur`,
      type: "info",
    });

    res.json({
      msg: "Message envoyÃ©",
      message: conversation.messages.slice(-1)[0],
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getRecruiterConversations = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { offerId, hasUnread, isActive } = req.query;

    let query = { recruiterId: recruiter._id, status: "active" };

    if (offerId) query.offerId = offerId;
    if (hasUnread === "true") query.unreadByRecruiter = { $gt: 0 };

    
    if (isActive === "true") query.candidateHasReplied = true;
    if (isActive === "false") query.candidateHasReplied = false;

    const conversations = await Conversation.find(query)
      .sort({ lastMessageAt: -1 })
      .populate({
        path: "candidateId",
        select: "profilePicture userId",
        populate: { path: "userId", select: "nom" },
      })
      .populate("offerId", "titre")
      .lean();

    const enriched = conversations.map((c) => ({
      _id: c._id,
      applicationId: c.applicationId,
      offer: { _id: c.offerId?._id, titre: c.offerId?.titre },
      candidate: {
        nom: c.candidateId?.userId?.nom,
        profilePicture: c.candidateId?.profilePicture,
      },
      lastMessage: c.messages?.slice(-1)[0],
      unreadCount: c.unreadByRecruiter,
      lastMessageAt: c.lastMessageAt,
    }));

    res.json(enriched);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getCandidateConversations = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });

    const conversations = await Conversation.find({
      candidateId: candidate._id,
      status: "active",
    })
      .sort({ lastMessageAt: -1 })
      .populate("offerId", "titre companyId")
      .populate({
        path: "offerId",
        populate: { path: "companyId", select: "name logo" },
      })
      .lean();

    const enriched = conversations.map((c) => ({
      _id: c._id,
      applicationId: c.applicationId,
      offer: {
        titre: c.offerId?.titre,
        entreprise: c.offerId?.companyId?.name,
        logo: c.offerId?.companyId?.logo,
      },
      lastMessage: c.messages?.slice(-1)[0],
      unreadCount: c.unreadByCandidate,
      lastMessageAt: c.lastMessageAt,
    }));

    res.json(enriched);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getConversationMessages = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { conversationId } = req.params;

    
    const conversation = await Conversation.findOne({
      _id: conversationId,
      candidateId: candidate._id,
    })
      .populate({
        path: "offerId",
        select: "titre companyId",
        populate: {
          path: "companyId",
          select: "name logo", 
        },
      })
      .lean();

    if (!conversation) {
      return res.status(404).json({ msg: "Conversation introuvable" });
    }

    
    await Conversation.findByIdAndUpdate(conversationId, {
      unreadByCandidate: 0,
    });

    
    await Conversation.updateOne(
      { _id: conversationId },
      { $set: { "messages.$[elem].readAt": new Date() } },
      {
        arrayFilters: [
          { "elem.readAt": { $exists: false }, "elem.senderType": "recruiter" },
        ],
      },
    );

    
    res.json({
      _id: conversation._id,
      applicationId: conversation.applicationId,
      status: conversation.status,
      
      context: {
        offerId: conversation.offerId?._id,
        offerTitle: conversation.offerId?.titre || "Offre supprimÃ©e",
        companyName:
          conversation.offerId?.companyId?.name || "Entreprise inconnue",
        companyLogo: conversation.offerId?.companyId?.logo,
      },
      messages: conversation.messages,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const sendMessageAsCandidate = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { conversationId } = req.params;
    const { content } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    const conversation = await Conversation.findOne({
      _id: conversationId,
      candidateId: candidate._id,
      status: "active",
    });

    if (!conversation) {
      return res
        .status(404)
        .json({ msg: "Conversation introuvable ou fermÃ©e" });
    }

    
    if (!conversation.candidateHasReplied) {
      conversation.candidateHasReplied = true;
      conversation.firstCandidateReplyAt = new Date();
    }

    conversation.messages.push({
      senderId: req.user.id,
      senderType: "candidate",
      content,
      attachments,
    });
    conversation.unreadByRecruiter += 1;
    conversation.lastMessageAt = new Date();
    await conversation.save();

    
    const recruiter = await Recruiter.findById(conversation.recruiterId);
    await Notification.create({
      userId: recruiter.userId,
      message: `Nouvelle rÃ©ponse d'un candidat`,
      type: "info",
    });

    res.json({
      msg: "Message envoyÃ©",
      message: conversation.messages.slice(-1)[0],
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const getRecruiterConversationMessages = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { conversationId } = req.params;

    const conversation = await Conversation.findOne({
      _id: conversationId,
      recruiterId: recruiter._id, 
    })
      .populate("candidateId", "profilePicture")
      .populate({
        path: "candidateId",
        populate: { path: "userId", select: "nom" },
      })
      .populate("offerId", "titre")
      .lean();

    if (!conversation) {
      return res.status(404).json({ msg: "Conversation introuvable" });
    }

    
    await Conversation.findByIdAndUpdate(conversationId, {
      unreadByRecruiter: 0,
    });

    res.json({
      _id: conversation._id,
      applicationId: conversation.applicationId,
      candidateId: conversation.candidateId?._id,
      offer: { titre: conversation.offerId?.titre },
      candidate: {
        nom: conversation.candidateId?.userId?.nom,
        profilePicture: conversation.candidateId?.profilePicture,
      },
      messages: conversation.messages,
      status: conversation.status,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\interviewController.js ===
import Interview from "../models/Interview.js";
import Application from "../models/Application.js";
import Offer from "../models/Offer.js";
import Candidate from "../models/Candidate.js";
import Recruiter from "../models/Recruiter.js";
import Notification from "../models/Notification.js";
import { mapRecruiterToCandidate } from "../utils/statusMapping.js";




export const proposeInterview = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { applicationId } = req.params;
    const {
      type,
      scheduledAt,
      duration,
      location,
      meetingLink,
      phoneNumber,
      preparationNotes,
    } = req.body;

    const application =
      await Application.findById(applicationId).populate("offerId");

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    if (
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(403).json({ msg: "Non autorisÃ©" });
    }

    
    const allowedStatuses = [
      "consultee",
      "preselection",
      "en_discussion",
      "entretien_termine",
    ];
    if (!allowedStatuses.includes(application.recruiterStatus)) {
      return res.status(400).json({
        msg: "Cette candidature ne peut pas recevoir d'entretien dans son Ã©tat actuel",
      });
    }

    const interview = await Interview.create({
      applicationId,
      offerId: application.offerId._id,
      candidateId: application.candidateId,
      recruiterId: recruiter._id,
      type,
      scheduledAt: new Date(scheduledAt),
      duration: duration || 30,
      location,
      meetingLink,
      phoneNumber,
      preparationNotes,
      status: "proposed",
    });

    
    if (application.recruiterStatus !== "entretien_planifie") {
      application.recruiterStatus = "entretien_planifie";
      application.candidateStatus =
        mapRecruiterToCandidate("entretien_planifie");
      application.statusHistory.push({
        candidateStatus: application.candidateStatus,
        recruiterStatus: "entretien_planifie",
        changedBy: req.user.id,
        note: "Entretien proposÃ©",
      });
      await application.save();
    }

    
    const candidate = await Candidate.findById(application.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `Un entretien vous est proposÃ© pour "${
        application.offerId.titre
      }" le ${new Date(scheduledAt).toLocaleDateString("fr-FR")}`,
      type: "validation",
    });

    res.status(201).json({ msg: "Entretien proposÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getRecruiterInterviews = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { status, upcoming, page = 1, limit = 20 } = req.query;

    let query = { recruiterId: recruiter._id };

    if (status) {
      query.status = status;
    }

    if (upcoming === "true") {
      query.scheduledAt = { $gte: new Date() };
      query.status = {
        $in: ["proposed", "confirmed", "rescheduled_by_candidate"],
      };
    }

    const skip = (page - 1) * limit;

    const [interviews, total] = await Promise.all([
      Interview.find(query)
        .sort({ scheduledAt: 1 })
        .skip(skip)
        .limit(parseInt(limit))
        .populate({
          path: "candidateId",
          select: "profilePicture userId",
          populate: { path: "userId", select: "nom email" },
        })
        .populate("offerId", "titre")
        .lean(),
      Interview.countDocuments(query),
    ]);

    
    const enriched = interviews.map((i) => ({
      ...i,
      needsAction: i.status === "rescheduled_by_candidate",
      isToday:
        new Date(i.scheduledAt).toDateString() === new Date().toDateString(),
      isPast: new Date(i.scheduledAt) < new Date(),
    }));

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getRecruiterInterviewsGrouped = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { view = "upcoming" } = req.query; 

    const now = new Date();
    const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);

    let query = { recruiterId: recruiter._id };

    if (view === "upcoming") {
      query.scheduledAt = { $gte: now };
      query.status = {
        $in: [
          "proposed",
          "confirmed",
          "rescheduled_by_candidate",
          "rescheduled_by_recruiter",
        ],
      };
    } else if (view === "recent") {
      query.scheduledAt = { $gte: sevenDaysAgo, $lt: now };
    }

    const interviews = await Interview.find(query)
      .sort({ scheduledAt: view === "upcoming" ? 1 : -1 })
      .populate({
        path: "candidateId",
        select: "profilePicture userId",
        populate: { path: "userId", select: "nom" },
      })
      .populate("offerId", "titre")
      .lean();

    
    const grouped = interviews.reduce((acc, interview) => {
      const dateKey = new Date(interview.scheduledAt)
        .toISOString()
        .split("T")[0];
      if (!acc[dateKey]) {
        acc[dateKey] = [];
      }
      acc[dateKey].push({
        _id: interview._id,
        type: interview.type,
        scheduledAt: interview.scheduledAt,
        duration: interview.duration,
        status: interview.status,
        location: interview.location,
        meetingLink: interview.meetingLink,
        candidate: {
          nom: interview.candidateId?.userId?.nom,
          profilePicture: interview.candidateId?.profilePicture,
        },
        offer: {
          _id: interview.offerId?._id,
          titre: interview.offerId?.titre,
        },
        needsAction: interview.status === "rescheduled_by_candidate",
      });
      return acc;
    }, {});

    res.json({
      grouped,
      total: interviews.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const acceptAlternativeDate = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { interviewId } = req.params;

    const interview = await Interview.findOne({
      _id: interviewId,
      recruiterId: recruiter._id,
      status: "rescheduled_by_candidate",
    });

    if (!interview) {
      return res
        .status(404)
        .json({ msg: "Entretien introuvable ou pas de proposition" });
    }

    interview.scheduledAt = interview.proposedAlternative.date;
    interview.status = "confirmed";
    interview.proposedAlternative = undefined;
    await interview.save();

    
    const candidate = await Candidate.findById(interview.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `Votre nouvelle date d'entretien a Ã©tÃ© confirmÃ©e`,
      type: "validation",
    });

    res.json({ msg: "Nouvelle date acceptÃ©e", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const rescheduleByRecruiter = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { interviewId } = req.params;
    const { newDate, message } = req.body;

    const interview = await Interview.findOne({
      _id: interviewId,
      recruiterId: recruiter._id,
    });

    if (!interview) {
      return res.status(404).json({ msg: "Entretien introuvable" });
    }

    interview.scheduledAt = new Date(newDate);
    interview.status = "rescheduled_by_recruiter";
    interview.proposedAlternative = {
      date: new Date(newDate),
      proposedBy: "recruiter",
      message,
      proposedAt: new Date(),
    };
    await interview.save();

    const candidate = await Candidate.findById(interview.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `L'entretien a Ã©tÃ© reprogrammÃ©, veuillez confirmer la nouvelle date`,
      type: "validation",
    });

    res.json({ msg: "Entretien reprogrammÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const cancelInterviewByRecruiter = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { interviewId } = req.params;
    const { reason } = req.body;

    const interview = await Interview.findOneAndUpdate(
      {
        _id: interviewId,
        recruiterId: recruiter._id,
        status: {
          $in: [
            "proposed",
            "confirmed",
            "rescheduled_by_candidate",
            "rescheduled_by_recruiter",
          ],
        },
      },
      {
        status: "cancelled_by_recruiter",
        recruiterNotes: reason,
      },
      { new: true },
    );

    if (!interview) {
      return res
        .status(404)
        .json({ msg: "Entretien introuvable ou dÃ©jÃ  terminÃ©" });
    }

    const candidate = await Candidate.findById(interview.candidateId);
    await Notification.create({
      userId: candidate.userId,
      message: `L'entretien prÃ©vu a Ã©tÃ© annulÃ© par le recruteur`,
      type: "info",
    });

    res.json({ msg: "Entretien annulÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const completeInterview = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });
    const { interviewId } = req.params;

    const { rating, notes, strengths, concerns, recommendation, status } =
      req.body;

    const interview = await Interview.findOne({
      _id: interviewId,
      recruiterId: recruiter._id,
    });

    if (!interview) {
      return res.status(404).json({ msg: "Entretien introuvable" });
    }

    interview.status = "completed";
    interview.feedback = {
      rating,
      notes,
      strengths,
      concerns,
      recommendation,
      completedAt: new Date(),
    };

    await interview.save();

    if (status === "retenue" || status === "refusee") {
      const application = await Application.findById(interview.applicationId);

      application.recruiterStatus = status;

      if (status === "retenue") {
        application.candidateStatus = "retenue";
        application.dateDecision = new Date();
      } else {
        application.candidateStatus = "non_retenue";
        application.dateDecision = new Date();
      }

      application.statusHistory.push({
        candidateStatus: application.candidateStatus,
        recruiterStatus: status,
        changedBy: req.user.id,
        note: `DÃ©cision finale aprÃ¨s entretien: ${recommendation}`,
      });

      await application.save();
    } else {
      const pendingInterviews = await Interview.countDocuments({
        applicationId: interview.applicationId,
        status: { $in: ["proposed", "confirmed"] },
      });

      if (pendingInterviews === 0) {
        const application = await Application.findById(interview.applicationId);

        if (
          application.recruiterStatus !== "retenue" &&
          application.recruiterStatus !== "refusee"
        ) {
          application.recruiterStatus = "entretien_termine";
          application.candidateStatus =
            mapRecruiterToCandidate("entretien_termine");

          application.statusHistory.push({
            candidateStatus: application.candidateStatus,
            recruiterStatus: "entretien_termine",
            changedBy: req.user.id,
            note: "Tous les entretiens terminÃ©s",
          });

          await application.save();
        }
      }
    }

    res.json({
      msg: "Entretien terminÃ© et dÃ©cision enregistrÃ©e",
      interview,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getCandidateInterviews = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { upcoming } = req.query;

    let query = { candidateId: candidate._id };

    if (upcoming === "true") {
      query.scheduledAt = { $gte: new Date() };
      
      query.status = {
        $nin: [
          "cancelled_by_candidate",
          "cancelled_by_recruiter",
          "completed",
          "no_show_candidate",
          "no_show_recruiter",
        ],
      };
    }

    const interviews = await Interview.find(query)
      .sort({ scheduledAt: 1 })
      .populate("offerId", "titre companyId")
      .populate({
        path: "offerId",
        populate: { path: "companyId", select: "name logo" },
      })
      .lean();

    const enriched = interviews.map((i) => ({
      _id: i._id,
      type: i.type,
      scheduledAt: i.scheduledAt,
      duration: i.duration,
      location: i.location,
      meetingLink: i.meetingLink,
      phoneNumber: i.phoneNumber,
      status: i.status,
      preparationNotes: i.preparationNotes,
      proposedAlternative: i.proposedAlternative,

      
      offerTitle: i.offerId?.titre,
      companyName: i.offerId?.companyId?.name,
      companyLogo: i.offerId?.companyId?.logo,

      
      needsResponse: ["proposed", "rescheduled_by_recruiter"].includes(
        i.status,
      ),
      isConfirmed: i.status === "confirmed",
      isPendingRecruiter: i.status === "rescheduled_by_candidate",
    }));

    res.json(enriched);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const acceptInterview = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { interviewId } = req.params;

    const interview = await Interview.findOneAndUpdate(
      {
        _id: interviewId,
        candidateId: candidate._id,
        status: { $in: ["proposed", "rescheduled_by_recruiter"] },
      },
      { status: "confirmed" },
      { new: true },
    );

    if (!interview) {
      return res
        .status(404)
        .json({ msg: "Entretien introuvable ou dÃ©jÃ  traitÃ©" });
    }

    
    const recruiter = await Recruiter.findById(interview.recruiterId);
    await Notification.create({
      userId: recruiter.userId,
      message: `Le candidat a confirmÃ© l'entretien`,
      type: "validation",
    });

    res.json({ msg: "Entretien confirmÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const declineInterview = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { interviewId } = req.params;
    const { reason } = req.body;

    const interview = await Interview.findOneAndUpdate(
      {
        _id: interviewId,
        candidateId: candidate._id,
        status: { $in: ["proposed", "rescheduled_by_recruiter"] },
      },
      { status: "cancelled_by_candidate" },
      { new: true },
    );

    if (!interview) {
      return res.status(404).json({ msg: "Entretien introuvable" });
    }

    const recruiter = await Recruiter.findById(interview.recruiterId);
    await Notification.create({
      userId: recruiter.userId,
      message: `Le candidat a dÃ©clinÃ© l'entretien${
        reason ? `: ${reason}` : ""
      }`,
      type: "info",
    });

    res.json({ msg: "Entretien dÃ©clinÃ©", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const proposeAlternativeDate = async (req, res) => {
  try {
    const candidate = await Candidate.findOne({ userId: req.user.id });
    const { interviewId } = req.params;
    const { newDate, message } = req.body;

    const interview = await Interview.findOne({
      _id: interviewId,
      candidateId: candidate._id,
      status: { $in: ["proposed", "rescheduled_by_recruiter"] },
    });

    if (!interview) {
      return res.status(404).json({ msg: "Entretien introuvable" });
    }

    interview.status = "rescheduled_by_candidate";
    interview.proposedAlternative = {
      date: new Date(newDate),
      proposedBy: "candidate",
      message,
      proposedAt: new Date(),
    };
    await interview.save();

    const recruiter = await Recruiter.findById(interview.recruiterId);
    await Notification.create({
      userId: recruiter.userId,
      message: `Le candidat propose une nouvelle date pour l'entretien`,
      type: "validation",
    });

    res.json({ msg: "Proposition envoyÃ©e", interview });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\notificationController.js ===
import Notification from "../models/Notification.js";

export const getMyNotifications = async (req, res) => {
  try {
    const notifications = await Notification.find({ userId: req.user.id }).sort(
      {
        date: -1,
      }
    );
    res.json(notifications);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getUnreadCount = async (req, res) => {
  try {
    const count = await Notification.countDocuments({
      userId: req.user.id,
      lu: false,
    });
    res.json({ count });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const markAsRead = async (req, res) => {
  try {
    const notification = await Notification.findOneAndUpdate(
      { _id: req.params.id, userId: req.user.id },
      { lu: true },
      { new: true }
    );

    if (!notification)
      return res.status(404).json({ msg: "Notification introuvable" });

    res.json(notification);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\offerController.js ===
import Offer from "../models/Offer.js";
import Company from "../models/Company.js";
import AnemOffer from "../models/AnemOffer.js";

const toCursor = (payload) => {
  return Buffer.from(JSON.stringify(payload)).toString("base64");
};

const fromCursor = (cursor) => {
  try {
    return JSON.parse(Buffer.from(cursor, "base64").toString("utf8"));
  } catch (e) {
    return null;
  }
};

export const getAllActiveOffers = async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    const {
      cursor,
      wilaya,
      sort,
      search,
      type,
      domaine,
      experienceLevel,
      minSalary,
      maxSalary,
      hasAnem,
    } = req.query;

    let query = { actif: true, validationStatus: "approved" };

    if (wilaya) {
      query.wilaya = { $regex: new RegExp(`^${wilaya}$`, "i") };
    }

    if (type) {
      query.type = type;
    }

    if (domaine) {
      query.domaine = domaine;
    }

    if (experienceLevel) {
      query.experienceLevel = experienceLevel;
    }

    if (minSalary) {
      query.salaryMax = { $gte: parseInt(minSalary) };
    }

    if (maxSalary) {
      query.salaryMin = { $lte: parseInt(maxSalary) };
    }

    
    if (hasAnem === "true" || hasAnem === "false") {
      const anemOfferIds = await AnemOffer.find({ anemEnabled: true }).distinct(
        "offerId",
      );
      if (hasAnem === "true") {
        query._id = { $in: anemOfferIds };
      } else {
        query._id = { $nin: anemOfferIds };
      }
    }

    if (search) {
      const matchingCompanies = await Company.find({
        name: { $regex: search, $options: "i" },
      }).select("_id");

      const companyIds = matchingCompanies.map((c) => c._id);

      query.$or = [
        { titre: { $regex: search, $options: "i" } },
        { description: { $regex: search, $options: "i" } },
        { skills: { $in: [new RegExp(search, "i")] } },
        { companyId: { $in: companyIds } },
      ];
    }

    if (cursor) {
      const decrypted = fromCursor(cursor);

      if (decrypted) {
        const { id, value } = decrypted;

        if (sort === "popular") {
          query.$and = [
            ...(query.$and || []),
            {
              $or: [
                { nombreCandidatures: { $lt: value } },
                { nombreCandidatures: value, _id: { $lt: id } },
              ],
            },
          ];
        } else {
          query.$and = [
            ...(query.$and || []),
            {
              $or: [
                { datePublication: { $lt: new Date(value) } },
                { datePublication: new Date(value), _id: { $lt: id } },
              ],
            },
          ];
        }
      }
    }

    let sortQuery = {};
    if (sort === "popular") {
      sortQuery = { nombreCandidatures: -1, _id: -1 };
    } else {
      sortQuery = { datePublication: -1, _id: -1 };
    }

    const offers = await Offer.find(query)
      .populate("companyId", "name logo location industry")
      .populate("recruteurId", "position")
      .sort(sortQuery)
      .limit(limit + 1);

    const hasNextPage = offers.length > limit;
    const data = hasNextPage ? offers.slice(0, limit) : offers;

    
    const offerIds = data.map((o) => o._id);
    const anemOffers = await AnemOffer.find({
      offerId: { $in: offerIds },
      anemEnabled: true,
    }).lean();
    const anemMap = new Map(
      anemOffers.map((a) => [a.offerId.toString(), true]),
    );

    const enrichedData = data.map((offer) => {
      const isNew =
        new Date() - new Date(offer.datePublication) < 2 * 24 * 60 * 60 * 1000;
      return {
        ...offer.toObject(),
        isNew,
        hasAnem: anemMap.has(offer._id.toString()),
      };
    });

    let nextCursor = null;
    if (hasNextPage && data.length > 0) {
      const lastItem = data[data.length - 1];

      const cursorValue =
        sort === "popular"
          ? lastItem.nombreCandidatures
          : lastItem.datePublication;

      nextCursor = toCursor({
        id: lastItem._id,
        value: cursorValue,
      });
    }

    res.json({
      data: enrichedData,
      meta: {
        nextCursor,
        hasNextPage,
        limit,
      },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: err.message });
  }
};

export const getOfferDetails = async (req, res) => {
  try {
    const offer = await Offer.findOne({ _id: req.params.id, actif: true })
      .populate("companyId", "name logo website description location size")
      .populate("recruteurId", "position");

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    const isNew =
      new Date() - new Date(offer.datePublication) < 2 * 24 * 60 * 60 * 1000;

    
    const anemOffer = await AnemOffer.findOne({
      offerId: offer._id,
      anemEnabled: true,
    }).lean();

    res.json({
      ...offer.toObject(),
      isNew,
      hasAnem: !!anemOffer,
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\passwordResetController.js ===
import bcrypt from "bcryptjs";
import User from "../models/User.js";
import VerificationToken from "../models/VerificationToken.js";
import SystemSettings from "../models/SystemSettings.js";
import {
  sendPasswordResetEmail,
  sendPasswordResetSuccessEmail,
} from "../services/emailService.js";


export const forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ msg: "L'adresse email est requise." });
    }

    const normalizedEmail = email.toLowerCase().trim();

    
    const user = await User.findOne({ email: normalizedEmail });

    
    const successMessage =
      "Si cette adresse email est associÃ©e Ã  un compte, vous recevrez un code de vÃ©rification.";

    if (!user) {
      
      return res.json({ msg: successMessage });
    }

    
    if (user.accountStatus === "banned") {
      return res.json({ msg: successMessage });
    }

    
    const result = await VerificationToken.createPasswordResetToken(user._id);

    if (!result.success) {
      return res.status(429).json({
        msg: result.error,
        retryAfter: result.retryAfter,
      });
    }

    
    const verificationMode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );

    console.log(`ðŸ“§ Password reset - Mode: ${verificationMode}`);

    if (verificationMode === "smtp") {
      try {
        await sendPasswordResetEmail(user.email, result.code, user.nom);
        console.log(`âœ… Password reset email sent to ${user.email}`);
      } catch (emailError) {
        console.error("âŒ Failed to send password reset email:", emailError);
        
      }
    } else {
      console.log(
        `\nðŸ“§ [DEV MODE] Password reset code for ${user.email}: ${result.code}\n`,
      );
    }

    res.json({
      msg: successMessage,
      
      ...(verificationMode === "development" && {
        devInfo: {
          code: result.code,
          expiresAt: result.expiresAt,
          requestsRemaining: result.requestsRemaining,
        },
      }),
    });
  } catch (err) {
    console.error("Forgot password error:", err);
    res
      .status(500)
      .json({ msg: "Une erreur est survenue. Veuillez rÃ©essayer." });
  }
};


export const verifyResetCode = async (req, res) => {
  try {
    const { email, code } = req.body;

    if (!email || !code) {
      return res.status(400).json({ msg: "Email et code requis." });
    }

    const normalizedEmail = email.toLowerCase().trim();

    
    const user = await User.findOne({ email: normalizedEmail });

    if (!user) {
      return res.status(400).json({
        msg: "Code invalide ou expirÃ©.",
      });
    }

    
    const verificationMode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );

    let verificationResult;

    if (verificationMode === "development" && code === "123456") {
      
      const token = await VerificationToken.findOne({
        userId: user._id,
        type: "password_reset",
      });

      if (!token) {
        return res.status(400).json({
          msg: "Aucune demande de rÃ©initialisation en cours. Veuillez en faire une nouvelle.",
        });
      }

      verificationResult = {
        valid: true,
        token: token.token,
      };
    } else {
      
      verificationResult = await VerificationToken.verifyCode(
        user._id,
        code,
        "password_reset",
      );
    }

    if (!verificationResult.valid) {
      return res.status(400).json({
        msg: verificationResult.error,
        attemptsRemaining: verificationResult.attemptsRemaining,
        locked: verificationResult.locked,
      });
    }

    
    res.json({
      msg: "Code vÃ©rifiÃ© avec succÃ¨s.",
      resetToken: verificationResult.token,
    });
  } catch (err) {
    console.error("Verify reset code error:", err);
    res
      .status(500)
      .json({ msg: "Une erreur est survenue. Veuillez rÃ©essayer." });
  }
};


export const resetPassword = async (req, res) => {
  try {
    const { resetToken, newPassword, confirmPassword } = req.body;

    if (!resetToken || !newPassword) {
      return res.status(400).json({
        msg: "Token de rÃ©initialisation et nouveau mot de passe requis.",
      });
    }

    
    if (newPassword.length < 8) {
      return res.status(400).json({
        msg: "Le mot de passe doit contenir au moins 8 caractÃ¨res.",
      });
    }

    if (!/[a-z]/.test(newPassword)) {
      return res.status(400).json({
        msg: "Le mot de passe doit contenir au moins une lettre minuscule.",
      });
    }

    if (!/[A-Z]/.test(newPassword)) {
      return res.status(400).json({
        msg: "Le mot de passe doit contenir au moins une lettre majuscule.",
      });
    }

    if (!/\d/.test(newPassword)) {
      return res.status(400).json({
        msg: "Le mot de passe doit contenir au moins un chiffre.",
      });
    }

    if (confirmPassword && newPassword !== confirmPassword) {
      return res.status(400).json({
        msg: "Les mots de passe ne correspondent pas.",
      });
    }

    
    const tokenResult = await VerificationToken.verifyResetToken(resetToken);

    if (!tokenResult.valid) {
      return res.status(400).json({
        msg: tokenResult.error,
      });
    }

    
    const user = await User.findById(tokenResult.userId);

    if (!user) {
      return res.status(400).json({
        msg: "Utilisateur introuvable.",
      });
    }

    
    const isSamePassword = await bcrypt.compare(newPassword, user.motDePasse);
    if (isSamePassword) {
      return res.status(400).json({
        msg: "Le nouveau mot de passe doit Ãªtre diffÃ©rent de l'ancien.",
      });
    }

    
    const hashedPassword = await bcrypt.hash(newPassword, 12);

    
    user.motDePasse = hashedPassword;
    user.emailVerified = true;
    await user.save();

    
    await VerificationToken.consumeResetToken(resetToken);

    
    const verificationMode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );

    if (verificationMode === "smtp") {
      try {
        await sendPasswordResetSuccessEmail(user.email, user.nom);
      } catch (emailError) {
        console.error(
          "Failed to send password reset success email:",
          emailError,
        );
      }
    } else {
      console.log(
        `\nðŸ“§ [DEV MODE] Password reset successful for ${user.email}\n`,
      );
    }

    res.json({
      msg: "Votre mot de passe a Ã©tÃ© rÃ©initialisÃ© avec succÃ¨s. Vous pouvez maintenant vous connecter.",
    });
  } catch (err) {
    console.error("Reset password error:", err);
    res
      .status(500)
      .json({ msg: "Une erreur est survenue. Veuillez rÃ©essayer." });
  }
};


export const checkResetToken = async (req, res) => {
  try {
    const { token } = req.params;

    if (!token) {
      return res.status(400).json({ valid: false });
    }

    const result = await VerificationToken.verifyResetToken(token);

    res.json({
      valid: result.valid,
      ...(result.valid && {
        expiresAt: result.expiresAt,
      }),
    });
  } catch (err) {
    res.status(500).json({ valid: false });
  }
};

export default {
  forgotPassword,
  verifyResetCode,
  resetPassword,
  checkResetToken,
};


=== controllers\recruiterApplicationController.js ===
import Application from "../models/Application.js";
import Interview from "../models/Interview.js";
import Conversation from "../models/Conversation.js";
import Offer from "../models/Offer.js";
import Candidate from "../models/Candidate.js";
import Recruiter from "../models/Recruiter.js";
import Notification from "../models/Notification.js";
import {
  mapRecruiterToCandidate,
  NOTIFY_CANDIDATE_STATUSES,
} from "../utils/statusMapping.js";


const getRecruiterProfile = async (userId) => {
  const recruiter = await Recruiter.findOne({ userId }).populate("companyId");
  if (!recruiter) throw new Error("Profil recruteur non trouvÃ©");
  return recruiter;
};


export const getOfferApplications = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { offerId } = req.params;
    const {
      status,
      starred,
      search,
      page = 1,
      limit = 20,
      sortBy = "datePostulation",
      sortOrder = "desc",
    } = req.query;

    
    const offer = await Offer.findOne({
      _id: offerId,
      recruteurId: recruiter._id,
    });

    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    let query = { offerId };

    if (status && status !== "all") {
      query.recruiterStatus = status;
    }

    if (starred === "true") {
      query.isStarred = true;
    }

    const skip = (page - 1) * limit;
    const sort = { [sortBy]: sortOrder === "desc" ? -1 : 1 };

    const [applications, total, statusCounts] = await Promise.all([
      Application.find(query)
        .sort(sort)
        .skip(skip)
        .limit(parseInt(limit))
        .populate({
          path: "candidateId",
          select: "profilePicture residence skills experiences userId",
          populate: { path: "userId", select: "nom email" },
        })
        .lean(),
      Application.countDocuments(query),
      Application.aggregate([
        { $match: { offerId: offer._id } },
        { $group: { _id: "$recruiterStatus", count: { $sum: 1 } } },
      ]),
    ]);

    
    const enriched = await Promise.all(
      applications
        .filter((app) => app.candidateId !== null)
        .map(async (app) => {
          const [conversation, upcomingInterview] = await Promise.all([
            Conversation.findOne({ applicationId: app._id })
              .select("unreadByRecruiter lastMessageAt")
              .lean(),
            Interview.findOne({
              applicationId: app._id,
              status: {
                $in: ["proposed", "confirmed", "rescheduled_by_candidate"],
              },
              scheduledAt: { $gte: new Date() },
            })
              .sort({ scheduledAt: 1 })
              .lean(),
          ]);

          return {
            _id: app._id,
            status: app.recruiterStatus,
            candidateStatus: app.candidateStatus,
            source: app.source,
            isStarred: app.isStarred,
            seenByRecruiter: app.seenByRecruiter,
            datePostulation: app.datePostulation,
            recruiterNotes: app.recruiterNotes,
            candidate: {
              _id: app.candidateId._id,
              nom: app.candidateId.userId?.nom,
              email: app.candidateId.userId?.email,
              profilePicture: app.candidateId.profilePicture,
              residence: app.candidateId.residence,
              skillsCount: app.candidateId.skills?.length || 0,
              experiencesCount: app.candidateId.experiences?.length || 0,
            },
            cvUrl: app.cvUrl,
            hasConversation: !!conversation,
            unreadMessages: conversation?.unreadByRecruiter || 0,
            upcomingInterview: upcomingInterview
              ? {
                  _id: upcomingInterview._id,
                  scheduledAt: upcomingInterview.scheduledAt,
                  status: upcomingInterview.status,
                  needsAction:
                    upcomingInterview.status === "rescheduled_by_candidate",
                }
              : null,
          };
        }),
    );

    
    const countsMap = {};
    statusCounts.forEach((s) => {
      countsMap[s._id] = s.count;
    });

    res.json({
      data: enriched,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
      statusCounts: countsMap,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const markAsSeen = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { applicationId } = req.params;

    const application =
      await Application.findById(applicationId).populate("offerId");

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    if (
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(403).json({ msg: "Non autorisÃ©" });
    }

    if (!application.seenByRecruiter) {
      application.seenByRecruiter = true;
      application.seenAt = new Date();

      if (application.recruiterStatus === "nouvelle") {
        application.recruiterStatus = "consultee";
        application.candidateStatus = mapRecruiterToCandidate("consultee");
        application.statusHistory.push({
          candidateStatus: application.candidateStatus,
          recruiterStatus: "consultee",
          changedBy: req.user.id,
        });
      }

      await application.save();
    }

    res.json({ msg: "MarquÃ©e comme vue", application });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateRecruiterStatus = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { applicationId } = req.params;
    const { status, notes } = req.body;

    const application =
      await Application.findById(applicationId).populate("offerId");

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    if (
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(403).json({ msg: "Non autorisÃ©" });
    }

    
    const validTransitions = {
      nouvelle: ["consultee", "preselection", "refusee"],
      consultee: ["preselection", "en_discussion", "refusee"],
      preselection: ["en_discussion", "entretien_planifie", "refusee"],
      en_discussion: ["preselection", "entretien_planifie", "refusee"],
      entretien_planifie: ["entretien_termine", "refusee"],
      entretien_termine: ["retenue", "refusee", "entretien_planifie"], 
    };

    const allowed = validTransitions[application.recruiterStatus] || [];
    if (!allowed.includes(status)) {
      return res.status(400).json({
        msg: `Transition non autorisÃ©e de "${application.recruiterStatus}" vers "${status}"`,
      });
    }

    const previousRecruiterStatus = application.recruiterStatus;
    application.recruiterStatus = status;
    application.candidateStatus = mapRecruiterToCandidate(status);

    if (notes) {
      application.recruiterNotes = notes;
    }

    if (status === "retenue" || status === "refusee") {
      application.dateDecision = new Date();
    }

    application.statusHistory.push({
      candidateStatus: application.candidateStatus,
      recruiterStatus: status,
      changedBy: req.user.id,
      note: notes,
    });

    await application.save();

    
    if (NOTIFY_CANDIDATE_STATUSES.includes(status)) {
      const candidate = await Candidate.findById(application.candidateId);
      const statusMessages = {
        retenue: `Bonne nouvelle ! Votre candidature pour "${application.offerId.titre}" a Ã©tÃ© retenue.`,
        refusee: `Votre candidature pour "${application.offerId.titre}" n'a pas Ã©tÃ© retenue.`,
      };

      await Notification.create({
        userId: candidate.userId,
        message: statusMessages[status],
        type: status === "retenue" ? "validation" : "info",
      });
    }

    res.json({
      msg: "Statut mis Ã  jour",
      application: {
        _id: application._id,
        recruiterStatus: application.recruiterStatus,
        candidateStatus: application.candidateStatus,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const toggleStarred = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { applicationId } = req.params;

    const application =
      await Application.findById(applicationId).populate("offerId");

    if (
      !application ||
      application.offerId.recruteurId.toString() !== recruiter._id.toString()
    ) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    application.isStarred = !application.isStarred;
    await application.save();

    res.json({
      msg: application.isStarred
        ? "AjoutÃ©e aux favoris"
        : "RetirÃ©e des favoris",
      isStarred: application.isStarred,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateNotes = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { applicationId } = req.params;
    const { notes } = req.body;

    const application = await Application.findOneAndUpdate(
      {
        _id: applicationId,
        offerId: {
          $in: await Offer.find({ recruteurId: recruiter._id }).distinct("_id"),
        },
      },
      { recruiterNotes: notes },
      { new: true },
    );

    if (!application) {
      return res.status(404).json({ msg: "Candidature introuvable" });
    }

    res.json({ msg: "Notes mises Ã  jour", notes: application.recruiterNotes });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getAllApplicationsAdvanced = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const {
      status,
      offerId,
      starred,
      hasConversation,
      conversationActive, 
      source, 
      sortBy = "datePostulation",
      sortOrder = "desc",
      page = 1,
      limit = 20,
    } = req.query;

    const myOfferIds = await Offer.find({
      recruteurId: recruiter._id,
    }).distinct("_id");

    let query = { offerId: { $in: myOfferIds } };

    
    if (status && status !== "all") {
      query.recruiterStatus = status;
    }
    if (offerId) {
      query.offerId = offerId;
    }
    if (starred === "true") {
      query.isStarred = true;
    }
    if (source) {
      query.source = source;
    }

    const skip = (page - 1) * limit;
    const sort = { [sortBy]: sortOrder === "desc" ? -1 : 1 };

    let applications = await Application.find(query)
      .sort(sort)
      .skip(skip)
      .limit(parseInt(limit))
      .populate("offerId", "titre")
      .populate({
        path: "candidateId",
        select: "profilePicture userId desiredPosition residence skills",
        populate: { path: "userId", select: "nom email" },
      })
      .lean();

    
    const enriched = await Promise.all(
      applications
        .filter((app) => app.candidateId)
        .map(async (app) => {
          const conversation = await Conversation.findOne({
            applicationId: app._id,
          })
            .select("candidateHasReplied unreadByRecruiter lastMessageAt")
            .lean();

          const upcomingInterview = await Interview.findOne({
            applicationId: app._id,
            status: {
              $in: [
                "proposed",
                "confirmed",
                "rescheduled_by_candidate",
                "rescheduled_by_recruiter",
              ],
            },
            scheduledAt: { $gte: new Date() },
          })
            .sort({ scheduledAt: 1 })
            .lean();

          return {
            _id: app._id,
            status: app.recruiterStatus,
            source: app.source,
            proposedBy: app.proposedBy,
            isStarred: app.isStarred,
            datePostulation: app.datePostulation,
            offer: {
              _id: app.offerId?._id,
              titre: app.offerId?.titre,
            },
            candidate: {
              _id: app.candidateId._id,
              nom: app.candidateId.userId?.nom,
              email: app.candidateId.userId?.email,
              profilePicture: app.candidateId.profilePicture,
              desiredPosition: app.candidateId.desiredPosition,
              wilaya: app.candidateId.residence?.wilaya,
            },
            conversation: conversation
              ? {
                  exists: true,
                  isActive: conversation.candidateHasReplied,
                  unreadCount: conversation.unreadByRecruiter,
                  lastMessageAt: conversation.lastMessageAt,
                }
              : {
                  exists: false,
                  isActive: false,
                },
            interview: upcomingInterview
              ? {
                  exists: true,
                  scheduledAt: upcomingInterview.scheduledAt,
                  status: upcomingInterview.status,
                }
              : null,
          };
        }),
    );

    
    let filtered = enriched;
    if (hasConversation === "true") {
      filtered = filtered.filter((a) => a.conversation.exists);
    }
    if (hasConversation === "false") {
      filtered = filtered.filter((a) => !a.conversation.exists);
    }
    if (conversationActive === "true") {
      filtered = filtered.filter((a) => a.conversation.isActive);
    }
    if (conversationActive === "false") {
      filtered = filtered.filter(
        (a) => a.conversation.exists && !a.conversation.isActive,
      );
    }

    const total = await Application.countDocuments(query);

    res.json({
      data: filtered,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const markAllOfferApplicationsAsSeen = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { offerId } = req.params;

    
    const offer = await Offer.findOne({
      _id: offerId,
      recruteurId: recruiter._id,
    });

    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    const result = await Application.updateMany(
      {
        offerId,
        seenByRecruiter: false,
      },
      {
        $set: {
          seenByRecruiter: true,
          seenAt: new Date(),
        },
      },
    );

    
    await Application.updateMany(
      {
        offerId,
        recruiterStatus: "nouvelle",
      },
      {
        $set: {
          recruiterStatus: "consultee",
          candidateStatus: "en_cours",
        },
        $push: {
          statusHistory: {
            candidateStatus: "en_cours",
            recruiterStatus: "consultee",
            changedBy: req.user.id,
            note: "Vue en masse",
          },
        },
      },
    );

    res.json({
      msg: "Candidatures marquÃ©es comme vues",
      modifiedCount: result.modifiedCount,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\recruiterController.js ===
import Offer from "../models/Offer.js";
import Recruiter from "../models/Recruiter.js";
import User from "../models/User.js";
import Candidate from "../models/Candidate.js";
import Company from "../models/Company.js";
import Notification from "../models/Notification.js";
import Application from "../models/Application.js";
import Admin from "../models/Admin.js";
import bcrypt from "bcryptjs";
import AnemOffer from "../models/AnemOffer.js";
import { createAnemOffer } from "./anemOfferController.js";

const getRecruiterProfile = async (userId) => {
  const recruiter = await Recruiter.findOne({ userId }).populate("companyId");
  if (!recruiter) throw new Error("Profil recruteur non trouvÃ©");
  return recruiter;
};

export const createOffer = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    const recruiter = await getRecruiterProfile(req.user.id);

    if (!user.emailVerified) {
      return res.status(403).json({
        msg: "Veuillez confirmer votre email.",
        code: "EMAIL_NOT_VERIFIED",
      });
    }

    if (recruiter.status !== "validated") {
      return res.status(403).json({
        msg: "Votre compte recruteur n'est pas validÃ©.",
        code: "RECRUITER_NOT_VALIDATED",
        recruiterStatus: recruiter.status,
      });
    }

    if (recruiter.companyId.status !== "active") {
      return res.status(403).json({
        msg: "Votre entreprise n'est pas encore validÃ©e.",
        code: "COMPANY_NOT_VALIDATED",
      });
    }

    if (!recruiter.permissions.postJobs) {
      return res.status(403).json({
        msg: "Vous n'avez pas la permission de publier des offres.",
        code: "PERMISSION_DENIED",
      });
    }

    const {
      titre,
      description,
      requirements,
      domaine,
      type,
      salaryMin,
      salaryMax,
      experienceLevel,
      skills,
      wilaya,
      visibility,
      candidateSearchMode,
      allowRepostulation,
      enableAnem, 
    } = req.body;

    if (!titre || !description || !requirements) {
      return res.status(400).json({
        msg: "Titre, description et requirements sont obligatoires.",
      });
    }

    
    if (enableAnem && !recruiter.canCreateAnemOffer()) {
      return res.status(403).json({
        msg: "Vous devez Ãªtre enregistrÃ© ANEM pour activer cette fonctionnalitÃ©.",
        code: "ANEM_NOT_REGISTERED",
        anemStatus: recruiter.anem.status,
      });
    }

    const newOffer = new Offer({
      recruteurId: recruiter._id,
      companyId: recruiter.companyId._id,
      titre,
      description,
      requirements,
      domaine,
      type: type || "full-time",
      salaryMin,
      salaryMax,
      allowRepostulation:
        allowRepostulation !== undefined ? allowRepostulation : true,
      experienceLevel,
      skills: skills || [],
      wilaya,
      visibility: visibility || {
        isPublic: true,
        acceptsDirectApplications: true,
      },
      candidateSearchMode: candidateSearchMode || "disabled",
      validationStatus: "pending",
      actif: false,
      datePublication: null,
    });

    const savedOffer = await newOffer.save();

    
    let anemData = null;
    if (enableAnem && recruiter.canCreateAnemOffer()) {
      try {
        anemData = await createAnemOffer(
          savedOffer._id,
          recruiter._id,
          recruiter.anem.registrationId,
          recruiter.anem.anemId,
        );
      } catch (anemErr) {
        console.error("Error creating ANEM offer:", anemErr);
        
      }
    }

    
    const admins = await User.find({ role: "admin" });
    const notificationPromises = admins.map((admin) =>
      Notification.create({
        userId: admin._id,
        message: `Nouvelle offre Ã  valider : "${savedOffer.titre}" de ${recruiter.companyId.name}`,
        type: "info",
      }),
    );
    await Promise.all(notificationPromises);

    res.status(201).json({
      msg: "Offre crÃ©Ã©e et en attente de validation âœ…",
      offer: savedOffer,
      anem: anemData
        ? {
            enabled: true,
            anemId: anemData.anemId,
          }
        : null,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getMyOffers = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);

    const offers = await Offer.find({ recruteurId: recruiter._id }).sort({
      createdAt: -1,
    });

    
    const offerIds = offers.map((o) => o._id);
    const anemOffers = await AnemOffer.find({
      offerId: { $in: offerIds },
    }).lean();
    const anemMap = new Map(anemOffers.map((a) => [a.offerId.toString(), a]));

    const enrichedOffers = offers.map((offer) => {
      const anem = anemMap.get(offer._id.toString());
      return {
        ...offer.toObject(),
        anem: anem
          ? {
              enabled: anem.anemEnabled,
              anemId: anem.anemId,
              enabledAt: anem.enabledAt,
            }
          : null,
      };
    });

    res.json(enrichedOffers);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getMyOffersWithStats = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);

    const offers = await Offer.aggregate([
      { $match: { recruteurId: recruiter._id } },
      {
        $lookup: {
          from: "applications",
          localField: "_id",
          foreignField: "offerId",
          as: "applications",
        },
      },
      {
        $lookup: {
          from: "anemoffers",
          localField: "_id",
          foreignField: "offerId",
          as: "anemData",
        },
      },
      {
        $addFields: {
          totalApplications: { $size: "$applications" },
          newApplications: {
            $size: {
              $filter: {
                input: "$applications",
                cond: { $eq: ["$$this.seenByRecruiter", false] },
              },
            },
          },
          inDiscussion: {
            $size: {
              $filter: {
                input: "$applications",
                cond: { $eq: ["$$this.recruiterStatus", "en_discussion"] },
              },
            },
          },
          starredCount: {
            $size: {
              $filter: {
                input: "$applications",
                cond: { $eq: ["$$this.isStarred", true] },
              },
            },
          },
          anem: {
            $cond: {
              if: { $gt: [{ $size: "$anemData" }, 0] },
              then: {
                enabled: { $arrayElemAt: ["$anemData.anemEnabled", 0] },
                anemId: { $arrayElemAt: ["$anemData.anemId", 0] },
                enabledAt: { $arrayElemAt: ["$anemData.enabledAt", 0] },
              },
              else: null,
            },
          },
        },
      },
      {
        $project: {
          applications: 0,
          anemData: 0,
        },
      },
      { $sort: { createdAt: -1 } },
    ]);

    res.json(offers);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const getRecruiterOfferDetails = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { id } = req.params;

    const offer = await Offer.findById(id);

    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    
    if (offer.recruteurId.toString() !== recruiter._id.toString()) {
      return res
        .status(403)
        .json({ msg: "Action non autorisÃ©e. Ce n'est pas votre offre." });
    }

    
    const anemOffer = await AnemOffer.findOne({
      offerId: offer._id,
    }).lean();

    res.json({
      ...offer.toObject(),
      anem: anemOffer
        ? {
            enabled: anemOffer.anemEnabled,
            anemId: anemOffer.anemId,
          }
        : null,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};
export const updateOffer = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const offer = await Offer.findById(req.params.id);

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });

    if (offer.recruteurId.toString() !== recruiter._id.toString()) {
      return res.status(403).json({ msg: "Action non autorisÃ©e" });
    }

    const { enableAnem, ...offerData } = req.body;

    
    if (enableAnem !== undefined) {
      const existingAnem = await AnemOffer.findOne({ offerId: offer._id });

      if (enableAnem) {
        
        if (!recruiter.canCreateAnemOffer()) {
          return res.status(403).json({
            msg: "Vous devez Ãªtre enregistrÃ© ANEM pour activer cette fonctionnalitÃ©.",
            code: "ANEM_NOT_REGISTERED",
            anemStatus: recruiter.anem.status,
          });
        }

        if (existingAnem) {
          existingAnem.anemEnabled = true;
          existingAnem.anemId = recruiter.anem.anemId;
          existingAnem.enabledAt = new Date();
          existingAnem.disabledAt = undefined;
          await existingAnem.save();
        } else {
          await createAnemOfferAssociation(
            offer._id,
            recruiter._id,
            recruiter.anem.registrationId,
            recruiter.anem.anemId,
          );
        }
      } else {
        
        if (existingAnem && existingAnem.anemEnabled) {
          existingAnem.anemEnabled = false;
          existingAnem.disabledAt = new Date();
          await existingAnem.save();
        }
      }
    }

    const updatedOffer = await Offer.findByIdAndUpdate(
      req.params.id,
      { $set: offerData },
      { new: true },
    );

    
    const anemOffer = await AnemOffer.findOne({
      offerId: updatedOffer._id,
    }).lean();

    res.json({
      msg: "Offre mise Ã  jour âœ…",
      offer: updatedOffer,
      anem: anemOffer
        ? {
            enabled: anemOffer.anemEnabled,
            anemId: anemOffer.anemId,
          }
        : null,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const deactivateOffer = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const offer = await Offer.findById(req.params.id);

    if (!offer) return res.status(404).json({ msg: "Offre introuvable" });
    if (offer.recruteurId.toString() !== recruiter._id.toString()) {
      return res.status(403).json({ msg: "Action non autorisÃ©e" });
    }

    offer.actif = false;
    await offer.save();

    res.json({ msg: "Offre dÃ©sactivÃ©e â›”", offer });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const updateRecruiterProfile = async (req, res) => {
  try {
    const userId = req.user.id;

    const { nom, motDePasse, telephone } = req.body;

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ msg: "Utilisateur introuvable" });

    if (nom) user.nom = nom;
    if (motDePasse) {
      const hash = await bcrypt.hash(motDePasse, 10);
      user.motDePasse = hash;
    }
    await user.save();

    const recruiter = await Recruiter.findOne({ userId });
    if (!recruiter)
      return res.status(404).json({ msg: "Profil recruteur introuvable" });

    if (telephone) recruiter.telephone = telephone;

    await recruiter.save();

    res.json({
      msg: "Profil mis Ã  jour avec succÃ¨s âœ…",
      user: { nom: user.nom, email: user.email },
      recruiter: {
        telephone: recruiter.telephone,
        position: recruiter.position,
        isAdmin: recruiter.isAdmin,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

function getStatusMessage(status) {
  const messages = {
    pending_validation: "En attente de validation initiale",
    pending_documents: "Documents demandÃ©s par l'administration",
    pending_info: "Informations complÃ©mentaires demandÃ©es",
    pending_revalidation: "RÃ©ponse en cours d'examen",
    rejected: "Compte refusÃ©",
  };
  return messages[status] || status;
}

export const updateCompanyDetails = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);

    if (!recruiter.isAdmin) {
      return res.status(403).json({
        msg: "AccÃ¨s refusÃ©. Seul l'administrateur de l'entreprise peut modifier ces informations.",
      });
    }

    const { website, description, industry, location, size, logo } = req.body;

    const updatedCompany = await Company.findByIdAndUpdate(
      recruiter.companyId._id,
      {
        $set: {
          website,
          description,
          industry,
          location,
          size,
          logo,
        },
      },
      { new: true },
    );

    res.json({
      msg: "Informations de l'entreprise mises Ã  jour âœ…",
      company: updatedCompany,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getRecruiterDashboard = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);

    const now = new Date();
    const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);

    const myOfferIds = await Offer.find({
      recruteurId: recruiter._id,
    }).distinct("_id");

    const [
      activeOffers,
      pendingOffers,
      rejectedOffers,
      totalApplications,
      newApplicationsThisWeek,
      applicationsByStatus,
      topOffers,
      recentApplications,
      anemOffersCount,
    ] = await Promise.all([
      Offer.countDocuments({
        recruteurId: recruiter._id,
        actif: true,
        validationStatus: "approved",
      }),
      Offer.countDocuments({
        recruteurId: recruiter._id,
        validationStatus: "pending",
      }),
      Offer.countDocuments({
        recruteurId: recruiter._id,
        validationStatus: { $in: ["rejected", "changes_requested"] },
      }),
      Application.countDocuments({ offerId: { $in: myOfferIds } }),
      Application.countDocuments({
        offerId: { $in: myOfferIds },
        datePostulation: { $gte: sevenDaysAgo },
      }),
      Application.aggregate([
        { $match: { offerId: { $in: myOfferIds } } },
        { $group: { _id: "$status", count: { $sum: 1 } } },
      ]),
      Offer.find({ recruteurId: recruiter._id, actif: true })
        .sort({ nombreCandidatures: -1 })
        .limit(5)
        .select("titre nombreCandidatures datePublication"),
      Application.find({ offerId: { $in: myOfferIds } })
        .populate({
          path: "candidateId",
          select: "profilePicture",
          populate: { path: "userId", select: "nom" },
        })
        .populate("offerId", "titre")
        .sort({ datePostulation: -1 })
        .limit(10),
      AnemOffer.countDocuments({
        recruiterId: recruiter._id,
        anemEnabled: true,
      }),
    ]);

    const statusMap = {};
    applicationsByStatus.forEach((s) => {
      statusMap[s._id] = s.count;
    });

    const alerts = [];
    if (recruiter.companyId.status !== "active") {
      alerts.push({
        type: "warning",
        message: "Votre entreprise est en attente de validation",
      });
    }
    if (recruiter.status !== "validated") {
      alerts.push({
        type: "warning",
        message: `Statut du compte : ${recruiter.status}`,
        statusMessage: getStatusMessage(recruiter.status),
      });
    }
    if (pendingOffers > 0) {
      alerts.push({
        type: "info",
        message: `${pendingOffers} offre(s) en attente de validation`,
      });
    }
    if (rejectedOffers > 0) {
      alerts.push({
        type: "error",
        message: `${rejectedOffers} offre(s) nÃ©cessitent des modifications`,
      });
    }

    const pendingRequests = recruiter.validationRequests.filter(
      (r) => r.status === "pending",
    );
    if (pendingRequests.length > 0) {
      alerts.push({
        type: "action_required",
        message: "Des documents ou informations sont demandÃ©s",
        requests: pendingRequests,
      });
    }

    res.json({
      overview: {
        activeOffers,
        pendingOffers,
        rejectedOffers,
        totalApplications,
        newApplicationsThisWeek,
        anemOffersCount,
      },
      applicationsByStatus: statusMap,
      topOffers,
      recentApplications,
      company: {
        name: recruiter.companyId.name,
        status: recruiter.companyId.status,
        logo: recruiter.companyId.logo,
      },
      recruiterStatus: recruiter.status,
      anem: {
        status: recruiter.anem.status,
        anemId: recruiter.anem.anemId,
        isRegistered: recruiter.canCreateAnemOffer(),
      },
      alerts,
      permissions: recruiter.permissions,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getOfferStats = async (req, res) => {
  try {
    const recruiter = await getRecruiterProfile(req.user.id);
    const { offerId } = req.params;

    const offer = await Offer.findOne({
      _id: offerId,
      recruteurId: recruiter._id,
    });

    if (!offer) {
      return res.status(404).json({ msg: "Offre introuvable" });
    }

    const [applicationsByStatus, applicationsByDay, anemOffer] =
      await Promise.all([
        Application.aggregate([
          { $match: { offerId: offer._id } },
          { $group: { _id: "$status", count: { $sum: 1 } } },
        ]),
        Application.aggregate([
          { $match: { offerId: offer._id } },
          {
            $group: {
              _id: {
                $dateToString: { format: "%Y-%m-%d", date: "$datePostulation" },
              },
              count: { $sum: 1 },
            },
          },
          { $sort: { _id: 1 } },
          { $limit: 30 },
        ]),
        AnemOffer.findOne({ offerId: offer._id }).lean(),
      ]);

    const statusMap = {};
    applicationsByStatus.forEach((s) => {
      statusMap[s._id] = s.count;
    });

    res.json({
      offer: {
        _id: offer._id,
        titre: offer.titre,
        actif: offer.actif,
        validationStatus: offer.validationStatus,
        datePublication: offer.datePublication,
        nombreCandidatures: offer.nombreCandidatures,
      },
      anem: anemOffer
        ? {
            enabled: anemOffer.anemEnabled,
            anemId: anemOffer.anemId,
            enabledAt: anemOffer.enabledAt,
          }
        : null,
      applicationsByStatus: statusMap,
      applicationsByDay,
      conversionRate:
        offer.nombreCandidatures > 0
          ? Math.round(
              ((statusMap["retenue"] || 0) / offer.nombreCandidatures) * 100,
            )
          : 0,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getRecruiterProfileEndpoint = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id })
      .populate("userId", "nom email emailVerified")
      .populate("companyId")
      .populate("anem.registrationId");

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil recruteur introuvable" });
    }

    const alerts = [];
    const user = await User.findById(req.user.id);

    if (!user.emailVerified) {
      alerts.push({
        type: "critical",
        message: "Email non vÃ©rifiÃ©",
        action: "verify_email",
      });
    }

    if (recruiter.status === "pending_validation") {
      alerts.push({
        type: "warning",
        message: "Compte en attente de validation par un administrateur",
      });
    }

    if (recruiter.status === "rejected") {
      alerts.push({
        type: "error",
        message: "Compte rejetÃ©",
        reason: recruiter.rejectionReason,
      });
    }

    if (recruiter.companyId?.status === "pending") {
      alerts.push({
        type: "warning",
        message: "Entreprise en attente de validation",
      });
    }

    const pendingRequests = recruiter.validationRequests?.filter(
      (r) => r.status === "pending",
    );

    if (pendingRequests?.length > 0) {
      alerts.push({
        type: "action_required",
        message:
          "Des documents ou informations sont demandÃ©s par l'administration",
        requests: pendingRequests,
      });
    }

    res.json({
      recruiter,
      alerts,
      canPostOffers:
        user.emailVerified &&
        recruiter.status === "validated" &&
        recruiter.companyId?.status === "active" &&
        recruiter.permissions.postJobs,
      anem: {
        status: recruiter.anem.status,
        anemId: recruiter.anem.anemId,
        isRegistered: recruiter.canCreateAnemOffer(),
        hasSeenModal: recruiter.anem.hasSeenAnemModal,
        declinedAnem: recruiter.anem.declinedAnem,
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCompanyTeam = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil introuvable" });
    }

    const team = await Recruiter.find({ companyId: recruiter.companyId })
      .populate("userId", "nom email")
      .select("position permissions isAdmin status createdAt");

    res.json(team);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const submitValidationResponse = async (req, res) => {
  try {
    const recruiter = await Recruiter.findOne({ userId: req.user.id });

    if (!recruiter) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const { requestId, text } = req.body;
    const documents = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    const request = recruiter.validationRequests.id(requestId);

    if (!request) {
      return res.status(404).json({ msg: "Demande introuvable." });
    }

    if (request.status !== "pending") {
      return res.status(400).json({ msg: "Cette demande a dÃ©jÃ  Ã©tÃ© traitÃ©e." });
    }

    request.response = {
      text,
      documents,
      submittedAt: new Date(),
    };
    request.status = "submitted";

    recruiter.status = "pending_revalidation";

    await recruiter.save();

    const admins = await Admin.find({
      "permissions.validateRecruiters": true,
      status: "active",
    }).populate("userId", "_id");

    const notifPromises = admins.map((admin) =>
      Notification.create({
        userId: admin.userId._id,
        message: `Le recruteur a rÃ©pondu Ã  une demande de validation.`,
        type: "info",
      }),
    );
    await Promise.all(notifPromises);

    res.json({ msg: "RÃ©ponse soumise. Vous serez notifiÃ© du rÃ©sultat." });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getRecruiterById = async (req, res) => {
  try {
    const { id } = req.params;

    const recruiter = await Recruiter.findById(id)
      .populate("userId", "nom email role accountStatus createdAt")
      .populate("companyId", "name logo website location description status");

    if (!recruiter) {
      return res.status(404).json({ msg: "Recruteur introuvable" });
    }

    const isAdmin = req.user && req.user.role === "admin";

    if (!isAdmin) {
      if (recruiter.status !== "validated") {
        return res.status(404).json({ msg: "Ce profil n'est pas accessible." });
      }

      if (recruiter.companyId?.status !== "active") {
        return res
          .status(404)
          .json({ msg: "L'entreprise de ce recruteur n'est pas active." });
      }
    }

    let responseData = {
      _id: recruiter._id,
      nom: recruiter.userId.nom,
      position: recruiter.position,
      entreprise: {
        _id: recruiter.companyId._id,
        nom: recruiter.companyId.name,
        logo: recruiter.companyId.logo,
        location: recruiter.companyId.location,
        website: recruiter.companyId.website,
        description: recruiter.companyId.description,
      },
      dateCreation: recruiter.createdAt,
    };

    if (isAdmin) {
      responseData.adminDetails = {
        email: recruiter.userId.email,
        telephone: recruiter.telephone,
        status: recruiter.status,
        userStatus: recruiter.userId.accountStatus,
        isAdminOfCompany: recruiter.isAdmin,
        permissions: recruiter.permissions,
        validationRequests: recruiter.validationRequests,
        rejectionReason: recruiter.rejectionReason,
        userId: recruiter.userId._id,
        anem: recruiter.anem,
      };
    }

    res.json(responseData);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getCandidateFullProfile = async (req, res) => {
  try {
    const { candidateId } = req.params;

    const candidate = await Candidate.findById(candidateId)
      .populate("userId", "nom email")
      .select("-favoris");

    if (!candidate) {
      return res.status(404).json({ msg: "Candidat introuvable" });
    }

    res.json(candidate);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== controllers\skillController.js ===
import Skill from "../models/Skills.js";
import SkillCluster from "../models/SkillCluster.js";
import SkillFeedback from "../models/SkillFeedback.js";
import ProposedSkill from "../models/ProposedSkill.js";
import Candidate from "../models/Candidate.js";
import User from "../models/User.js";
import SystemSettings from "../models/SystemSettings.js";
import { logAdminAction } from "../models/AdminLog.js";



const ABUSE_PATTERNS = [
  /\b(ceo of|king of|lord of|god of|master of)\b/i,
  /\b(fuck|shit|ass|porn|xxx|dick|pussy|bitch)\b/i,
  /(.)\1{4,}/i, 
  /^.{0,1}$/i, 
  /^.{100,}$/i, 
];

const detectAbuse = (text) => {
  for (const pattern of ABUSE_PATTERNS) {
    if (pattern.test(text)) {
      return true;
    }
  }
  return false;
};



const levenshtein = (a, b) => {
  const matrix = Array.from({ length: a.length + 1 }, (_, i) =>
    Array.from({ length: b.length + 1 }, (_, j) =>
      i === 0 ? j : j === 0 ? i : 0,
    ),
  );
  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,
        matrix[i][j - 1] + 1,
        matrix[i - 1][j - 1] + cost,
      );
    }
  }
  return matrix[a.length][b.length];
};

const similarity = (a, b) => {
  const maxLen = Math.max(a.length, b.length);
  if (maxLen === 0) return 1;
  return 1 - levenshtein(a, b) / maxLen;
};

const findBestMatch = async (rawText, threshold = 0.6) => {
  const normalized = rawText.trim().toLowerCase();

  
  const exactMatch = await Skill.findOne({
    name: normalized,
    isHidden: { $ne: true },
  });
  if (exactMatch) {
    return { match: exactMatch, type: "exact", confidence: 1.0 };
  }

  
  const aliasMatch = await Skill.findOne({
    aliases: normalized,
    isHidden: { $ne: true },
  });
  if (aliasMatch) {
    return { match: aliasMatch, type: "alias", confidence: 0.95 };
  }

  
  const prefix = normalized.substring(
    0,
    Math.max(2, Math.floor(normalized.length * 0.5)),
  );
  const candidates = await Skill.find({
    $or: [
      { name: { $regex: prefix, $options: "i" } },
      { aliases: { $regex: prefix, $options: "i" } },
    ],
    isHidden: { $ne: true },
  })
    .limit(50)
    .lean();

  let bestScore = 0;
  let bestCandidate = null;

  for (const skill of candidates) {
    const nameScore = similarity(normalized, skill.name);
    let maxAliasScore = 0;
    for (const alias of skill.aliases || []) {
      const aliasScore = similarity(normalized, alias);
      if (aliasScore > maxAliasScore) maxAliasScore = aliasScore;
    }
    const score = Math.max(nameScore, maxAliasScore);
    if (score > bestScore) {
      bestScore = score;
      bestCandidate = skill;
    }
  }

  if (bestScore >= threshold && bestCandidate) {
    return {
      match: bestCandidate,
      type: bestScore >= 0.9 ? "alias" : "fuzzy",
      confidence: bestScore,
    };
  }

  return { match: null, type: "unmatched", confidence: 0 };
};






export const getSkills = async (req, res) => {
  try {
    const { search, category } = req.query;

    const suggestionsEnabled = await SystemSettings.getSetting(
      "skill_suggestions_enabled",
      true,
    );

    if (!suggestionsEnabled && search) {
      return res.json({ skills: [], categories: [] });
    }

    let query = { isHidden: { $ne: true } };

    if (search) {
      const escaped = search.trim().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      query.$or = [
        { name: { $regex: escaped, $options: "i" } },
        { aliases: { $regex: escaped, $options: "i" } },
      ];
    }

    if (category) {
      query.category = category;
    }

    const skills = await Skill.find(query)
      .sort({ usageCount: -1, name: 1 })
      .limit(50)
      .select("name category subCategory aliases usageCount")
      .lean();

    const categories = await Skill.distinct("category", {
      isHidden: { $ne: true },
    });

    res.json({
      skills,
      categories: categories.filter(Boolean),
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getSkillProposalStatus = async (req, res) => {
  try {
    const settings = await SystemSettings.getMultipleSettings([
      "skill_proposal_enabled",
      "skill_system_enabled",
      "max_skills_per_candidate",
      "skill_level_enabled",
      "skill_suggestions_enabled",
      "skill_feedback_enabled",
    ]);

    res.json({
      systemEnabled: settings.skill_system_enabled ?? true,
      proposalEnabled: settings.skill_proposal_enabled ?? true,
      maxSkills: settings.max_skills_per_candidate ?? 6,
      levelEnabled: settings.skill_level_enabled ?? true,
      suggestionsEnabled: settings.skill_suggestions_enabled ?? true,
      feedbackEnabled: settings.skill_feedback_enabled ?? true,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const suggestSkills = async (req, res) => {
  try {
    const { q } = req.query;

    if (!q || q.trim().length < 2) {
      return res.json({ suggestions: [] });
    }

    const suggestionsEnabled = await SystemSettings.getSetting(
      "skill_suggestions_enabled",
      true,
    );

    if (!suggestionsEnabled) {
      return res.json({ suggestions: [] });
    }

    const threshold = await SystemSettings.getSetting(
      "skill_suggestion_threshold",
      0.6,
    );

    const normalized = q.trim().toLowerCase();
    const escaped = normalized.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

    
    const officialMatches = await Skill.find({
      $or: [
        { name: { $regex: escaped, $options: "i" } },
        { aliases: { $regex: escaped, $options: "i" } },
      ],
      isHidden: { $ne: true },
    })
      .sort({ usageCount: -1 })
      .limit(10)
      .select("name category usageCount")
      .lean();

    
    const suggestions = officialMatches.map((skill) => {
      const score = similarity(normalized, skill.name);
      let matchLevel = "close";
      if (score >= 0.9) matchLevel = "strong";
      if (score < threshold) matchLevel = "weak";

      return {
        _id: skill._id,
        name: skill.name,
        category: skill.category,
        confidence: Math.round(score * 100) / 100,
        matchLevel,
      };
    });

    
    const filtered = suggestions.filter((s) => s.confidence >= threshold);

    
    filtered.sort((a, b) => b.confidence - a.confidence);

    res.json({
      suggestions: filtered.slice(0, 5),
      query: q.trim(),
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const addSkillToCandidate = async (req, res) => {
  try {
    const userId = req.user.id;
    const { name, level, selectedSuggestionId } = req.body;

    if (!name || name.trim().length === 0) {
      return res
        .status(400)
        .json({ msg: "Le nom de la compÃ©tence est requis." });
    }

    const systemEnabled = await SystemSettings.getSetting(
      "skill_system_enabled",
      true,
    );
    if (!systemEnabled) {
      return res
        .status(400)
        .json({ msg: "Le systÃ¨me de compÃ©tences est actuellement dÃ©sactivÃ©." });
    }

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const maxSkills = await SystemSettings.getSetting(
      "max_skills_per_candidate",
      6,
    );
    if (candidate.skills.length >= maxSkills) {
      return res.status(400).json({
        msg: `Vous ne pouvez pas ajouter plus de ${maxSkills} compÃ©tences.`,
        maxSkills,
      });
    }

    const rawText = name.trim();
    const normalizedText = rawText.toLowerCase();

    
    const existingSkill = candidate.skills.find(
      (s) => s.normalizedText === normalizedText,
    );
    if (existingSkill) {
      return res.status(400).json({ msg: "Vous avez dÃ©jÃ  cette compÃ©tence." });
    }

    
    const abuseEnabled = await SystemSettings.getSetting(
      "skill_abuse_detection_enabled",
      true,
    );
    const isAbusive = abuseEnabled && detectAbuse(rawText);

    
    const skillEntry = {
      rawText,
      normalizedText,
      level: level || "unset",
      addedAt: new Date(),
      isVisibleToRecruiters: !isAbusive,
      isFlagged: isAbusive,
      flagReason: isAbusive ? "auto_detected_abuse" : undefined,
    };

    
    if (selectedSuggestionId) {
      const officialSkill = await Skill.findById(selectedSuggestionId);
      if (officialSkill && !officialSkill.isHidden) {
        skillEntry.officialSkillId = officialSkill._id;
        skillEntry.officialSkillName = officialSkill.name;
        skillEntry.domain = officialSkill.category;
        skillEntry.subDomain = officialSkill.subCategory;
        skillEntry.matchType = "exact";

        
        await Skill.findByIdAndUpdate(officialSkill._id, {
          $inc: { usageCount: 1 },
        });
      }
    } else if (!isAbusive) {
      
      const proposalEnabled = await SystemSettings.getSetting(
        "skill_proposal_enabled",
        true,
      );

      const threshold = await SystemSettings.getSetting(
        "skill_suggestion_threshold",
        0.6,
      );

      const matchResult = await findBestMatch(normalizedText, threshold);

      if (matchResult.match && matchResult.confidence >= 0.9) {
        
        skillEntry.officialSkillId = matchResult.match._id;
        skillEntry.officialSkillName = matchResult.match.name;
        skillEntry.domain = matchResult.match.category;
        skillEntry.subDomain = matchResult.match.subCategory;
        skillEntry.matchType = matchResult.type === "exact" ? "exact" : "alias";

        await Skill.findByIdAndUpdate(matchResult.match._id, {
          $inc: { usageCount: 1 },
        });
      } else {
        
        skillEntry.matchType = "unmatched";

        if (!proposalEnabled) {
          return res.status(400).json({
            msg: "Cette compÃ©tence n'existe pas dans notre liste. Veuillez en sÃ©lectionner une parmi les suggestions.",
          });
        }
      }
    }

    
    if (!isAbusive) {
      try {
        const { cluster } = await SkillCluster.trackVariant(normalizedText);
        skillEntry.clusterId = cluster._id;
      } catch (clusterErr) {
        console.error("Cluster tracking error (non-blocking):", clusterErr);
      }
    } else {
      
      try {
        const { cluster } = await SkillCluster.trackVariant(normalizedText);
        skillEntry.clusterId = cluster._id;
        cluster.isFlagged = true;
        cluster.flagCount = (cluster.flagCount || 0) + 1;
        cluster.flagReasons.push({
          reason: "auto_abuse_detection",
          flaggedBy: "system",
          flaggedAt: new Date(),
        });
        await cluster.save();
      } catch (clusterErr) {
        console.error("Cluster flagging error (non-blocking):", clusterErr);
      }
    }

    candidate.skills.push(skillEntry);
    await candidate.save();

    const addedSkill = candidate.skills[candidate.skills.length - 1];

    res.json({
      msg: "CompÃ©tence ajoutÃ©e",
      skill: {
        _id: addedSkill._id,
        rawText: addedSkill.rawText,
        level: addedSkill.level,
        officialSkillName: addedSkill.officialSkillName,
        domain: addedSkill.domain,
        subDomain: addedSkill.subDomain,
        matchType: addedSkill.matchType,
      },
      totalSkills: candidate.skills.length,
      maxSkills,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateCandidateSkill = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;
    const { level } = req.body;

    const levelEnabled = await SystemSettings.getSetting(
      "skill_level_enabled",
      true,
    );

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const skill = candidate.skills.id(skillId);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable." });
    }

    if (level && levelEnabled) {
      const validLevels = ["beginner", "intermediate", "expert", "unset"];
      if (!validLevels.includes(level)) {
        return res.status(400).json({ msg: "Niveau invalide." });
      }
      skill.level = level;
    } else if (level && !levelEnabled) {
      return res.status(400).json({
        msg: "La dÃ©finition du niveau de compÃ©tence est actuellement dÃ©sactivÃ©e.",
      });
    }

    await candidate.save();
    res.json({ msg: "CompÃ©tence mise Ã  jour", skill });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const deleteCandidateSkill = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const skill = candidate.skills.id(skillId);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable." });
    }

    
    if (skill.officialSkillId) {
      await Skill.findByIdAndUpdate(skill.officialSkillId, {
        $inc: { usageCount: -1 },
      });
    }

    candidate.skills.pull(skillId);
    await candidate.save();

    res.json({ msg: "CompÃ©tence supprimÃ©e", skills: candidate.skills });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getSkillDetails = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const skill = candidate.skills.id(skillId);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable." });
    }

    const feedbackEnabled = await SystemSettings.getSetting(
      "skill_feedback_enabled",
      true,
    );

    let canSubmitFeedback = false;
    if (feedbackEnabled && skill.officialSkillId) {
      const maxPerSkill = await SystemSettings.getSetting(
        "skill_feedback_max_per_skill",
        1,
      );
      const activeFeedback = await SkillFeedback.countDocuments({
        candidateSkillId: skill._id,
        userId,
        status: "pending",
      });
      canSubmitFeedback = activeFeedback < maxPerSkill;
    }

    res.json({
      _id: skill._id,
      rawText: skill.rawText,
      level: skill.level,
      officialSkillName: skill.officialSkillName,
      domain: skill.domain,
      subDomain: skill.subDomain,
      matchType: skill.matchType,
      addedAt: skill.addedAt,
      mappingHistory: skill.mappingHistory,
      canSubmitFeedback,
      feedbackEnabled,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const submitSkillFeedback = async (req, res) => {
  try {
    const userId = req.user.id;
    const { skillId } = req.params;
    const { category, comment } = req.body;

    const feedbackEnabled = await SystemSettings.getSetting(
      "skill_feedback_enabled",
      true,
    );
    if (!feedbackEnabled) {
      return res.status(400).json({
        msg: "Le systÃ¨me de feedback de compÃ©tences est actuellement dÃ©sactivÃ©.",
      });
    }

    const candidate = await Candidate.findOne({ userId });
    if (!candidate) {
      return res.status(404).json({ msg: "Profil introuvable." });
    }

    const skill = candidate.skills.id(skillId);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable." });
    }

    if (!skill.officialSkillId) {
      return res.status(400).json({
        msg: "Aucun mapping officiel Ã  signaler pour cette compÃ©tence.",
      });
    }

    
    const maxPerWeek = await SystemSettings.getSetting(
      "skill_feedback_max_per_week",
      3,
    );
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
    const weeklyCount = await SkillFeedback.countDocuments({
      userId,
      createdAt: { $gte: oneWeekAgo },
    });
    if (weeklyCount >= maxPerWeek) {
      return res.status(429).json({
        msg: `Vous avez atteint la limite de ${maxPerWeek} feedback(s) par semaine.`,
      });
    }

    
    const maxPerSkill = await SystemSettings.getSetting(
      "skill_feedback_max_per_skill",
      1,
    );
    const skillCount = await SkillFeedback.countDocuments({
      candidateSkillId: skill._id,
      userId,
      status: "pending",
    });
    if (skillCount >= maxPerSkill) {
      return res.status(400).json({
        msg: "Vous avez dÃ©jÃ  un feedback en attente pour cette compÃ©tence.",
      });
    }

    const validCategories = [
      "incorrect_mapping",
      "wrong_domain",
      "skill_merged_incorrectly",
      "other",
    ];
    if (!category || !validCategories.includes(category)) {
      return res.status(400).json({ msg: "CatÃ©gorie de feedback invalide." });
    }

    const feedback = await SkillFeedback.create({
      userId,
      candidateId: candidate._id,
      candidateSkillId: skill._id,
      rawSkillText: skill.rawText,
      mappedToSkillId: skill.officialSkillId,
      mappedToName: skill.officialSkillName,
      category,
      comment: comment?.substring(0, 500),
    });

    res.json({
      msg: "Feedback soumis. Merci pour votre contribution.",
      feedbackId: feedback._id,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};






export const createSkill = async (req, res) => {
  try {
    const { name, category, subCategory, description, aliases } = req.body;
    const normalizedName = name.trim().toLowerCase();

    const exist = await Skill.findOne({
      $or: [{ name: normalizedName }, { aliases: normalizedName }],
    });
    if (exist) {
      return res.status(400).json({
        msg: "Cette compÃ©tence existe dÃ©jÃ .",
        existingSkill: exist.name,
      });
    }

    const normalizedAliases = (aliases || [])
      .map((a) => a.trim().toLowerCase())
      .filter(Boolean);

    const newSkill = await Skill.create({
      name: normalizedName,
      category: category?.trim() || null,
      subCategory: subCategory?.trim() || null,
      description: description?.trim() || null,
      aliases: normalizedAliases,
    });

    await logAdminAction(
      req.user.id,
      "skill_created",
      { type: "skill", id: newSkill._id },
      { name: normalizedName, category },
      req,
    );

    res.status(201).json(newSkill);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateSkill = async (req, res) => {
  try {
    const { id } = req.params;
    const { name, category, subCategory, description, aliases, isHidden } =
      req.body;

    const updates = {};
    if (name) updates.name = name.trim().toLowerCase();
    if (category !== undefined) updates.category = category?.trim() || null;
    if (subCategory !== undefined)
      updates.subCategory = subCategory?.trim() || null;
    if (description !== undefined)
      updates.description = description?.trim() || null;
    if (aliases)
      updates.aliases = aliases
        .map((a) => a.trim().toLowerCase())
        .filter(Boolean);
    if (isHidden !== undefined) updates.isHidden = isHidden;

    const skill = await Skill.findByIdAndUpdate(id, updates, { new: true });
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable" });
    }

    await logAdminAction(
      req.user.id,
      "skill_updated",
      { type: "skill", id: skill._id },
      { updates },
      req,
    );

    res.json({ msg: "CompÃ©tence mise Ã  jour", skill });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const deleteSkill = async (req, res) => {
  try {
    const skill = await Skill.findByIdAndDelete(req.params.id);
    if (!skill) {
      return res.status(404).json({ msg: "CompÃ©tence introuvable" });
    }

    await logAdminAction(
      req.user.id,
      "skill_deleted",
      { type: "skill", id: req.params.id },
      { name: skill.name },
      req,
    );

    res.json({ msg: "CompÃ©tence supprimÃ©e" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getTrendingClusters = async (req, res) => {
  try {
    const { days = 30, limit = 20 } = req.query;

    const windowDays = await SystemSettings.getSetting(
      "skill_trending_window_days",
      parseInt(days),
    );

    const startDate = new Date();
    startDate.setDate(startDate.getDate() - windowDays);

    const clusters = await SkillCluster.find({
      status: "pending",
      isFlagged: false,
      createdAt: { $gte: startDate },
    })
      .sort({ totalUsageCount: -1 })
      .limit(parseInt(limit))
      .lean();

    
    const enriched = clusters.map((c) => {
      const daysSinceCreation = Math.max(
        1,
        (Date.now() - new Date(c.createdAt).getTime()) / (1000 * 60 * 60 * 24),
      );
      const growthRate = c.totalUsageCount / daysSinceCreation;

      return {
        ...c,
        growthRate: Math.round(growthRate * 100) / 100,
        variantCount: c.variants?.length || 0,
      };
    });

    enriched.sort((a, b) => b.growthRate - a.growthRate);

    res.json({ data: enriched, windowDays });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getDuplicateClusters = async (req, res) => {
  try {
    const { limit = 20 } = req.query;

    const clusters = await SkillCluster.find({
      status: "pending",
      "variants.1": { $exists: true }, 
    })
      .sort({ totalUsageCount: -1 })
      .limit(parseInt(limit))
      .lean();

    const enriched = clusters.map((c) => ({
      ...c,
      variantCount: c.variants?.length || 0,
      variants: c.variants?.sort((a, b) => b.usageCount - a.usageCount),
    }));

    res.json({ data: enriched });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getOrphanClusters = async (req, res) => {
  try {
    const { limit = 20, minUsage = 3 } = req.query;

    const clusters = await SkillCluster.find({
      status: "pending",
      promotedToSkillId: { $exists: false },
      isFlagged: false,
      totalUsageCount: { $gte: parseInt(minUsage) },
    })
      .sort({ totalUsageCount: -1 })
      .limit(parseInt(limit))
      .lean();

    res.json({ data: clusters });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getFlaggedClusters = async (req, res) => {
  try {
    const { limit = 20 } = req.query;

    const clusters = await SkillCluster.find({
      isFlagged: true,
    })
      .sort({ flagCount: -1, createdAt: -1 })
      .limit(parseInt(limit))
      .lean();

    res.json({ data: clusters });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const getClusterDetail = async (req, res) => {
  try {
    const { clusterId } = req.params;

    const cluster = await SkillCluster.findById(clusterId)
      .populate("promotedToSkillId", "name category")
      .populate("promotedBy", "nom")
      .populate("dismissedBy", "nom");

    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    
    const threshold = await SystemSettings.getSetting(
      "skill_suggestion_threshold",
      0.6,
    );

    const matchResult = await findBestMatch(cluster.canonicalName, threshold);

    
    const variantTexts = cluster.variants.map((v) => v.text);
    const candidateCount = await Candidate.countDocuments({
      "skills.normalizedText": { $in: variantTexts },
    });

    res.json({
      cluster,
      systemSuggestion: matchResult.match
        ? {
            name: matchResult.match.name,
            category: matchResult.match.category,
            confidence: matchResult.confidence,
          }
        : null,
      candidateCount,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const promoteCluster = async (req, res) => {
  try {
    const { clusterId } = req.params;
    const { name, domain, subDomain, description, aliasVariantTexts } =
      req.body;

    if (!name || !domain) {
      return res.status(400).json({ msg: "Nom et domaine sont obligatoires." });
    }

    const cluster = await SkillCluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    if (cluster.status === "promoted") {
      return res.status(400).json({ msg: "Ce cluster a dÃ©jÃ  Ã©tÃ© promu." });
    }

    const normalizedName = name.trim().toLowerCase();

    
    let officialSkill = await Skill.findOne({ name: normalizedName });

    const selectedAliases = (aliasVariantTexts || [])
      .map((a) => a.trim().toLowerCase())
      .filter((a) => a !== normalizedName);

    
    const allVariantTexts = cluster.variants
      .map((v) => v.text)
      .filter((t) => t !== normalizedName);

    const combinedAliases = [
      ...new Set([...selectedAliases, ...allVariantTexts]),
    ];

    if (officialSkill) {
      
      const existingAliases = new Set(officialSkill.aliases || []);
      combinedAliases.forEach((a) => existingAliases.add(a));
      officialSkill.aliases = [...existingAliases];
      if (!officialSkill.category && domain)
        officialSkill.category = domain.trim();
      if (!officialSkill.subCategory && subDomain)
        officialSkill.subCategory = subDomain.trim();
      officialSkill.isPromoted = true;
      officialSkill.promotedFrom = cluster._id;
      await officialSkill.save();
    } else {
      officialSkill = await Skill.create({
        name: normalizedName,
        category: domain.trim(),
        subCategory: subDomain?.trim() || null,
        description: description?.trim() || null,
        aliases: combinedAliases,
        isPromoted: true,
        promotedFrom: cluster._id,
      });
    }

    
    cluster.status = "promoted";
    cluster.promotedToSkillId = officialSkill._id;
    cluster.promotedAt = new Date();
    cluster.promotedBy = req.user.id;
    await cluster.save();

    
    const autoMigrate = await SystemSettings.getSetting(
      "skill_auto_migration_enabled",
      true,
    );

    let migratedCount = 0;

    if (autoMigrate) {
      const variantTexts = cluster.variants.map((v) => v.text);
      
      const allTexts = [...new Set([...variantTexts, normalizedName])];

      
      const candidatesToUpdate = await Candidate.find({
        "skills.normalizedText": { $in: allTexts },
        "skills.matchType": { $in: ["unmatched", "fuzzy"] },
      });

      for (const candidate of candidatesToUpdate) {
        let changed = false;
        for (const skill of candidate.skills) {
          if (
            allTexts.includes(skill.normalizedText) &&
            ["unmatched", "fuzzy"].includes(skill.matchType)
          ) {
            
            skill.mappingHistory.push({
              previousOfficialId: skill.officialSkillId,
              previousOfficialName: skill.officialSkillName,
              newOfficialId: officialSkill._id,
              newOfficialName: officialSkill.name,
              reason: "cluster_promotion",
              migratedAt: new Date(),
            });

            skill.officialSkillId = officialSkill._id;
            skill.officialSkillName = officialSkill.name;
            skill.domain = officialSkill.category;
            skill.subDomain = officialSkill.subCategory;
            skill.matchType = "promoted";
            
            changed = true;
          }
        }
        if (changed) {
          await candidate.save();
          migratedCount++;
        }
      }

      
      officialSkill.usageCount =
        (officialSkill.usageCount || 0) + cluster.totalUsageCount;
      await officialSkill.save();
    }

    await logAdminAction(
      req.user.id,
      "skill_cluster_promoted",
      { type: "skill_cluster", id: cluster._id },
      {
        officialSkillId: officialSkill._id,
        name: normalizedName,
        domain,
        aliasCount: combinedAliases.length,
        migratedCandidates: migratedCount,
      },
      req,
    );

    res.json({
      msg: "CompÃ©tence promue avec succÃ¨s",
      skill: officialSkill,
      migratedCandidates: migratedCount,
      aliasesAdded: combinedAliases.length,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const dismissCluster = async (req, res) => {
  try {
    const { clusterId } = req.params;
    const { reason } = req.body;

    const cluster = await SkillCluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    cluster.status = "dismissed";
    cluster.dismissedAt = new Date();
    cluster.dismissedBy = req.user.id;
    cluster.dismissReason = reason;
    await cluster.save();

    await logAdminAction(
      req.user.id,
      "skill_cluster_dismissed",
      { type: "skill_cluster", id: cluster._id },
      { reason },
      req,
    );

    res.json({ msg: "Cluster rejetÃ©" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const flagCluster = async (req, res) => {
  try {
    const { clusterId } = req.params;
    const { reason } = req.body;

    const cluster = await SkillCluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    cluster.isFlagged = true;
    cluster.flagCount += 1;
    cluster.flagReasons.push({
      reason: reason || "admin_flagged",
      flaggedBy: "admin",
      flaggedAt: new Date(),
    });
    await cluster.save();

    
    const maxFlags = await SystemSettings.getSetting(
      "skill_abuse_max_flags_before_hide",
      3,
    );

    if (cluster.flagCount >= maxFlags) {
      const variantTexts = cluster.variants.map((v) => v.text);
      await Candidate.updateMany(
        { "skills.normalizedText": { $in: variantTexts } },
        { $set: { "skills.$[elem].isVisibleToRecruiters": false } },
        { arrayFilters: [{ "elem.normalizedText": { $in: variantTexts } }] },
      );
    }

    res.json({ msg: "Cluster signalÃ©", flagCount: cluster.flagCount });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const unflagCluster = async (req, res) => {
  try {
    const { clusterId } = req.params;

    const cluster = await SkillCluster.findById(clusterId);
    if (!cluster) {
      return res.status(404).json({ msg: "Cluster introuvable" });
    }

    cluster.isFlagged = false;
    cluster.status = "pending";
    await cluster.save();

    
    const variantTexts = cluster.variants.map((v) => v.text);
    await Candidate.updateMany(
      {
        "skills.normalizedText": { $in: variantTexts },
        "skills.flagReason": "auto_detected_abuse",
      },
      {
        $set: {
          "skills.$[elem].isVisibleToRecruiters": true,
          "skills.$[elem].isFlagged": false,
          "skills.$[elem].flagReason": null,
        },
      },
      {
        arrayFilters: [
          {
            "elem.normalizedText": { $in: variantTexts },
            "elem.flagReason": "auto_detected_abuse",
          },
        ],
      },
    );

    res.json({ msg: "Cluster dÃ©bloquÃ©" });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getSkillFeedback = async (req, res) => {
  try {
    const { status = "pending", page = 1, limit = 20 } = req.query;

    let query = {};
    if (status !== "all") query.status = status;

    const [feedbacks, total] = await Promise.all([
      SkillFeedback.find(query)
        .sort({ createdAt: -1 })
        .skip((page - 1) * limit)
        .limit(parseInt(limit))
        .populate("userId", "nom email")
        .populate("mappedToSkillId", "name category")
        .populate("reviewedBy", "nom")
        .lean(),
      SkillFeedback.countDocuments(query),
    ]);

    res.json({
      data: feedbacks,
      meta: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(total / limit),
      },
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const reviewSkillFeedback = async (req, res) => {
  try {
    const { feedbackId } = req.params;
    const { action, note } = req.body;

    const validActions = [
      "mapping_adjusted",
      "mapping_removed",
      "no_change",
      "user_flagged",
    ];
    if (!action || !validActions.includes(action)) {
      return res.status(400).json({ msg: "Action invalide." });
    }

    const feedback = await SkillFeedback.findById(feedbackId);
    if (!feedback) {
      return res.status(404).json({ msg: "Feedback introuvable" });
    }

    feedback.status = action === "no_change" ? "rejected" : "accepted";
    feedback.reviewedBy = req.user.id;
    feedback.reviewedAt = new Date();
    feedback.reviewNote = note;
    feedback.actionTaken = action;
    await feedback.save();

    
    if (action === "mapping_removed") {
      const candidate = await Candidate.findById(feedback.candidateId);
      if (candidate) {
        const skill = candidate.skills.id(feedback.candidateSkillId);
        if (skill) {
          skill.mappingHistory.push({
            previousOfficialId: skill.officialSkillId,
            previousOfficialName: skill.officialSkillName,
            newOfficialId: null,
            newOfficialName: null,
            reason: "feedback_accepted",
            migratedAt: new Date(),
          });
          skill.officialSkillId = null;
          skill.officialSkillName = null;
          skill.domain = null;
          skill.subDomain = null;
          skill.matchType = "unmatched";
          await candidate.save();
        }
      }
    }

    
    if (action === "user_flagged") {
      await Candidate.findByIdAndUpdate(feedback.candidateId, {
        $inc: { skillTrustScore: -10 },
      });
    }

    await logAdminAction(
      req.user.id,
      "skill_feedback_reviewed",
      { type: "skill_feedback", id: feedback._id },
      { action, note },
      req,
    );

    res.json({ msg: "Feedback traitÃ©", feedback });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getSkillSystemStats = async (req, res) => {
  try {
    const [
      totalOfficialSkills,
      totalClusters,
      pendingClusters,
      flaggedClusters,
      promotedClusters,
      pendingFeedback,
      totalFeedback,
      topSkills,
      recentClusters,
      categoryDistribution,
    ] = await Promise.all([
      Skill.countDocuments({ isHidden: { $ne: true } }),
      SkillCluster.countDocuments(),
      SkillCluster.countDocuments({ status: "pending", isFlagged: false }),
      SkillCluster.countDocuments({ isFlagged: true }),
      SkillCluster.countDocuments({ status: "promoted" }),
      SkillFeedback.countDocuments({ status: "pending" }),
      SkillFeedback.countDocuments(),
      Skill.find({ isHidden: { $ne: true } })
        .sort({ usageCount: -1 })
        .limit(10)
        .select("name category usageCount")
        .lean(),
      SkillCluster.find({ status: "pending" })
        .sort({ createdAt: -1 })
        .limit(5)
        .select("canonicalName totalUsageCount createdAt")
        .lean(),
      Skill.aggregate([
        {
          $match: {
            isHidden: { $ne: true },
            category: { $exists: true, $ne: null },
          },
        },
        { $group: { _id: "$category", count: { $sum: 1 } } },
        { $sort: { count: -1 } },
      ]),
    ]);

    res.json({
      officialSkills: totalOfficialSkills,
      clusters: {
        total: totalClusters,
        pending: pendingClusters,
        flagged: flaggedClusters,
        promoted: promotedClusters,
      },
      feedback: {
        pending: pendingFeedback,
        total: totalFeedback,
      },
      topSkills,
      recentClusters,
      categoryDistribution,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};




export const getSkillSettings = async (req, res) => {
  try {
    const settings = await SystemSettings.getSettingsByCategory("skills");
    res.json(settings);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


export const updateSkillSettings = async (req, res) => {
  try {
    const { settings } = req.body;

    if (!settings || typeof settings !== "object") {
      return res.status(400).json({ msg: "Settings object requis." });
    }

    const validSkillKeys = [
      "skill_system_enabled",
      "max_skills_per_candidate",
      "skill_proposal_enabled",
      "skill_suggestions_enabled",
      "skill_suggestion_threshold",
      "skill_level_enabled",
      "skill_feedback_enabled",
      "skill_feedback_max_per_week",
      "skill_feedback_max_per_skill",
      "skill_abuse_detection_enabled",
      "skill_abuse_max_flags_before_hide",
      "skill_auto_migration_enabled",
      "skill_recruiter_search_expand_aliases",
      "skill_trending_window_days",
    ];

    const updates = {};
    for (const [key, value] of Object.entries(settings)) {
      if (!validSkillKeys.includes(key)) {
        return res.status(400).json({ msg: `ClÃ© invalide: ${key}` });
      }
      updates[key] = value;
    }

    for (const [key, value] of Object.entries(updates)) {
      await SystemSettings.setSetting(key, value, null, req.user.id);
    }

    await logAdminAction(
      req.user.id,
      "skill_settings_updated",
      { type: "system_settings" },
      { updates },
      req,
    );

    const updatedSettings =
      await SystemSettings.getSettingsByCategory("skills");

    res.json({
      msg: "ParamÃ¨tres des compÃ©tences mis Ã  jour",
      settings: updatedSettings,
    });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export default {
  
  getSkills,
  getSkillProposalStatus,
  suggestSkills,
  
  addSkillToCandidate,
  updateCandidateSkill,
  deleteCandidateSkill,
  getSkillDetails,
  submitSkillFeedback,
  
  createSkill,
  updateSkill,
  deleteSkill,
  
  getTrendingClusters,
  getDuplicateClusters,
  getOrphanClusters,
  getFlaggedClusters,
  getClusterDetail,
  promoteCluster,
  dismissCluster,
  flagCluster,
  unflagCluster,
  
  getSkillFeedback,
  reviewSkillFeedback,
  
  getSkillSystemStats,
  getSkillSettings,
  updateSkillSettings,
};


=== controllers\supportController.js ===
import SupportTicket from "../models/SupportTicket.js";
import Admin from "../models/Admin.js";
import Notification from "../models/Notification.js";
import { logAdminAction } from "../models/AdminLog.js";

export const createTicket = async (req, res) => {
  try {
    const { subject, description, category } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    if (!subject || !description || !category) {
      return res.status(400).json({
        msg: "Sujet, description et catÃ©gorie sont obligatoires.",
      });
    }

    const ticket = await SupportTicket.create({
      userId: req.user.id,
      subject,
      description,
      category,
      attachments,
    });

    const admins = await Admin.find({
      label: ticket.assignedToLabel,
      status: "active",
      "permissions.handleSupportTickets": true,
    }).populate("userId", "_id");

    const notifPromises = admins.map((admin) =>
      Notification.create({
        userId: admin.userId._id,
        message: `Nouveau ticket support: "${subject}"`,
        type: "info",
      })
    );
    await Promise.all(notifPromises);

    res.status(201).json({ msg: "Ticket crÃ©Ã© avec succÃ¨s.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getMyTickets = async (req, res) => {
  try {
    const tickets = await SupportTicket.find({ userId: req.user.id })
      .sort({ createdAt: -1 })
      .select("-messages.adminId");

    res.json(tickets);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const getTicketDetails = async (req, res) => {
  try {
    const { ticketId } = req.params;

    const ticket = await SupportTicket.findOne({
      _id: ticketId,
      userId: req.user.id,
    });

    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable." });
    }

    res.json(ticket);
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

export const replyToTicket = async (req, res) => {
  try {
    const { ticketId } = req.params;
    const { content } = req.body;
    const attachments = req.files?.map((f) => f.path.replace(/\\/g, "/")) || [];

    if (!content) {
      return res.status(400).json({ msg: "Le contenu est obligatoire." });
    }

    const ticket = await SupportTicket.findOne({
      _id: ticketId,
      userId: req.user.id,
      status: { $nin: ["closed"] },
    });

    if (!ticket) {
      return res.status(404).json({ msg: "Ticket introuvable ou fermÃ©." });
    }

    ticket.messages.push({
      from: "user",
      content,
      attachments,
    });

    if (ticket.status === "awaiting_user") {
      ticket.status = "in_progress";
    }

    await ticket.save();

    if (ticket.assignedTo) {
      const admin = await Admin.findById(ticket.assignedTo).populate("userId");
      if (admin) {
        await Notification.create({
          userId: admin.userId._id,
          message: `Nouvelle rÃ©ponse sur le ticket: "${ticket.subject}"`,
          type: "info",
        });
      }
    }

    res.json({ msg: "RÃ©ponse envoyÃ©e.", ticket });
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== middleware\adminPermissions.js ===
import Admin from "../models/Admin.js";

export const requireAdminPermission = (permission) => {
  return async (req, res, next) => {
    try {
      const admin = await Admin.findOne({ userId: req.user.id });

      if (!admin) {
        return res.status(403).json({ msg: "AccÃ¨s administrateur requis." });
      }

      if (admin.status !== "active") {
        return res
          .status(403)
          .json({ msg: "Votre compte administrateur est suspendu." });
      }

      if (!admin.hasPermission(permission)) {
        return res.status(403).json({
          msg: `Permission "${permission}" requise.`,
          code: "PERMISSION_DENIED",
        });
      }

      req.admin = admin;
      next();
    } catch (err) {
      res.status(500).json({ msg: err.message });
    }
  };
};

export const requireActiveAdmin = async (req, res, next) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin || admin.status !== "active") {
      return res
        .status(403)
        .json({ msg: "AccÃ¨s administrateur actif requis." });
    }

    req.admin = admin;
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== middleware\auth.js ===
import jwt from "jsonwebtoken";

export default function auth(req, res, next) {
  const token = req.header("Authorization");
  if (!token) return res.status(401).json({ msg: "Pas de token fourni" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch {
    res.status(401).json({ msg: "Token invalide" });
  }
}


=== middleware\optionalAuth.js ===
import jwt from "jsonwebtoken";

export const optionalAuth = (req, res, next) => {
  const token = req.header("Authorization");

  if (!token) {
    req.user = null;
    return next();
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
  } catch (err) {
    req.user = null;
  }
  next();
};


=== middleware\requireEmailVerification.js ===
import User from "../models/User.js";

export const requireEmailVerification = async (req, res, next) => {
  if (!req.user) {
    return res.status(401).json({ msg: "Utilisateur non authentifiÃ©." });
  }

  try {
    const user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ msg: "Utilisateur introuvable." });
    }

    if (!user.emailVerified) {
      return res.status(403).json({
        msg: "Veuillez confirmer votre adresse e-mail pour effectuer cette action.",
        code: "EMAIL_NOT_VERIFIED",
      });
    }
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


=== middleware\roles.js ===
export const authRole = (roles = []) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ msg: "AccÃ¨s refusÃ© : rÃ´le non autorisÃ©" });
    }
    next();
  };
};


=== middleware\security.js ===
import helmet from "helmet";
import mongoSanitize from "express-mongo-sanitize";


const rateLimitStore = new Map();

const createRateLimiter = (options = {}) => {
  const {
    windowMs = 15 * 60 * 1000, 
    max = 100,
    message = "Trop de requÃªtes, veuillez rÃ©essayer plus tard.",
    keyGenerator = (req) => req.ip,
  } = options;

  
  setInterval(() => {
    const now = Date.now();
    for (const [key, data] of rateLimitStore.entries()) {
      if (now - data.startTime > windowMs) {
        rateLimitStore.delete(key);
      }
    }
  }, windowMs);

  return (req, res, next) => {
    const key = keyGenerator(req);
    const now = Date.now();

    let record = rateLimitStore.get(key);

    if (!record || now - record.startTime > windowMs) {
      record = { count: 1, startTime: now };
      rateLimitStore.set(key, record);
    } else {
      record.count++;
    }

    res.setHeader("X-RateLimit-Limit", max);
    res.setHeader("X-RateLimit-Remaining", Math.max(0, max - record.count));
    res.setHeader(
      "X-RateLimit-Reset",
      new Date(record.startTime + windowMs).toISOString(),
    );

    if (record.count > max) {
      return res.status(429).json({
        msg: message,
        retryAfter: Math.ceil((record.startTime + windowMs - now) / 1000),
      });
    }

    next();
  };
};



export const passwordResetLimiter = createRateLimiter({
  windowMs: 60 * 60 * 1000, 
  max: 5, 
  message: "Trop de demandes de rÃ©initialisation. RÃ©essayez dans 1 heure.",
  keyGenerator: (req) => `pwdreset:${req.ip}`,
});


export const passwordResetVerifyLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000, 
  max: 10, 
  message: "Trop de tentatives de vÃ©rification. RÃ©essayez dans 15 minutes.",
  keyGenerator: (req) => `pwdverify:${req.ip}`,
});


export const authRateLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000,
  max: 10,
  message: "Trop de tentatives de connexion. RÃ©essayez dans 15 minutes.",
  keyGenerator: (req) => `auth:${req.ip}`,
});

export const emailVerificationLimiter = createRateLimiter({
  windowMs: 60 * 1000, 
  max: 3,
  message: "Trop de demandes de vÃ©rification. RÃ©essayez dans 1 minute.",
  keyGenerator: (req) => `email:${req.user?.id || req.ip}`,
});

export const uploadRateLimiter = createRateLimiter({
  windowMs: 60 * 1000,
  max: 10,
  message: "Trop de tÃ©lÃ©chargements. RÃ©essayez dans 1 minute.",
  keyGenerator: (req) => `upload:${req.user?.id || req.ip}`,
});

export const generalRateLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000,
  max: 200,
});

export const offerCreationLimiter = createRateLimiter({
  windowMs: 60 * 60 * 1000, 
  max: 10,
  message: "Trop d'offres crÃ©Ã©es. RÃ©essayez dans 1 heure.",
  keyGenerator: (req) => `offer:${req.user?.id || req.ip}`,
});

export const applicationLimiter = createRateLimiter({
  windowMs: 60 * 60 * 1000, 
  max: 20,
  message: "Trop de candidatures envoyÃ©es. RÃ©essayez dans 1 heure.",
  keyGenerator: (req) => `apply:${req.user?.id || req.ip}`,
});

export const messageLimiter = createRateLimiter({
  windowMs: 60 * 1000, 
  max: 30,
  message: "Trop de messages envoyÃ©s. RÃ©essayez dans 1 minute.",
  keyGenerator: (req) => `msg:${req.user?.id || req.ip}`,
});


export const setupSecurity = (app) => {
  
  app.use(
    helmet({
      contentSecurityPolicy: false, 
      crossOriginEmbedderPolicy: false,
    }),
  );

  
  app.use(mongoSanitize());

  
  app.use(generalRateLimiter);
};

export default {
  setupSecurity,
  authRateLimiter,
  emailVerificationLimiter,
  uploadRateLimiter,
};


=== middleware\validate.js ===
import { validationResult, body, param, query } from "express-validator";


export const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      msg: "DonnÃ©es invalides",
      errors: errors.array().map((e) => ({ field: e.path, message: e.msg })),
    });
  }
  next();
};


export const validators = {
  
  register: [
    body("nom")
      .trim()
      .notEmpty()
      .withMessage("Le nom est requis")
      .isLength({ max: 100 }),
    body("email")
      .trim()
      .isEmail()
      .withMessage("Email invalide")
      .normalizeEmail(),
    body("motDePasse")
      .isLength({ min: 8 })
      .withMessage("Le mot de passe doit contenir au moins 8 caractÃ¨res")
      .matches(/[a-z]/)
      .withMessage("Le mot de passe doit contenir une minuscule")
      .matches(/[A-Z]/)
      .withMessage("Le mot de passe doit contenir une majuscule")
      .matches(/\d/)
      .withMessage("Le mot de passe doit contenir un chiffre"),
    body("role").isIn(["candidat", "recruteur"]).withMessage("RÃ´le invalide"),
    handleValidationErrors,
  ],

  login: [
    body("email")
      .trim()
      .isEmail()
      .withMessage("Email invalide")
      .normalizeEmail(),
    body("motDePasse").notEmpty().withMessage("Mot de passe requis"),
    handleValidationErrors,
  ],

  verifyEmail: [
    body("code")
      .trim()
      .notEmpty()
      .withMessage("Code requis")
      .isLength({ min: 6, max: 6 }),
    handleValidationErrors,
  ],

  changeEmail: [
    body("newEmail")
      .trim()
      .isEmail()
      .withMessage("Email invalide")
      .normalizeEmail(),
    handleValidationErrors,
  ],

  
  updateProfile: [
    body("telephone")
      .optional()
      .trim()
      .matches(/^[0-9+\s-]{8,20}$/)
      .withMessage("TÃ©lÃ©phone invalide"),
    body("bio")
      .optional()
      .trim()
      .isLength({ max: 1000 })
      .withMessage("Bio trop longue (max 1000)"),
    body("dateOfBirth").optional().isISO8601().withMessage("Date invalide"),
    body("gender")
      .optional()
      .isIn(["homme", "femme"])
      .withMessage("Genre invalide"),
    handleValidationErrors,
  ],

  applyToOffer: [
    body("offreId").isMongoId().withMessage("ID offre invalide"),
    body("cvUrl").notEmpty().withMessage("CV requis"),
    body("coverLetter")
      .optional()
      .trim()
      .isLength({ max: 5000 })
      .withMessage("Lettre trop longue"),
    handleValidationErrors,
  ],

  addSkill: [
    body("name")
      .trim()
      .notEmpty()
      .withMessage("Nom requis")
      .isLength({ max: 100 }),
    body("level").optional().isIn(["beginner", "intermediate", "expert"]),
    handleValidationErrors,
  ],
  addSkillV2: [
    body("name")
      .trim()
      .notEmpty()
      .withMessage("Nom requis")
      .isLength({ min: 1, max: 100 })
      .withMessage("Le nom doit faire entre 1 et 100 caractÃ¨res"),
    body("level")
      .optional()
      .isIn(["beginner", "intermediate", "expert", "unset"])
      .withMessage("Niveau invalide"),
    body("selectedSuggestionId")
      .optional()
      .isMongoId()
      .withMessage("ID suggestion invalide"),
    handleValidationErrors,
  ],

  skillFeedback: [
    body("category")
      .isIn([
        "incorrect_mapping",
        "wrong_domain",
        "skill_merged_incorrectly",
        "other",
      ])
      .withMessage("CatÃ©gorie invalide"),
    body("comment")
      .optional()
      .trim()
      .isLength({ max: 500 })
      .withMessage("Commentaire trop long (max 500)"),
    handleValidationErrors,
  ],

  addExperience: [
    body("jobTitle")
      .trim()
      .notEmpty()
      .withMessage("Titre requis")
      .isLength({ max: 200 }),
    body("company")
      .trim()
      .notEmpty()
      .withMessage("Entreprise requise")
      .isLength({ max: 200 }),
    body("startDate").optional().isISO8601().withMessage("Date invalide"),
    body("endDate").optional().isISO8601().withMessage("Date invalide"),
    handleValidationErrors,
  ],

  addEducation: [
    body("institut")
      .trim()
      .notEmpty()
      .withMessage("Institut requis")
      .isLength({ max: 200 }),
    body("degree")
      .trim()
      .notEmpty()
      .withMessage("DiplÃ´me requis")
      .isLength({ max: 200 }),
    body("startDate").optional().isISO8601().withMessage("Date invalide"),
    handleValidationErrors,
  ],

  
  createTicket: [
    body("subject")
      .trim()
      .notEmpty()
      .withMessage("Sujet requis")
      .isLength({ max: 200 }),
    body("description")
      .trim()
      .notEmpty()
      .withMessage("Description requise")
      .isLength({ max: 5000 }),
    body("category")
      .isIn([
        "support_understanding",
        "technical_issue",
        "account_profile",
        "company_recruitment",
        "documents_verification",
        "special_request",
        "feedback_suggestion",
      ])
      .withMessage("CatÃ©gorie invalide"),
    handleValidationErrors,
  ],

  replyToTicket: [
    body("content")
      .trim()
      .notEmpty()
      .withMessage("Contenu requis")
      .isLength({ max: 5000 }),
    handleValidationErrors,
  ],

  
  mongoId: (paramName = "id") => [
    param(paramName).isMongoId().withMessage("ID invalide"),
    handleValidationErrors,
  ],

  
  pagination: [
    query("page").optional().isInt({ min: 1 }).toInt(),
    query("limit").optional().isInt({ min: 1, max: 100 }).toInt(),
    handleValidationErrors,
  ],
  forgotPassword: [
    body("email")
      .trim()
      .isEmail()
      .withMessage("Adresse email invalide")
      .normalizeEmail(),
    handleValidationErrors,
  ],

  verifyResetCode: [
    body("email")
      .trim()
      .isEmail()
      .withMessage("Adresse email invalide")
      .normalizeEmail(),
    body("code")
      .trim()
      .notEmpty()
      .withMessage("Code requis")
      .isLength({ min: 6, max: 6 })
      .withMessage("Le code doit contenir 6 chiffres"),
    handleValidationErrors,
  ],

  resetPassword: [
    body("resetToken")
      .trim()
      .notEmpty()
      .withMessage("Token de rÃ©initialisation requis"),
    body("newPassword")
      .isLength({ min: 8 })
      .withMessage("Le mot de passe doit contenir au moins 8 caractÃ¨res")
      .matches(/[a-z]/)
      .withMessage("Le mot de passe doit contenir une minuscule")
      .matches(/[A-Z]/)
      .withMessage("Le mot de passe doit contenir une majuscule")
      .matches(/\d/)
      .withMessage("Le mot de passe doit contenir un chiffre"),
    body("confirmPassword")
      .optional()
      .custom((value, { req }) => {
        if (value !== req.body.newPassword) {
          throw new Error("Les mots de passe ne correspondent pas");
        }
        return true;
      }),
    handleValidationErrors,
  ],
};

export default validators;


=== models\Admin.js ===
import mongoose from "mongoose";

const adminSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true,
    },

    label: {
      type: String,
      enum: [
        "super_admin",
        "support",
        "technical",
        "operational",
        "recruitment",
        "moderation",
        "product",
      ],
      default: "support",
    },

    permissions: {
      createAdmin: { type: Boolean, default: false },
      deleteAdmin: { type: Boolean, default: false },
      editAdminPermissions: { type: Boolean, default: false },
      assignAdminLabels: { type: Boolean, default: false },

      validateOffers: { type: Boolean, default: false },
      validateRecruiters: { type: Boolean, default: false },
      validateCompanies: { type: Boolean, default: false },

      banUsers: { type: Boolean, default: false },
      suspendUsers: { type: Boolean, default: false },

      proposeCandidates: { type: Boolean, default: false },

      manageAnnouncements: { type: Boolean, default: false },
      sendNotifications: { type: Boolean, default: false },

      handleSupportTickets: { type: Boolean, default: false },

      viewStats: { type: Boolean, default: true },
      viewLogs: { type: Boolean, default: false },
    },

    status: {
      type: String,
      enum: ["active", "suspended", "revoked"],
      default: "active",
    },
    suspensionReason: String,
    suspendedUntil: Date,

    createdBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
  },
  { timestamps: true }
);

adminSchema.methods.hasPermission = function (permission) {
  if (this.label === "super_admin") return true;
  return this.permissions[permission] === true;
};

export default mongoose.model("Admin", adminSchema);


=== models\AdminLog.js ===
import mongoose from "mongoose";

const adminLogSchema = new mongoose.Schema(
  {
    adminId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    action: {
      type: String,
      enum: [
        "admin_created",
        "admin_deleted",
        "admin_suspended",
        "admin_reactivated",
        "admin_permissions_updated",
        "admin_label_changed",
        "recruiter_validated",
        "recruiter_rejected",
        "recruiter_suspended",
        "recruiter_documents_requested",
        "recruiter_revalidated",
        "recruiter_request_canceled",
        "recruiter_multiple_requests",
        "company_validated",
        "company_rejected",
        "company_suspended",
        "company_created_by_admin",
        "company_updated_by_admin",
        "company_admin_assigned",
        "company_admin_removed",
        "offer_approved",
        "offer_rejected",
        "offer_changes_requested",
        "offer_deleted",
        "offer_updated_by_admin",
        "offer_activated_admin",
        "offer_deactivated_admin",
        "user_banned",
        "user_unbanned",
        "user_message_sent",
        "candidate_proposed",
        "announcement_created",
        "announcement_updated",
        "announcement_deleted",
        "ticket_responded",
        "ticket_closed",
        "ticket_reassigned",
        "anem_demande_viewed",
        "anem_demande_assigned",
        "anem_demande_in_progress",
        "anem_pdf_downloaded",
        "anem_id_approved",
        "anem_id_rejected",
        "anem_registration_success",
        "anem_registration_failed",
        "anem_bulk_status_update",
        "anem_note_added",
        
        "skill_created",
        "skill_updated",
        "skill_deleted",
        "skill_cluster_promoted",
        "skill_cluster_dismissed",
        "skill_feedback_reviewed",
        "skill_settings_updated",
        "candidate_anem_demande_viewed",
        "candidate_anem_demande_assigned",
        "candidate_anem_demande_in_progress",
        "candidate_anem_pdf_downloaded",
        "candidate_anem_id_approved",
        "candidate_anem_id_rejected",
        "candidate_anem_registration_success",
        "candidate_anem_registration_failed",
        "candidate_anem_note_added",
      ],
      required: true,
      index: true,
    },
    targetType: {
      type: String,
      enum: [
        "user",
        "recruiter",
        "company",
        "offer",
        "application",
        "announcement",
        "ticket",
        "admin",
        "anem_registration",
        "candidate_anem_registration",
        "skill",
        "skill_cluster",
        "skill_feedback",
        "system_settings",
      ],
    },
    targetId: { type: mongoose.Schema.Types.ObjectId },
    details: { type: mongoose.Schema.Types.Mixed },
    ip: { type: String },
    userAgent: { type: String },
  },
  { timestamps: true },
);

adminLogSchema.index({ createdAt: -1 });
adminLogSchema.index({ action: 1, createdAt: -1 });
adminLogSchema.index({ targetType: 1, targetId: 1 });

const AdminLog = mongoose.model("AdminLog", adminLogSchema);

export const logAdminAction = async (
  adminId,
  action,
  target = {},
  details = {},
  req = null,
) => {
  try {
    await AdminLog.create({
      adminId,
      action,
      targetType: target.type,
      targetId: target.id,
      details,
      ip: req?.ip || req?.connection?.remoteAddress,
      userAgent: req?.get?.("User-Agent") || req?.headers?.["user-agent"],
    });
  } catch (err) {
    console.error("Erreur lors du logging admin:", err);
  }
};

export default AdminLog;


=== models\AnemOffer.js ===
import mongoose from "mongoose";

const anemOfferSchema = new mongoose.Schema(
  {
    offerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Offer",
      required: true,
      unique: true,
    },
    recruiterId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Recruiter",
      required: true,
    },
    anemRegistrationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "AnemRegistration",
      required: true,
    },

    
    anemEnabled: { type: Boolean, default: true },
    anemId: { type: String, required: true },

    
    enabledAt: { type: Date, default: Date.now },
    disabledAt: { type: Date },

    
    submittedToAnem: { type: Boolean, default: false },
    submittedAt: { type: Date },
    anemReference: { type: String },
    anemResponse: { type: mongoose.Schema.Types.Mixed },
  },
  { timestamps: true },
);

anemOfferSchema.index({ offerId: 1 });
anemOfferSchema.index({ recruiterId: 1 });
anemOfferSchema.index({ anemEnabled: 1 });
anemOfferSchema.index({ recruiterId: 1, anemEnabled: 1 });

export default mongoose.model("AnemOffer", anemOfferSchema);


=== models\AnemRegistration.js ===
import mongoose from "mongoose";

const anemRegistrationSchema = new mongoose.Schema(
  {
    recruiterId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Recruiter",
      required: true,
    },
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
    },
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    
    registrationType: {
      type: String,
      enum: ["self_declared", "site_registration"],
      required: true,
    },

    
    declaredAnemId: { type: String },
    declaredAt: { type: Date },

    
    step1: {
      typeAffiliation: {
        type: String,
        enum: ["CNAS", "CASNOS"],
      },
      numeroCnas: { type: String },
      rib: { type: String },
      raisonSociale: { type: String },
      denominationCommerciale: { type: String },
      numeroRc: { type: String },
      entrepriseEtrangere: { type: Boolean, default: false },
      responsable: { type: String },
      fonction: { type: String },
      nif: { type: String },
    },

    
    step2: {
      secteurActivite: { type: String },
      brancheActivite: { type: String },
      secteurJuridique: { type: String },
      statutJuridique: { type: String },
      adresse: { type: String },
      telephone: { type: String },
      fax: { type: String },
      mobile: { type: String },
      paysOrigine: { type: String, default: "AlgÃ©rie" },
      wilaya: { type: String },
      commune: { type: String },
      codePostal: { type: String },
    },

    
    step3: {
      effectifDeclare: { type: Number },
      dontInseresCta: { type: Number },
      nombreInseresDaip: { type: Number },
      autresIndications: { type: String },
    },

    
    step4: {
      email: { type: String },
      
      consentementRgpd: { type: Boolean, default: false },
      consentementAt: { type: Date },
    },

    
    currentStep: {
      type: Number,
      default: 1,
      min: 1,
      max: 4,
    },

    
    formCompleted: { type: Boolean, default: false },
    formCompletedAt: { type: Date },
    formSubmittedAt: { type: Date },

    
    status: {
      type: String,
      enum: [
        "draft",
        "pending",
        "pending_verification",
        "in_progress",
        "registered",
        "failed",
        "rejected",
      ],
      default: "draft",
    },

    
    verifiedAnemId: { type: String },
    verifiedAt: { type: Date },
    verifiedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },

    
    failureReason: { type: String },
    rejectionReason: { type: String },

    
    assignedTo: { type: mongoose.Schema.Types.ObjectId, ref: "Admin" },
    assignedAt: { type: Date },
    assignedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },

    
    pdfDownloads: [
      {
        downloadedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        downloadedAt: { type: Date, default: Date.now },
        ip: { type: String },
      },
    ],

    
    adminNotes: [
      {
        content: { type: String, required: true },
        createdBy: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
          required: true,
        },
        createdAt: { type: Date, default: Date.now },
        isPublic: { type: Boolean, default: false }, 
      },
    ],

    
    auditLog: [
      {
        action: {
          type: String,
          enum: [
            "created",
            "step_saved",
            "form_submitted",
            "pdf_downloaded",
            "assigned",
            "status_changed",
            "note_added",
            "anem_id_submitted",
            "anem_id_updated",
          ],
          required: true,
        },
        previousValue: { type: mongoose.Schema.Types.Mixed },
        newValue: { type: mongoose.Schema.Types.Mixed },
        performedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        performedAt: { type: Date, default: Date.now },
        ip: { type: String },
        userAgent: { type: String },
      },
    ],

    
    anemIdHistory: [
      {
        anemId: { type: String, required: true },
        submittedAt: { type: Date, default: Date.now },
        status: {
          type: String,
          enum: ["pending", "approved", "rejected"],
          default: "pending",
        },
        reviewedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        reviewedAt: { type: Date },
        rejectionReason: { type: String },
        adminComment: { type: String },
      },
    ],
  },
  { timestamps: true },
);


anemRegistrationSchema.index({ recruiterId: 1 }, { unique: true });
anemRegistrationSchema.index({ userId: 1 });
anemRegistrationSchema.index({ companyId: 1 });
anemRegistrationSchema.index({ status: 1 });
anemRegistrationSchema.index({ status: 1, createdAt: -1 });
anemRegistrationSchema.index({ assignedTo: 1, status: 1 });
anemRegistrationSchema.index({ "step2.wilaya": 1 });
anemRegistrationSchema.index({ registrationType: 1, status: 1 });


anemRegistrationSchema.methods.isRegistered = function () {
  return this.status === "registered" && this.verifiedAnemId;
};

anemRegistrationSchema.methods.canCreateAnemOffer = function () {
  return this.status === "registered" && this.verifiedAnemId;
};

anemRegistrationSchema.methods.addAuditEntry = function (
  action,
  performedBy,
  details = {},
  req = null,
) {
  this.auditLog.push({
    action,
    previousValue: details.previousValue,
    newValue: details.newValue,
    performedBy,
    performedAt: new Date(),
    ip: req?.ip || req?.connection?.remoteAddress,
    userAgent: req?.get?.("User-Agent") || req?.headers?.["user-agent"],
  });
};

anemRegistrationSchema.methods.getPublicNotes = function () {
  return this.adminNotes
    .filter((note) => note.isPublic)
    .sort((a, b) => b.createdAt - a.createdAt);
};

anemRegistrationSchema.methods.getLatestPublicNote = function () {
  const publicNotes = this.getPublicNotes();
  return publicNotes.length > 0 ? publicNotes[0] : null;
};


anemRegistrationSchema.virtual("effectiveAnemId").get(function () {
  return this.verifiedAnemId || null;
});


anemRegistrationSchema.methods.generatePdfData = async function () {
  await this.populate([
    { path: "recruiterId", select: "position telephone" },
    { path: "userId", select: "nom email" },
    { path: "companyId", select: "name website location" },
  ]);

  return {
    
    documentTitle: "Demande d'inscription ANEM",
    generatedAt: new Date().toISOString(),
    registrationId: this._id.toString(),
    submittedAt: this.formSubmittedAt || this.formCompletedAt,

    
    recruiter: {
      nom: this.userId?.nom,
      email: this.userId?.email,
      telephone: this.recruiterId?.telephone,
      position: this.recruiterId?.position,
    },

    
    company: {
      name: this.companyId?.name,
      website: this.companyId?.website,
      location: this.companyId?.location,
    },

    
    informationsGenerales: {
      typeAffiliation: this.step1?.typeAffiliation,
      numeroCnas: this.step1?.numeroCnas,
      rib: this.step1?.rib,
      raisonSociale: this.step1?.raisonSociale,
      denominationCommerciale: this.step1?.denominationCommerciale,
      numeroRc: this.step1?.numeroRc,
      entrepriseEtrangere: this.step1?.entrepriseEtrangere ? "Oui" : "Non",
      responsable: this.step1?.responsable,
      fonction: this.step1?.fonction,
      nif: this.step1?.nif,
    },

    
    informationsEmployeur: {
      secteurActivite: this.step2?.secteurActivite,
      brancheActivite: this.step2?.brancheActivite,
      secteurJuridique: this.step2?.secteurJuridique,
      statutJuridique: this.step2?.statutJuridique,
      adresse: this.step2?.adresse,
      telephone: this.step2?.telephone,
      fax: this.step2?.fax,
      mobile: this.step2?.mobile,
      paysOrigine: this.step2?.paysOrigine,
      wilaya: this.step2?.wilaya,
      commune: this.step2?.commune,
      codePostal: this.step2?.codePostal,
    },

    
    informationsCnas: {
      effectifDeclare: this.step3?.effectifDeclare,
      dontInseresCta: this.step3?.dontInseresCta,
      nombreInseresDaip: this.step3?.nombreInseresDaip,
      autresIndications: this.step3?.autresIndications,
    },

    
    compteEnLigne: {
      email: this.step4?.email,
      consentementRgpd: this.step4?.consentementRgpd
        ? "AcceptÃ©"
        : "Non acceptÃ©",
      consentementAt: this.step4?.consentementAt,
    },

    
    legalReference:
      "Loi 18-07 relative Ã  la protection des donnÃ©es personnelles",
  };
};

export default mongoose.model("AnemRegistration", anemRegistrationSchema);


=== models\Announcement.js ===
import mongoose from "mongoose";

const announcementSchema = new mongoose.Schema(
  {
    title: { type: String, required: true },
    content: { type: String, required: true },
    targetAudience: {
      type: String,
      enum: ["all", "admins", "recruiters", "candidates"],
      default: "all",
    },
    status: {
      type: String,
      enum: ["draft", "scheduled", "published", "expired", "archived"],
      default: "draft",
    },
    publishAt: { type: Date },
    expiresAt: { type: Date },
    priority: {
      type: String,
      enum: ["low", "normal", "high", "critical"],
      default: "normal",
    },
    displayType: {
      type: String,
      enum: ["banner", "modal", "inline"],
      default: "inline",
    },
    viewCount: { type: Number, default: 0 },
    dismissedBy: [{ type: mongoose.Schema.Types.ObjectId, ref: "User" }],
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    updatedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
  },
  { timestamps: true }
);

announcementSchema.index({ status: 1, publishAt: 1, expiresAt: 1 });

export default mongoose.model("Announcement", announcementSchema);


=== models\Application.js ===
import mongoose from "mongoose";

const applicationSchema = new mongoose.Schema(
  {
    offerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Offer",
      required: true,
    },
    candidateId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Candidate",
      required: true,
    },

    
    source: {
      type: String,
      enum: ["direct", "admin_proposal"],
      default: "direct",
    },
    proposedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User", 
    },
    proposedAt: Date,

    
    candidateStatus: {
      type: String,
      enum: [
        "envoyee",
        "en_cours",
        "retenue",
        "non_retenue", 
        "retiree", 
        "cancelled",
      ],
      default: "envoyee",
    },

    recruiterStatus: {
      type: String,
      enum: [
        "nouvelle",
        "consultee",
        "preselection",
        "en_discussion",
        "entretien_planifie",
        "entretien_termine",
        "retenue", 
        "refusee", 
        "retiree_par_candidat",
        "annulee_par_candidat",
      ],
      default: "nouvelle",
    },

    
    cvUrl: { type: String, required: true },
    coverLetter: { type: String },

    isRepostulation: { type: Boolean, default: false },

    
    offerSnapshot: {
      titre: String,
      entrepriseNom: String,
      companyId: { type: mongoose.Schema.Types.ObjectId, ref: "Company" },
      location: String,
      salaryMin: Number,
      salaryMax: Number,
      type: { type: String },
      wilaya: String,
      domaine: String,
    },

    
    recruiterNotes: {
      type: String,
      maxLength: 2000,
    },

    
    isStarred: { type: Boolean, default: false }, 
    seenByRecruiter: { type: Boolean, default: false },
    seenAt: Date,

    
    datePostulation: { type: Date, default: Date.now },
    dateDecision: Date, 
    withdrawnAt: Date, 
    withdrawReason: String,

    
    statusHistory: [
      {
        candidateStatus: String,
        recruiterStatus: String,
        changedBy: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
        },
        changedAt: { type: Date, default: Date.now },
        note: String,
      },
    ],
  },
  { timestamps: true },
);


applicationSchema.index({ offerId: 1, candidateId: 1 }, { unique: true });


applicationSchema.index({ offerId: 1, recruiterStatus: 1 });
applicationSchema.index({ candidateId: 1, candidateStatus: 1 });
applicationSchema.index({ offerId: 1, datePostulation: -1 });
applicationSchema.index({ recruiterStatus: 1, isStarred: 1 });

export default mongoose.model("Application", applicationSchema);


=== models\Candidate.js ===
import mongoose from "mongoose";

const educationSchema = new mongoose.Schema({
  institut: { type: String, required: true },
  degree: { type: String, required: true },
  fieldOfStudy: { type: String },
  startDate: { type: Date },
  endDate: { type: Date },
  description: { type: String },
});

const experienceSchema = new mongoose.Schema({
  jobTitle: { type: String, required: true },
  company: { type: String, required: true },
  startDate: { type: Date },
  endDate: { type: Date },
  description: { type: String },
});

const skillSchema = new mongoose.Schema({
  rawText: {
    type: String,
    required: true,
    trim: true,
  },
  normalizedText: {
    type: String,
    required: true,
    trim: true,
    lowercase: true,
  },
  level: {
    type: String,
    enum: ["beginner", "intermediate", "expert", "unset"],
    default: "unset",
  },
  officialSkillId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "Skill",
    default: null,
  },
  officialSkillName: {
    type: String,
    default: null,
  },
  domain: {
    type: String,
    default: null,
    trim: true,
  },
  subDomain: {
    type: String,
    default: null,
    trim: true,
  },
  clusterId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "SkillCluster",
    default: null,
  },
  matchType: {
    type: String,
    enum: ["exact", "alias", "promoted", "unmatched"],
    default: "unmatched",
  },
  isVisibleToRecruiters: {
    type: Boolean,
    default: true,
  },
  isFlagged: {
    type: Boolean,
    default: false,
  },
  flagReason: {
    type: String,
  },
  addedAt: {
    type: Date,
    default: Date.now,
  },
  mappingHistory: [
    {
      previousOfficialId: { type: mongoose.Schema.Types.ObjectId },
      previousOfficialName: { type: String },
      newOfficialId: { type: mongoose.Schema.Types.ObjectId },
      newOfficialName: { type: String },
      reason: { type: String },
      migratedAt: { type: Date, default: Date.now },
    },
  ],
});

const candidateSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true,
    },

    dateOfBirth: { type: Date },
    bio: { type: String, maxLength: 1000 },
    gender: {
      type: String,
      enum: ["homme", "femme"],
    },

    residence: {
      wilaya: { type: String },
      commune: { type: String },
      address: { type: String },
    },

    searchPreferences: {
      wilayas: [{ type: String }],
      remoteOnly: { type: Boolean, default: false },
      willingToRelocate: { type: Boolean, default: false },
    },

    desiredPosition: { type: String },

    desiredJobTypes: [
      {
        type: String,
        enum: [
          "full-time",
          "part-time",
          "remote",
          "internship",
          "freelance",
          "CDI",
          "CDD",
        ],
      },
    ],
    
    anem: {
      registrationId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "CandidateAnemRegistration",
      },
      status: {
        type: String,
        enum: [
          "not_started",
          "draft",
          "pending",
          "pending_verification",
          "in_progress",
          "registered",
          "failed",
          "rejected",
        ],
        default: "not_started",
      },
      anemId: { type: String },
      registeredAt: { type: Date },
      hasSeenAnemInfo: { type: Boolean, default: false },
      declinedAnem: { type: Boolean, default: false },
      declinedAt: { type: Date },
      lastStatusUpdate: { type: Date },
    },

    profilePicture: { type: String },
    telephone: { type: String },
    links: {
      website: { type: String },
      linkedin: { type: String },
      github: { type: String },
      portfolio: { type: String },
    },

    autoriserProposition: { type: Boolean, default: true },

    favoris: [
      {
        offerId: { type: mongoose.Schema.Types.ObjectId, ref: "Offer" },
        savedAt: { type: Date, default: Date.now },
      },
    ],

    cvs: [
      {
        url: { type: String, required: true },
        dateDepot: { type: Date, default: Date.now },
        score: { type: Number, default: 0 },
      },
    ],

    skills: [skillSchema],
    experiences: [experienceSchema],
    education: [educationSchema],

    skillTrustScore: {
      type: Number,
      default: 100,
      min: 0,
      max: 100,
    },
  },
  { timestamps: true },
);

candidateSchema.index({ userId: 1 });
candidateSchema.index({ "residence.wilaya": 1 });
candidateSchema.index({ autoriserProposition: 1 });
candidateSchema.index({ "skills.officialSkillId": 1 });
candidateSchema.index({ "skills.normalizedText": 1 });
candidateSchema.index({ "skills.isVisibleToRecruiters": 1 });
candidateSchema.index({ "skills.domain": 1 });

export default mongoose.model("Candidate", candidateSchema);


=== models\CandidateAnemRegistration.js ===
import mongoose from "mongoose";

const candidateAnemRegistrationSchema = new mongoose.Schema(
  {
    candidateId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Candidate",
      required: true,
    },
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },

    
    registrationType: {
      type: String,
      enum: ["self_declared", "site_registration"],
      required: true,
    },

    
    declaredAnemId: { type: String },
    declaredAt: { type: Date },

    
    step1: {
      civilite: {
        type: String,
        enum: ["monsieur", "madame"],
      },
      nom: { type: String },
      prenom: { type: String },
      estPresume: { type: Boolean, default: false },
      numeroActeNaissance: { type: String },
      dateNaissance: { type: Date },
      paysNaissance: { type: String, default: "AlgÃ©rie" },
      wilayaNaissance: { type: String },
      communeNaissance: { type: String },
      situationFamiliale: {
        type: String,
        enum: ["celibataire", "marie", "divorce", "veuf"],
      },
      situationServiceNational: {
        type: String,
        enum: ["accompli", "exempte", "sursis", "non_concerne"],
      },
      nombreEnfantsCharge: { type: Number, default: 0 },
    },

    
    step2: {
      mobile: { type: String },
      fax: { type: String },
      wilayaResidence: { type: String },
      communeResidence: { type: String },
      quartierResidence: { type: String },
      adresse: { type: String },
      
      nomArabe: { type: String },
      prenomArabe: { type: String },
      adresseArabe: { type: String },
    },

    
    step3: {
      typePieceIdentite: {
        type: String,
        enum: [
          "carte_identite",
          "passeport",
          "permis_conduire",
          "carte_sejour",
        ],
      },
      numeroPieceIdentite: { type: String },
      datePieceIdentite: { type: Date },
      delivreePar: { type: String },
      numeroSecuriteSociale: { type: String },
      nombrePersonnesCharge: { type: Number, default: 0 },
      niveauInstruction: {
        type: String,
        enum: [
          "sans",
          "primaire",
          "moyen",
          "secondaire",
          "superieur",
          "post_graduation",
        ],
      },
      niveauQualification: {
        type: String,
        enum: [
          "sans_qualification",
          "ouvrier_specialise",
          "ouvrier_qualifie",
          "agent_maitrise",
          "technicien",
          "technicien_superieur",
          "cadre",
          "cadre_superieur",
        ],
      },
      handicape: { type: Boolean, default: false },
    },

    
    step4: {
      email: { type: String },
      consentementRgpd: { type: Boolean, default: false },
      consentementAt: { type: Date },
    },

    
    currentStep: {
      type: Number,
      default: 1,
      min: 1,
      max: 4,
    },

    formCompleted: { type: Boolean, default: false },
    formCompletedAt: { type: Date },
    formSubmittedAt: { type: Date },

    
    status: {
      type: String,
      enum: [
        "draft",
        "pending",
        "pending_verification",
        "in_progress",
        "registered",
        "failed",
        "rejected",
      ],
      default: "draft",
    },

    
    verifiedAnemId: { type: String },
    verifiedAt: { type: Date },
    verifiedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },

    
    failureReason: { type: String },
    rejectionReason: { type: String },

    
    assignedTo: { type: mongoose.Schema.Types.ObjectId, ref: "Admin" },
    assignedAt: { type: Date },
    assignedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },

    
    pdfDownloads: [
      {
        downloadedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        downloadedAt: { type: Date, default: Date.now },
        ip: { type: String },
      },
    ],

    
    adminNotes: [
      {
        content: { type: String, required: true },
        createdBy: {
          type: mongoose.Schema.Types.ObjectId,
          ref: "User",
          required: true,
        },
        createdAt: { type: Date, default: Date.now },
        isPublic: { type: Boolean, default: false },
      },
    ],

    
    auditLog: [
      {
        action: {
          type: String,
          enum: [
            "created",
            "step_saved",
            "form_submitted",
            "pdf_downloaded",
            "assigned",
            "status_changed",
            "note_added",
            "anem_id_submitted",
            "anem_id_updated",
          ],
          required: true,
        },
        previousValue: { type: mongoose.Schema.Types.Mixed },
        newValue: { type: mongoose.Schema.Types.Mixed },
        performedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        performedAt: { type: Date, default: Date.now },
        ip: { type: String },
        userAgent: { type: String },
      },
    ],

    
    anemIdHistory: [
      {
        anemId: { type: String, required: true },
        submittedAt: { type: Date, default: Date.now },
        status: {
          type: String,
          enum: ["pending", "approved", "rejected"],
          default: "pending",
        },
        reviewedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        reviewedAt: { type: Date },
        rejectionReason: { type: String },
        adminComment: { type: String },
      },
    ],
  },
  { timestamps: true },
);


candidateAnemRegistrationSchema.index({ candidateId: 1 }, { unique: true });
candidateAnemRegistrationSchema.index({ userId: 1 });
candidateAnemRegistrationSchema.index({ status: 1 });
candidateAnemRegistrationSchema.index({ status: 1, createdAt: -1 });
candidateAnemRegistrationSchema.index({ assignedTo: 1, status: 1 });
candidateAnemRegistrationSchema.index({ "step2.wilayaResidence": 1 });
candidateAnemRegistrationSchema.index({ registrationType: 1, status: 1 });


candidateAnemRegistrationSchema.methods.isRegistered = function () {
  return this.status === "registered" && this.verifiedAnemId;
};

candidateAnemRegistrationSchema.methods.addAuditEntry = function (
  action,
  performedBy,
  details = {},
  req = null,
) {
  this.auditLog.push({
    action,
    previousValue: details.previousValue,
    newValue: details.newValue,
    performedBy,
    performedAt: new Date(),
    ip: req?.ip || req?.connection?.remoteAddress,
    userAgent: req?.get?.("User-Agent") || req?.headers?.["user-agent"],
  });
};

candidateAnemRegistrationSchema.methods.getPublicNotes = function () {
  return this.adminNotes
    .filter((note) => note.isPublic)
    .sort((a, b) => b.createdAt - a.createdAt);
};

candidateAnemRegistrationSchema.methods.getLatestPublicNote = function () {
  const publicNotes = this.getPublicNotes();
  return publicNotes.length > 0 ? publicNotes[0] : null;
};

candidateAnemRegistrationSchema.virtual("effectiveAnemId").get(function () {
  return this.verifiedAnemId || null;
});

candidateAnemRegistrationSchema.methods.generatePdfData = async function () {
  await this.populate([
    { path: "candidateId", select: "telephone residence profilePicture" },
    { path: "userId", select: "nom email" },
  ]);

  return {
    documentTitle: "Demande d'inscription ANEM - Demandeur d'emploi",
    generatedAt: new Date().toISOString(),
    registrationId: this._id.toString(),
    submittedAt: this.formSubmittedAt || this.formCompletedAt,

    demandeur: {
      nom: this.userId?.nom,
      email: this.userId?.email,
    },

    etatCivil: {
      civilite: this.step1?.civilite,
      nom: this.step1?.nom,
      prenom: this.step1?.prenom,
      estPresume: this.step1?.estPresume ? "Oui" : "Non",
      numeroActeNaissance: this.step1?.numeroActeNaissance,
      dateNaissance: this.step1?.dateNaissance,
      paysNaissance: this.step1?.paysNaissance,
      wilayaNaissance: this.step1?.wilayaNaissance,
      communeNaissance: this.step1?.communeNaissance,
      situationFamiliale: this.step1?.situationFamiliale,
      situationServiceNational: this.step1?.situationServiceNational,
      nombreEnfantsCharge: this.step1?.nombreEnfantsCharge,
    },

    contact: {
      mobile: this.step2?.mobile,
      fax: this.step2?.fax,
      wilayaResidence: this.step2?.wilayaResidence,
      communeResidence: this.step2?.communeResidence,
      quartierResidence: this.step2?.quartierResidence,
      adresse: this.step2?.adresse,
      nomArabe: this.step2?.nomArabe,
      prenomArabe: this.step2?.prenomArabe,
      adresseArabe: this.step2?.adresseArabe,
    },

    autresInformations: {
      typePieceIdentite: this.step3?.typePieceIdentite,
      numeroPieceIdentite: this.step3?.numeroPieceIdentite,
      datePieceIdentite: this.step3?.datePieceIdentite,
      delivreePar: this.step3?.delivreePar,
      numeroSecuriteSociale: this.step3?.numeroSecuriteSociale,
      nombrePersonnesCharge: this.step3?.nombrePersonnesCharge,
      niveauInstruction: this.step3?.niveauInstruction,
      niveauQualification: this.step3?.niveauQualification,
      handicape: this.step3?.handicape ? "Oui" : "Non",
    },

    compteEnLigne: {
      email: this.step4?.email,
      consentementRgpd: this.step4?.consentementRgpd
        ? "AcceptÃ©"
        : "Non acceptÃ©",
      consentementAt: this.step4?.consentementAt,
    },

    legalReference:
      "Loi 18-07 relative Ã  la protection des donnÃ©es personnelles",
  };
};

export default mongoose.model(
  "CandidateAnemRegistration",
  candidateAnemRegistrationSchema,
);


=== models\Company.js ===
import mongoose from "mongoose";

const companySchema = new mongoose.Schema(
  {
    name: { type: String, required: true, unique: true },
    logo: { type: String },
    website: { type: String },
    description: { type: String },
    industry: { type: String },
    location: { type: String },
    size: { type: String },

    status: {
      type: String,
      enum: ["pending", "active", "rejected"],
      default: "pending",
    },
  },
  { timestamps: true }
);
companySchema.index({ status: 1 });
companySchema.index({ name: "text" });
export default mongoose.model("Company", companySchema);


=== models\Conversation.js ===
import mongoose from "mongoose";

const messageSchema = new mongoose.Schema({
  senderId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
  },
  senderType: {
    type: String,
    enum: ["candidate", "recruiter"],
    required: true,
  },
  content: { type: String, required: true, maxLength: 5000 },
  attachments: [String],
  readAt: Date,
  createdAt: { type: Date, default: Date.now },
});

const conversationSchema = new mongoose.Schema(
  {
    applicationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Application",
      required: true,
      unique: true, 
    },
    offerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Offer",
      required: true,
    },
    candidateId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Candidate",
      required: true,
    },
    recruiterId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Recruiter",
      required: true,
    },

    
    candidateHasReplied: { type: Boolean, default: false },

    
    initiatedAt: { type: Date, default: Date.now },

    
    firstCandidateReplyAt: Date,

    
    openedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    openedAt: { type: Date, default: Date.now },

    messages: [messageSchema],

    
    unreadByCandidate: { type: Number, default: 0 },
    unreadByRecruiter: { type: Number, default: 0 },

    lastMessageAt: Date,

    
    status: {
      type: String,
      enum: ["active", "archived", "closed"],
      default: "active",
    },
    
    createdWith: {
      type: String,
      enum: ["custom_message", "standard_message"],
      default: "custom_message",
    },
  },
  { timestamps: true },
);


conversationSchema.index({ recruiterId: 1, candidateHasReplied: 1 });
conversationSchema.index({ candidateId: 1, lastMessageAt: -1 });
conversationSchema.index({ recruiterId: 1, lastMessageAt: -1 });
conversationSchema.index({ applicationId: 1 });

export default mongoose.model("Conversation", conversationSchema);


=== models\Interview.js ===
import mongoose from "mongoose";

const interviewSchema = new mongoose.Schema(
  {
    applicationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Application",
      required: true,
    },
    offerId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Offer",
      required: true,
    },
    candidateId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Candidate",
      required: true,
    },
    recruiterId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Recruiter",
      required: true,
    },

    
    type: {
      type: String,
      enum: ["phone", "video", "in_person"],
      default: "video",
    },
    scheduledAt: { type: Date, required: true },
    duration: { type: Number, default: 30 }, 
    location: String, 
    meetingLink: String, 
    phoneNumber: String, 

    
    status: {
      type: String,
      enum: [
        "proposed", 
        "confirmed", 
        "rescheduled_by_candidate", 
        "rescheduled_by_recruiter", 
        "cancelled_by_candidate",
        "cancelled_by_recruiter",
        "completed", 
        "no_show_candidate", 
        "no_show_recruiter", 
      ],
      default: "proposed",
    },

    
    proposedAlternative: {
      date: Date,
      proposedBy: {
        type: String,
        enum: ["candidate", "recruiter"],
      },
      message: String,
      proposedAt: Date,
    },

    
    recruiterNotes: String, 
    preparationNotes: String, 

    
    feedback: {
      rating: { type: Number, min: 1, max: 5 },
      notes: String,
      strengths: [String],
      concerns: [String],
      recommendation: {
        type: String,
        enum: ["strong_yes", "yes", "maybe", "no", "strong_no"],
      },
      completedAt: Date,
    },

    
    reminderSentToCandidate: { type: Boolean, default: false },
    reminderSentToRecruiter: { type: Boolean, default: false },
  },
  { timestamps: true }
);


interviewSchema.index({ applicationId: 1 });
interviewSchema.index({ candidateId: 1, status: 1 });
interviewSchema.index({ recruiterId: 1, scheduledAt: 1 });
interviewSchema.index({ status: 1, scheduledAt: 1 });
interviewSchema.index({ scheduledAt: 1 }); 

export default mongoose.model("Interview", interviewSchema);


=== models\Notification.js ===
import mongoose from "mongoose";

const notificationSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    message: { type: String, required: true },
    type: {
      type: String,
      enum: ["info", "alerte", "validation"],
      default: "info",
    },
    lu: { type: Boolean, default: false },
    date: { type: Date, default: Date.now },
  },
  { timestamps: true }
);

notificationSchema.index({ userId: 1, lu: 1 });
notificationSchema.index({ userId: 1, date: -1 });

export default mongoose.model("Notification", notificationSchema);


=== models\Offer.js ===
import mongoose from "mongoose";

const offerSchema = new mongoose.Schema(
  {
    recruteurId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Recruiter",
      required: true,
    },
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
    },

    titre: { type: String, required: true },
    description: { type: String, required: true },
    requirements: { type: String, required: true },

    domaine: { type: String },
    type: {
      type: String,
      enum: [
        "full-time",
        "part-time",
        "remote",
        "internship",
        "freelance",
        "CDI",
        "CDD",
      ],
      default: "full-time",
    },
    salaryMin: { type: Number },
    salaryMax: { type: Number },
    experienceLevel: { type: String, enum: ["junior", "mid", "senior"] },
    skills: [{ type: String, index: true }],
    wilaya: { type: String },

    
    isAnem: { type: Boolean, default: false },
    

    allowRepostulation: { type: Boolean, default: true },

    validationStatus: {
      type: String,
      enum: ["draft", "pending", "approved", "rejected", "changes_requested"],
      default: "pending",
    },
    validationHistory: [
      {
        status: String,
        message: String,
        adminId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        date: { type: Date, default: Date.now },
      },
    ],
    rejectionReason: String,

    visibility: {
      isPublic: { type: Boolean, default: true },
      acceptsDirectApplications: { type: Boolean, default: true },
    },

    candidateSearchMode: {
      type: String,
      enum: ["disabled", "manual", "automatic"],
      default: "disabled",
    },

    actif: { type: Boolean, default: false },
    datePublication: { type: Date },
    nombreCandidatures: { type: Number, default: 0 },
  },
  { timestamps: true },
);

offerSchema.methods.isVisible = function () {
  return this.validationStatus === "approved" && this.actif;
};

offerSchema.index({ titre: "text", description: "text", skills: "text" });

export default mongoose.model("Offer", offerSchema);


=== models\ProposedSkill.js ===
import mongoose from "mongoose";

const proposedSkillSchema = new mongoose.Schema(
  {
    label: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
      index: true,
    },
    domain: {
      type: String,
      default: null,
      trim: true,
    },
    status: {
      type: String,
      enum: ["pending", "approved", "rejected", "merged"],
      default: "pending",
      index: true,
    },
    proposedBy: [
      {
        userId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        candidateId: { type: mongoose.Schema.Types.ObjectId, ref: "Candidate" },
        proposedAt: { type: Date, default: Date.now },
      },
    ],
    proposalCount: {
      type: Number,
      default: 1,
    },
    
    approvedSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Skill",
    },
    
    reviewedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    reviewedAt: Date,
    reviewNote: String,
    
    mergedInto: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "ProposedSkill",
    },
  },
  { timestamps: true },
);


proposedSkillSchema.index({ label: 1 }, { unique: true });
proposedSkillSchema.index({ status: 1, proposalCount: -1 });


proposedSkillSchema.statics.proposeSkill = async function (
  label,
  userId,
  candidateId,
) {
  const normalizedLabel = label.trim().toLowerCase();

  
  let proposedSkill = await this.findOne({ label: normalizedLabel });

  if (proposedSkill) {
    
    const alreadyProposed = proposedSkill.proposedBy.some(
      (p) => p.userId?.toString() === userId,
    );

    if (!alreadyProposed) {
      proposedSkill.proposedBy.push({
        userId,
        candidateId,
        proposedAt: new Date(),
      });
      proposedSkill.proposalCount += 1;
      await proposedSkill.save();
    }

    return { proposedSkill, isNew: false };
  }

  
  proposedSkill = await this.create({
    label: normalizedLabel,
    proposedBy: [{ userId, candidateId, proposedAt: new Date() }],
  });

  return { proposedSkill, isNew: true };
};

export default mongoose.model("ProposedSkill", proposedSkillSchema);


=== models\Recruiter.js ===
import mongoose from "mongoose";

const recruiterSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      unique: true,
    },
    companyId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Company",
      required: true,
    },

    telephone: { type: String },
    position: { type: String },

    status: {
      type: String,
      enum: [
        "pending_validation",
        "pending_documents",
        "pending_info",
        "pending_info_and_documents",
        "pending_revalidation",
        "validated",
        "rejected",
      ],
      default: "pending_validation",
    },

    rejectionReason: String,

    validationRequests: [
      {
        type: {
          type: String,
          enum: ["document", "information", "clarification"],
        },
        message: String,
        requiredFields: [String],
        requiredDocuments: Number,
        response: {
          text: String,
          documents: [String],
          submittedAt: Date,
        },
        status: {
          type: String,
          enum: ["pending", "submitted", "approved", "rejected"],
          default: "pending",
        },
        createdAt: { type: Date, default: Date.now },
        reviewedAt: Date,
        reviewedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
      },
    ],

    permissions: {
      postJobs: { type: Boolean, default: true },
      reviewCandidates: { type: Boolean, default: true },
      scheduleInterviews: { type: Boolean, default: true },
      manageTeam: { type: Boolean, default: false },
      editCompany: { type: Boolean, default: false },
    },

    isAdmin: { type: Boolean, default: false },

    
    
    
    anem: {
      
      registrationId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: "AnemRegistration",
      },

      
      status: {
        type: String,
        enum: [
          "not_started",
          "draft",
          "pending",
          "pending_verification",
          "in_progress",
          "registered",
          "failed",
          "rejected",
        ],
        default: "not_started",
      },

      
      anemId: { type: String },

      
      registeredAt: { type: Date },

      
      hasSeenAnemModal: { type: Boolean, default: false },
      modalSeenAt: { type: Date },

      
      declinedAnem: { type: Boolean, default: false },
      declinedAt: { type: Date },

      
      lastStatusUpdate: { type: Date },
    },

    favoriteCandidates: [
      {
        candidateId: { type: mongoose.Schema.Types.ObjectId, ref: "Candidate" },
        savedAt: { type: Date, default: Date.now },
        notes: String,
      },
    ],

    invitedBy: { type: mongoose.Schema.Types.ObjectId, ref: "Recruiter" },
    invitedAt: Date,
  },
  { timestamps: true },
);

recruiterSchema.index({ userId: 1 });
recruiterSchema.index({ companyId: 1 });
recruiterSchema.index({ status: 1 });
recruiterSchema.index({ "anem.status": 1 });
recruiterSchema.index({ "anem.anemId": 1 });

recruiterSchema.methods.canPerformActions = function () {
  return this.status === "validated";
};

recruiterSchema.methods.hasPendingRequests = function () {
  return this.validationRequests.some((r) => r.status === "pending");
};

recruiterSchema.methods.isAnemRegistered = function () {
  return this.anem.status === "registered" && this.anem.anemId;
};

recruiterSchema.methods.canCreateAnemOffer = function () {
  return this.anem.status === "registered" && this.anem.anemId;
};

recruiterSchema.methods.shouldShowAnemModal = function (offerCount) {
  
  
  
  if (offerCount === 0 && !this.anem.hasSeenAnemModal) {
    return { show: true, reason: "first_offer" };
  }
  return { show: false, reason: null };
};

recruiterSchema.methods.updateAnemStatus = async function (
  newStatus,
  anemId = null,
) {
  this.anem.status = newStatus;
  this.anem.lastStatusUpdate = new Date();

  if (newStatus === "registered" && anemId) {
    this.anem.anemId = anemId;
    this.anem.registeredAt = new Date();
  }

  await this.save();
};

export default mongoose.model("Recruiter", recruiterSchema);


=== models\SkillCluster.js ===
import mongoose from "mongoose";

const skillClusterSchema = new mongoose.Schema(
  {
    canonicalName: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
      unique: true,
    },
    variants: [
      {
        text: { type: String, required: true, trim: true, lowercase: true },
        usageCount: { type: Number, default: 1 },
        firstSeenAt: { type: Date, default: Date.now },
        lastSeenAt: { type: Date, default: Date.now },
      },
    ],
    suggestedDomain: { type: String, trim: true },
    suggestedSubDomain: { type: String, trim: true },
    suggestedCanonicalName: { type: String, trim: true },
    confidenceScore: { type: Number, default: 0, min: 0, max: 1 },
    totalUsageCount: { type: Number, default: 0 },
    status: {
      type: String,
      enum: ["pending", "promoted", "dismissed", "flagged"],
      default: "pending",
    },
    promotedToSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Skill",
    },
    promotedAt: { type: Date },
    promotedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
    dismissedAt: { type: Date },
    dismissedBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
    dismissReason: { type: String },
    flagCount: { type: Number, default: 0 },
    isFlagged: { type: Boolean, default: false },
    flagReasons: [
      {
        reason: String,
        flaggedBy: { type: String, enum: ["system", "user", "admin"] },
        flaggedAt: { type: Date, default: Date.now },
      },
    ],
  },
  { timestamps: true },
);

skillClusterSchema.index({ status: 1, totalUsageCount: -1 });
skillClusterSchema.index({ canonicalName: 1 });
skillClusterSchema.index({ "variants.text": 1 });
skillClusterSchema.index({ isFlagged: 1, flagCount: -1 });
skillClusterSchema.index({ createdAt: -1 });
skillClusterSchema.index({ totalUsageCount: -1 });

skillClusterSchema.statics.trackVariant = async function (rawText) {
  const normalized = rawText.trim().toLowerCase();

  let cluster = await this.findOne({ "variants.text": normalized });

  if (cluster) {
    const variant = cluster.variants.find((v) => v.text === normalized);
    if (variant) {
      variant.usageCount += 1;
      variant.lastSeenAt = new Date();
    }
    cluster.totalUsageCount += 1;
    await cluster.save();
    return { cluster, isNew: false };
  }

  cluster = await this.findOne({ canonicalName: normalized });

  if (cluster) {
    cluster.variants.push({
      text: normalized,
      usageCount: 1,
      firstSeenAt: new Date(),
      lastSeenAt: new Date(),
    });
    cluster.totalUsageCount += 1;
    await cluster.save();
    return { cluster, isNew: false };
  }

  cluster = await this.create({
    canonicalName: normalized,
    variants: [
      {
        text: normalized,
        usageCount: 1,
        firstSeenAt: new Date(),
        lastSeenAt: new Date(),
      },
    ],
    totalUsageCount: 1,
  });

  return { cluster, isNew: true };
};

const SkillCluster = mongoose.model("SkillCluster", skillClusterSchema);

export default SkillCluster;


=== models\SkillFeedback.js ===
import mongoose from "mongoose";

const skillFeedbackSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    candidateId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Candidate",
      required: true,
    },
    candidateSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      required: true,
    },
    rawSkillText: {
      type: String,
      required: true,
      trim: true,
    },
    mappedToSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Skill",
    },
    mappedToName: {
      type: String,
      trim: true,
    },
    category: {
      type: String,
      enum: [
        "incorrect_mapping",
        "wrong_domain",
        "skill_merged_incorrectly",
        "other",
      ],
      required: true,
    },
    comment: {
      type: String,
      maxLength: 500,
    },
    status: {
      type: String,
      enum: ["pending", "reviewed", "accepted", "rejected"],
      default: "pending",
    },
    reviewedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    reviewedAt: { type: Date },
    reviewNote: { type: String },
    actionTaken: {
      type: String,
      enum: [
        "mapping_adjusted",
        "mapping_removed",
        "no_change",
        "user_flagged",
      ],
    },
  },
  { timestamps: true },
);

skillFeedbackSchema.index({ userId: 1, createdAt: -1 });
skillFeedbackSchema.index({ candidateSkillId: 1, status: 1 });
skillFeedbackSchema.index({ status: 1, createdAt: -1 });
skillFeedbackSchema.index({ mappedToSkillId: 1 });

export default mongoose.model("SkillFeedback", skillFeedbackSchema);


=== models\Skills.js ===
import mongoose from "mongoose";

const skillSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
      index: true,
    },
    category: {
      type: String,
      trim: true,
      index: true,
    },
    subCategory: {
      type: String,
      trim: true,
    },
    description: {
      type: String,
      maxLength: 500,
    },
    aliases: [
      {
        type: String,
        trim: true,
        lowercase: true,
      },
    ],
    isPromoted: {
      type: Boolean,
      default: false,
    },
    promotedFrom: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "SkillCluster",
    },
    wasProposed: {
      type: Boolean,
      default: false,
    },
    proposedSkillId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "ProposedSkill",
    },
    usageCount: {
      type: Number,
      default: 0,
    },
    isHidden: {
      type: Boolean,
      default: false,
    },
  },
  { timestamps: true },
);

skillSchema.index({ name: "text", aliases: "text", category: "text" });
skillSchema.index({ aliases: 1 });
skillSchema.index({ usageCount: -1 });
skillSchema.index({ isHidden: 1 });

skillSchema.statics.findByNameOrAlias = async function (query) {
  const normalized = query.trim().toLowerCase();
  return this.findOne({
    $or: [{ name: normalized }, { aliases: normalized }],
    isHidden: { $ne: true },
  });
};

skillSchema.statics.searchSimilar = async function (query, limit = 10) {
  const normalized = query.trim().toLowerCase();
  const escaped = normalized.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

  return this.find({
    $or: [
      { name: { $regex: escaped, $options: "i" } },
      { aliases: { $regex: escaped, $options: "i" } },
    ],
    isHidden: { $ne: true },
  })
    .sort({ usageCount: -1 })
    .limit(limit)
    .lean();
};

export default mongoose.model("Skill", skillSchema);


=== models\SupportTicket.js ===
import mongoose from "mongoose";

const supportTicketSchema = new mongoose.Schema(
  {
    userId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    subject: { type: String, required: true },
    description: { type: String, required: true },
    category: {
      type: String,
      enum: [
        "support_understanding",
        "technical_issue",
        "account_profile",
        "company_recruitment",
        "documents_verification",
        "special_request",
        "feedback_suggestion",
      ],
      required: true,
    },
    assignedToLabel: {
      type: String,
      enum: [
        "support",
        "technical",
        "operational",
        "recruitment",
        "moderation",
        "super_admin",
        "product",
      ],
    },
    assignedTo: { type: mongoose.Schema.Types.ObjectId, ref: "Admin" },
    status: {
      type: String,
      enum: ["open", "in_progress", "awaiting_user", "resolved", "closed"],
      default: "open",
    },
    priority: {
      type: String,
      enum: ["low", "medium", "high", "urgent"],
      default: "medium",
    },
    attachments: [{ type: String }],
    messages: [
      {
        from: { type: String, enum: ["user", "admin"], required: true },
        content: { type: String, required: true },
        adminId: { type: mongoose.Schema.Types.ObjectId, ref: "User" },
        attachments: [String],
        createdAt: { type: Date, default: Date.now },
      },
    ],
    chatEnabled: { type: Boolean, default: false },
    resolvedAt: Date,
    closedAt: Date,
  },
  { timestamps: true }
);

supportTicketSchema.pre("save", function (next) {
  if (this.isNew && !this.assignedToLabel) {
    const categoryToLabel = {
      support_understanding: "support",
      technical_issue: "technical",
      account_profile: "operational",
      company_recruitment: "recruitment",
      documents_verification: "moderation",
      special_request: "super_admin",
      feedback_suggestion: "product",
    };
    this.assignedToLabel = categoryToLabel[this.category] || "support";
  }
  next();
});

supportTicketSchema.index({ status: 1, createdAt: -1 });
supportTicketSchema.index({ assignedToLabel: 1, status: 1 });

export default mongoose.model("SupportTicket", supportTicketSchema);


=== models\SystemSettings.js ===
import mongoose from "mongoose";

const systemSettingsSchema = new mongoose.Schema(
  {
    key: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },
    value: {
      type: mongoose.Schema.Types.Mixed,
      required: true,
    },
    description: {
      type: String,
    },
    category: {
      type: String,
      enum: [
        "general",
        "email",
        "skills",
        "candidates",
        "recruiters",
        "security",
      ],
      default: "general",
    },
    updatedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    updatedAt: {
      type: Date,
      default: Date.now,
    },
  },
  { timestamps: true },
);

systemSettingsSchema.statics.getSetting = async function (
  key,
  defaultValue = null,
) {
  const setting = await this.findOne({ key });
  return setting ? setting.value : defaultValue;
};

systemSettingsSchema.statics.setSetting = async function (
  key,
  value,
  description = null,
  updatedBy = null,
) {
  const update = { value, updatedAt: new Date() };
  if (description) update.description = description;
  if (updatedBy) update.updatedBy = updatedBy;

  return this.findOneAndUpdate(
    { key },
    { $set: update, $setOnInsert: { key } },
    { upsert: true, new: true },
  );
};

systemSettingsSchema.statics.getMultipleSettings = async function (keys) {
  const settings = await this.find({ key: { $in: keys } });
  const map = {};
  settings.forEach((s) => {
    map[s.key] = s.value;
  });
  return map;
};

systemSettingsSchema.statics.getSettingsByCategory = async function (category) {
  return this.find({ category }).select("-__v").lean();
};

systemSettingsSchema.statics.initializeDefaults = async function () {
  const defaults = [
    
    {
      key: "email_verification_mode",
      value: process.env.NODE_ENV === "production" ? "smtp" : "development",
      description:
        "Mode de vÃ©rification email: 'smtp' pour production, 'development' pour code statique 123456",
      category: "email",
    },
    {
      key: "verification_code_expiry_minutes",
      value: 15,
      description: "DurÃ©e de validitÃ© du code de vÃ©rification en minutes",
      category: "email",
    },

    
    {
      key: "max_cv_per_candidate",
      value: 3,
      description: "Nombre maximum de CV par candidat",
      category: "candidates",
    },

    
    {
      key: "skill_system_enabled",
      value: true,
      description: "Active ou dÃ©sactive tout le systÃ¨me de compÃ©tences",
      category: "skills",
    },
    {
      key: "max_skills_per_candidate",
      value: 6,
      description: "Nombre maximum de compÃ©tences par candidat",
      category: "skills",
    },
    {
      key: "skill_proposal_enabled",
      value: true,
      description:
        "Permet aux candidats d'ajouter des compÃ©tences en texte libre (non officielles)",
      category: "skills",
    },
    {
      key: "skill_suggestions_enabled",
      value: true,
      description:
        "Active les suggestions de compÃ©tences similaires lors de la saisie",
      category: "skills",
    },
    {
      key: "skill_suggestion_threshold",
      value: 0.6,
      description:
        "Seuil de confiance (0-1) pour afficher des suggestions de compÃ©tences similaires",
      category: "skills",
    },
    {
      key: "skill_level_enabled",
      value: true,
      description:
        "Permet aux candidats de dÃ©finir un niveau pour chaque compÃ©tence",
      category: "skills",
    },
    {
      key: "skill_feedback_enabled",
      value: true,
      description:
        "Permet aux candidats de signaler un mapping incorrect de compÃ©tence",
      category: "skills",
    },
    {
      key: "skill_feedback_max_per_week",
      value: 3,
      description:
        "Nombre maximum de feedbacks de compÃ©tences par candidat par semaine",
      category: "skills",
    },
    {
      key: "skill_feedback_max_per_skill",
      value: 1,
      description:
        "Nombre maximum de feedbacks actifs par compÃ©tence par candidat",
      category: "skills",
    },
    {
      key: "skill_abuse_detection_enabled",
      value: true,
      description:
        "Active la dÃ©tection automatique de compÃ©tences abusives/spam",
      category: "skills",
    },
    {
      key: "skill_abuse_max_flags_before_hide",
      value: 3,
      description:
        "Nombre de signalements avant de masquer une compÃ©tence des recruteurs",
      category: "skills",
    },
    {
      key: "skill_auto_migration_enabled",
      value: true,
      description:
        "Migration automatique des compÃ©tences utilisateur vers les officielles aprÃ¨s promotion",
      category: "skills",
    },
    {
      key: "skill_recruiter_search_expand_aliases",
      value: true,
      description:
        "La recherche recruteur inclut les alias et variantes historiques",
      category: "skills",
    },
    {
      key: "skill_trending_window_days",
      value: 30,
      description:
        "FenÃªtre en jours pour le calcul des compÃ©tences tendance (admin dashboard)",
      category: "skills",
    },
  ];

  for (const setting of defaults) {
    const exists = await this.findOne({ key: setting.key });
    if (!exists) {
      await this.create(setting);
    }
  }
};

export default mongoose.model("SystemSettings", systemSettingsSchema);


=== models\User.js ===
import mongoose from "mongoose";

const userSchema = new mongoose.Schema(
  {
    nom: { type: String },
    email: { type: String, required: true, unique: true },
    motDePasse: { type: String, required: true },
    role: {
      type: String,
      enum: ["candidat", "recruteur", "admin"],
      required: true,
    },

    emailVerified: {
      type: Boolean,
      default: false,
    },

    accountStatus: {
      type: String,
      enum: ["active", "suspended", "banned"],
      default: "active",
    },
    suspensionReason: String,
    suspendedUntil: Date,

    derniereConnexion: Date,
  },
  { timestamps: true },
);

userSchema.index({ email: 1 });
userSchema.index({ role: 1 });
userSchema.index({ createdAt: -1 });
userSchema.index({ accountStatus: 1 });

userSchema.methods.canLogin = function () {
  if (this.accountStatus === "banned") return false;
  if (this.accountStatus === "suspended") {
    if (this.suspendedUntil && new Date() > this.suspendedUntil) {
      return true;
    }
    return false;
  }
  return true;
};

export default mongoose.model("User", userSchema);


=== models\VerificationToken.js ===
import mongoose from "mongoose";
import crypto from "crypto";

const verificationTokenSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: "User",
    required: true,
    index: true,
  },
  token: {
    type: String,
    required: true,
  },
  code: {
    type: String,
    required: true,
  },
  type: {
    type: String,
    enum: ["email_verification", "password_reset"],
    default: "email_verification",
  },
  expiresAt: {
    type: Date,
    required: true,
    index: { expireAfterSeconds: 0 },
  },
  attempts: {
    type: Number,
    default: 0,
  },
  maxAttempts: {
    type: Number,
    default: 3,
  },
  
  requestCount: {
    type: Number,
    default: 1,
  },
  lastRequestAt: {
    type: Date,
    default: Date.now,
  },
  
  cooldownUntil: {
    type: Date,
    default: null,
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
});


verificationTokenSchema.statics.generateCode = function () {
  return Math.floor(100000 + Math.random() * 900000).toString();
};


verificationTokenSchema.statics.generateToken = function () {
  return crypto.randomBytes(32).toString("hex");
};


verificationTokenSchema.statics.createVerificationToken = async function (
  userId,
  type = "email_verification",
  expiresInMinutes = 15,
) {
  
  await this.deleteMany({ userId, type });

  const code = this.generateCode();
  const token = this.generateToken();

  const verificationToken = await this.create({
    userId,
    token,
    code,
    type,
    expiresAt: new Date(Date.now() + expiresInMinutes * 60 * 1000),
  });

  return { code, token, expiresAt: verificationToken.expiresAt };
};


verificationTokenSchema.statics.createPasswordResetToken = async function (
  userId,
  expiresInMinutes = 20,
) {
  const MAX_REQUESTS = 3;
  const COOLDOWN_MINUTES = 5;
  const LOCKOUT_MINUTES = 30;

  
  const existingToken = await this.findOne({ userId, type: "password_reset" });

  const now = new Date();

  if (existingToken) {
    
    if (existingToken.cooldownUntil && existingToken.cooldownUntil > now) {
      const waitMinutes = Math.ceil(
        (existingToken.cooldownUntil - now) / (60 * 1000),
      );
      return {
        success: false,
        error: `Trop de demandes. Veuillez attendre ${waitMinutes} minute(s) avant de rÃ©essayer.`,
        retryAfter: existingToken.cooldownUntil,
      };
    }

    
    const timeSinceLastRequest = now - existingToken.lastRequestAt;
    const cooldownMs = COOLDOWN_MINUTES * 60 * 1000;

    if (timeSinceLastRequest < cooldownMs) {
      const waitSeconds = Math.ceil((cooldownMs - timeSinceLastRequest) / 1000);
      const waitMinutes = Math.ceil(waitSeconds / 60);
      return {
        success: false,
        error: `Veuillez attendre ${waitMinutes} minute(s) avant de demander un nouveau code.`,
        retryAfter: new Date(
          existingToken.lastRequestAt.getTime() + cooldownMs,
        ),
      };
    }

    
    if (existingToken.requestCount >= MAX_REQUESTS) {
      
      existingToken.cooldownUntil = new Date(
        now.getTime() + LOCKOUT_MINUTES * 60 * 1000,
      );
      existingToken.requestCount = 0; 
      await existingToken.save();

      return {
        success: false,
        error: `Nombre maximum de demandes atteint. Veuillez attendre ${LOCKOUT_MINUTES} minutes.`,
        retryAfter: existingToken.cooldownUntil,
      };
    }

    
    const newCode = this.generateCode();
    existingToken.code = newCode;
    existingToken.token = this.generateToken();
    existingToken.expiresAt = new Date(
      now.getTime() + expiresInMinutes * 60 * 1000,
    );
    existingToken.attempts = 0; 
    existingToken.requestCount += 1;
    existingToken.lastRequestAt = now;
    existingToken.cooldownUntil = null;

    await existingToken.save();

    return {
      success: true,
      code: newCode,
      token: existingToken.token,
      expiresAt: existingToken.expiresAt,
      requestsRemaining: MAX_REQUESTS - existingToken.requestCount,
    };
  }

  
  const code = this.generateCode();
  const token = this.generateToken();

  const verificationToken = await this.create({
    userId,
    token,
    code,
    type: "password_reset",
    expiresAt: new Date(now.getTime() + expiresInMinutes * 60 * 1000),
    requestCount: 1,
    lastRequestAt: now,
  });

  return {
    success: true,
    code,
    token: verificationToken.token,
    expiresAt: verificationToken.expiresAt,
    requestsRemaining: MAX_REQUESTS - 1,
  };
};


verificationTokenSchema.statics.verifyCode = async function (
  userId,
  code,
  type = "email_verification",
) {
  const verificationToken = await this.findOne({
    userId,
    type,
    expiresAt: { $gt: new Date() },
  });

  if (!verificationToken) {
    return {
      valid: false,
      error: "Code expirÃ© ou invalide. Demandez un nouveau code.",
    };
  }

  if (verificationToken.attempts >= verificationToken.maxAttempts) {
    await verificationToken.deleteOne();
    return {
      valid: false,
      error: "Trop de tentatives incorrectes. Demandez un nouveau code.",
      locked: true,
    };
  }

  if (verificationToken.code !== code) {
    verificationToken.attempts += 1;
    await verificationToken.save();
    const remaining =
      verificationToken.maxAttempts - verificationToken.attempts;

    if (remaining === 0) {
      await verificationToken.deleteOne();
      return {
        valid: false,
        error:
          "Code incorrect. Le code a Ã©tÃ© invalidÃ©. Demandez un nouveau code.",
        attemptsRemaining: 0,
        locked: true,
      };
    }

    return {
      valid: false,
      error: `Code incorrect. ${remaining} tentative(s) restante(s).`,
      attemptsRemaining: remaining,
    };
  }

  
  if (type === "password_reset") {
    return {
      valid: true,
      token: verificationToken.token,
      userId: verificationToken.userId,
    };
  }

  
  await verificationToken.deleteOne();
  return { valid: true };
};


verificationTokenSchema.statics.verifyResetToken = async function (token) {
  const verificationToken = await this.findOne({
    token,
    type: "password_reset",
    expiresAt: { $gt: new Date() },
  });

  if (!verificationToken) {
    return {
      valid: false,
      error: "Lien de rÃ©initialisation invalide ou expirÃ©.",
    };
  }

  return {
    valid: true,
    userId: verificationToken.userId,
  };
};


verificationTokenSchema.statics.consumeResetToken = async function (token) {
  const result = await this.deleteOne({ token, type: "password_reset" });
  return result.deletedCount > 0;
};

export default mongoose.model("VerificationToken", verificationTokenSchema);


=== routes\adminRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { authRole } from "../middleware/roles.js";
import Admin from "../models/Admin.js";
import {
  getRecruiters,
  validateRecruiter,
  rejectRecruiter,
  requestRecruiterDocuments,
  requestMultipleValidationItems,
  cancelValidationRequest,
  getAllUsers,
  banUser,
  unBanUser,
  sendMessageToUser,
  getCandidateDetailsAdmin,
  createAdmin,
  deleteAdmin,
  getAllAdmins,
  suspendAdmin,
  updateAdminPermissions,
  updateAdminLabel,
  getPendingCompanies,
  validateCompany,
  rejectCompany,
  getCompanyDetailsAdmin,
  getAllCompanies,
  getPendingOffers,
  approveOffer,
  rejectOffer,
  deleteOfferAdmin,
  getManualSelectionOffers,
  proposeCandidateToOffer,
  toggleOfferVisibility,
  getGlobalStats,
  getTrends,
  getAdminLogs,
  createCompanyByAdmin,
  getCompanyRecruiters,
  assignCompanyAdmin,
  removeCompanyAdmin,
  updateCompanyByAdmin,
  getOfferDetailsAdmin,
  updateOfferByAdmin,
} from "../controllers/adminController.js";

import {
  getSkills,
  createSkill,
  updateSkill,
  deleteSkill,
  
  getTrendingClusters,
  getDuplicateClusters,
  getOrphanClusters,
  getFlaggedClusters,
  getClusterDetail,
  promoteCluster,
  dismissCluster,
  flagCluster,
  unflagCluster,
  
  getSkillFeedback,
  reviewSkillFeedback,
  
  getSkillSystemStats,
  getSkillSettings,
  updateSkillSettings,
} from "../controllers/skillController.js";

import {
  createAnnouncement,
  getAllAnnouncements,
  updateAnnouncement,
  deleteAnnouncement,
} from "../controllers/announcementController.js";

import {
  getTicketsByLabel,
  getTicketById,
  respondToTicket,
  reassignTicket,
  closeTicket,
} from "../controllers/adminSupportController.js";

import {
  toggleEmailVerificationMode,
  getEmailVerificationMode,
  toggleSkillProposal,
  getAllSettings,
  getSettingsByCategory,
  updateSettingsBulk,
} from "../controllers/adminSettingsController.js";

import { uploadAttachments } from "../config/multer.js";

const router = express.Router();

router.use(auth, authRole(["admin"]));

const requirePermission = (permission) => async (req, res, next) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin) {
      return res.status(403).json({ msg: "Admin introuvable" });
    }

    if (admin.status !== "active") {
      return res.status(403).json({ msg: "Compte admin suspendu" });
    }

    if (!admin.hasPermission(permission)) {
      return res.status(403).json({
        msg: `Permission "${permission}" requise`,
        code: "PERMISSION_DENIED",
      });
    }

    req.admin = admin;
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};

router.get("/stats/global", requirePermission("viewStats"), getGlobalStats);
router.get("/stats/trends", requirePermission("viewStats"), getTrends);

router.get(
  "/recruteurs",
  requirePermission("validateRecruiters"),
  getRecruiters,
);
router.put(
  "/recruteurs/valider/:id",
  requirePermission("validateRecruiters"),
  validateRecruiter,
);
router.put(
  "/recruteurs/rejeter/:id",
  requirePermission("validateRecruiters"),
  rejectRecruiter,
);
router.post(
  "/recruteurs/:recruiterId/request-documents",
  requirePermission("validateRecruiters"),
  requestRecruiterDocuments,
);
router.post(
  "/recruteurs/:recruiterId/request-multiple",
  requirePermission("validateRecruiters"),
  requestMultipleValidationItems,
);

router.put(
  "/recruteurs/:id/cancel-request",
  requirePermission("validateRecruiters"),
  cancelValidationRequest,
);

router.get("/users", getAllUsers);
router.put("/users/ban/:id", requirePermission("banUsers"), banUser);
router.put("/users/unban/:id", requirePermission("banUsers"), unBanUser);
router.post(
  "/users/message/:id",
  requirePermission("sendNotifications"),
  sendMessageToUser,
);

router.get("/admins", requirePermission("viewStats"), getAllAdmins);
router.post("/admins", requirePermission("createAdmin"), createAdmin);
router.delete("/admins/:id", requirePermission("deleteAdmin"), deleteAdmin);
router.put(
  "/admins/:id/suspend",
  requirePermission("deleteAdmin"),
  suspendAdmin,
);
router.put(
  "/admins/:id/permissions",
  requirePermission("editAdminPermissions"),
  updateAdminPermissions,
);
router.put(
  "/admins/:id/label",
  requirePermission("assignAdminLabels"),
  updateAdminLabel,
);

router.get(
  "/entreprises/all",
  requirePermission("validateCompanies"),
  getAllCompanies,
);

router.get(
  "/entreprises/en-attente",
  requirePermission("validateCompanies"),
  getPendingCompanies,
);
router.put(
  "/entreprises/valider/:id",
  requirePermission("validateCompanies"),
  validateCompany,
);
router.put(
  "/entreprises/rejeter/:id",
  requirePermission("validateCompanies"),
  rejectCompany,
);

router.get(
  "/entreprises/:companyId",
  requirePermission("validateCompanies"),
  getCompanyDetailsAdmin,
);

router.put(
  "/entreprises/:id",
  requirePermission("validateCompanies"),
  updateCompanyByAdmin,
);

router.get(
  "/offres/en-attente",
  requirePermission("validateOffers"),
  getPendingOffers,
);
router.put(
  "/offres/:id/approve",
  requirePermission("validateOffers"),
  approveOffer,
);
router.put(
  "/offres/:id/reject",
  requirePermission("validateOffers"),
  rejectOffer,
);
router.delete(
  "/offres/:id",
  requirePermission("validateOffers"),
  deleteOfferAdmin,
);
router.get(
  "/offres/manuelles",
  requirePermission("proposeCandidates"),
  getManualSelectionOffers,
);
router.post(
  "/offres/proposer",
  requirePermission("proposeCandidates"),
  proposeCandidateToOffer,
);

router.get(
  "/offres/:id/details",
  requirePermission("validateOffers"),
  getOfferDetailsAdmin,
);
router.put(
  "/offres/:id/update",
  requirePermission("validateOffers"),
  updateOfferByAdmin,
);
router.put(
  "/offres/:id/visibility",
  requirePermission("validateOffers"),
  toggleOfferVisibility,
);

router.get(
  "/candidates/:id",
  requirePermission("viewStats"),
  getCandidateDetailsAdmin,
);

router.get(
  "/announcements",
  requirePermission("manageAnnouncements"),
  getAllAnnouncements,
);
router.post(
  "/announcements",
  requirePermission("manageAnnouncements"),
  createAnnouncement,
);
router.put(
  "/announcements/:id",
  requirePermission("manageAnnouncements"),
  updateAnnouncement,
);
router.delete(
  "/announcements/:id",
  requirePermission("manageAnnouncements"),
  deleteAnnouncement,
);

router.get(
  "/tickets",
  requirePermission("handleSupportTickets"),
  getTicketsByLabel,
);
router.get(
  "/tickets/:ticketId",
  requirePermission("handleSupportTickets"),
  getTicketById,
);
router.post(
  "/tickets/:ticketId/respond",
  requirePermission("handleSupportTickets"),
  uploadAttachments.array("attachments", 3),
  respondToTicket,
);
router.put(
  "/tickets/:ticketId/reassign",
  requirePermission("handleSupportTickets"),
  reassignTicket,
);
router.put(
  "/tickets/:ticketId/close",
  requirePermission("handleSupportTickets"),
  closeTicket,
);

router.get("/logs", requirePermission("viewLogs"), getAdminLogs);

router.post(
  "/entreprises/create",
  requirePermission("validateCompanies"),
  createCompanyByAdmin,
);

router.get(
  "/entreprises/:companyId/recruiters",
  requirePermission("validateCompanies"),
  getCompanyRecruiters,
);

router.post(
  "/entreprises/assign-admin",
  requirePermission("validateCompanies"),
  assignCompanyAdmin,
);

router.delete(
  "/entreprises/remove-admin/:recruiterId",
  requirePermission("validateCompanies"),
  removeCompanyAdmin,
);


router.get("/settings", getAllSettings);
router.get("/settings/category/:category", getSettingsByCategory);
router.put(
  "/settings/bulk",
  requirePermission("editAdminPermissions"),
  updateSettingsBulk,
);
router.get("/settings/email-verification-mode", getEmailVerificationMode);
router.post("/settings/email-verification-mode", toggleEmailVerificationMode);
router.post("/settings/skill-proposal", toggleSkillProposal);






router.get(
  "/skills/stats",
  requirePermission("viewStats"),
  getSkillSystemStats,
);
router.get(
  "/skills/settings",
  requirePermission("viewStats"),
  getSkillSettings,
);
router.put(
  "/skills/settings",
  requirePermission("editAdminPermissions"),
  updateSkillSettings,
);


router.get(
  "/skills/clusters/trending",
  requirePermission("validateOffers"),
  getTrendingClusters,
);
router.get(
  "/skills/clusters/duplicates",
  requirePermission("validateOffers"),
  getDuplicateClusters,
);
router.get(
  "/skills/clusters/orphans",
  requirePermission("validateOffers"),
  getOrphanClusters,
);
router.get(
  "/skills/clusters/flagged",
  requirePermission("validateOffers"),
  getFlaggedClusters,
);
router.get(
  "/skills/clusters/:clusterId",
  requirePermission("validateOffers"),
  getClusterDetail,
);
router.post(
  "/skills/clusters/:clusterId/promote",
  requirePermission("validateOffers"),
  promoteCluster,
);
router.post(
  "/skills/clusters/:clusterId/dismiss",
  requirePermission("validateOffers"),
  dismissCluster,
);
router.post(
  "/skills/clusters/:clusterId/flag",
  requirePermission("validateOffers"),
  flagCluster,
);
router.post(
  "/skills/clusters/:clusterId/unflag",
  requirePermission("validateOffers"),
  unflagCluster,
);


router.get(
  "/skills/feedback",
  requirePermission("validateOffers"),
  getSkillFeedback,
);
router.post(
  "/skills/feedback/:feedbackId/review",
  requirePermission("validateOffers"),
  reviewSkillFeedback,
);


router.get("/skills", requirePermission("viewStats"), getSkills);
router.post("/skills", requirePermission("validateOffers"), createSkill);
router.put("/skills/:id", requirePermission("validateOffers"), updateSkill);
router.delete("/skills/:id", requirePermission("validateOffers"), deleteSkill);

export default router;


=== routes\anemRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { authRole } from "../middleware/roles.js";
import Admin from "../models/Admin.js";


import {
  getAnemStatus,
  checkAnemModalRequired,
  markAnemModalSeen,
  declineAnem,
  resetAnemDecline,
  submitAnemId,
  startRegistration,
  saveRegistrationStep,
  submitRegistration,
  getRegistrationForm,
} from "../controllers/anemController.js";


import {
  getAnemDemandes,
  getDemandeDetails,
  getPendingAnemIds,
  assignDemande,
  markInProgress,
  getPdfData,
  approveAnemId,
  rejectAnemId,
  markRegistered,
  markFailed,
  addAdminNote,
  bulkUpdateStatus,
  getAnemStats,
  getNewDemandesCount,
  getAdminsForAssignment,
} from "../controllers/anemController.js";


import {
  checkAnemEligibility,
  enableAnemForOffer,
  disableAnemForOffer,
  getOfferAnemStatus,
  getRecruiterAnemOffers,
} from "../controllers/anemOfferController.js";

const router = express.Router();






router.get("/status", auth, authRole(["recruteur"]), getAnemStatus);
router.get(
  "/check-modal",
  auth,
  authRole(["recruteur"]),
  checkAnemModalRequired,
);
router.post("/modal-seen", auth, authRole(["recruteur"]), markAnemModalSeen);
router.post("/decline", auth, authRole(["recruteur"]), declineAnem);
router.post("/reset-decline", auth, authRole(["recruteur"]), resetAnemDecline);


router.post("/submit-id", auth, authRole(["recruteur"]), submitAnemId);


router.post(
  "/start-registration",
  auth,
  authRole(["recruteur"]),
  startRegistration,
);
router.post("/save-step", auth, authRole(["recruteur"]), saveRegistrationStep);
router.post(
  "/submit-registration",
  auth,
  authRole(["recruteur"]),
  submitRegistration,
);
router.get(
  "/registration-form",
  auth,
  authRole(["recruteur"]),
  getRegistrationForm,
);


router.get(
  "/offer-eligibility",
  auth,
  authRole(["recruteur"]),
  checkAnemEligibility,
);
router.get("/offers", auth, authRole(["recruteur"]), getRecruiterAnemOffers);
router.get(
  "/offers/:offerId/status",
  auth,
  authRole(["recruteur"]),
  getOfferAnemStatus,
);
router.post(
  "/offers/:offerId/enable",
  auth,
  authRole(["recruteur"]),
  enableAnemForOffer,
);
router.post(
  "/offers/:offerId/disable",
  auth,
  authRole(["recruteur"]),
  disableAnemForOffer,
);





const requireAnemPermission = async (req, res, next) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin) {
      return res.status(403).json({ msg: "Admin introuvable" });
    }

    if (admin.status !== "active") {
      return res.status(403).json({ msg: "Compte admin suspendu" });
    }

    
    const hasPermission =
      admin.label === "super_admin" ||
      admin.permissions.validateRecruiters ||
      admin.permissions.validateCompanies;

    if (!hasPermission) {
      return res.status(403).json({
        msg: "Permission requise pour gÃ©rer les demandes ANEM",
        code: "PERMISSION_DENIED",
      });
    }

    req.admin = admin;
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


router.get(
  "/admin/stats",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  getAnemStats,
);

router.get(
  "/admin/demandes/count",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  getNewDemandesCount,
);


router.get(
  "/admin/demandes",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  getAnemDemandes,
);

router.get(
  "/admin/demandes/:demandeId",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  getDemandeDetails,
);


router.get(
  "/admin/pending-ids",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  getPendingAnemIds,
);


router.get(
  "/admin/admins-for-assignment",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  getAdminsForAssignment,
);

router.post(
  "/admin/demandes/:demandeId/assign",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  assignDemande,
);


router.post(
  "/admin/demandes/:demandeId/in-progress",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  markInProgress,
);


router.get(
  "/admin/demandes/:demandeId/pdf-data",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  getPdfData,
);


router.post(
  "/admin/demandes/:demandeId/approve-id",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  approveAnemId,
);

router.post(
  "/admin/demandes/:demandeId/reject-id",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  rejectAnemId,
);


router.post(
  "/admin/demandes/:demandeId/register",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  markRegistered,
);

router.post(
  "/admin/demandes/:demandeId/fail",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  markFailed,
);


router.post(
  "/admin/demandes/:demandeId/note",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  addAdminNote,
);


router.post(
  "/admin/demandes/bulk-update",
  auth,
  authRole(["admin"]),
  requireAnemPermission,
  bulkUpdateStatus,
);

export default router;


=== routes\announcementRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import {
  getActiveAnnouncements,
  dismissAnnouncement,
} from "../controllers/announcementController.js";

const router = express.Router();

router.use(auth);

router.get("/active", getActiveAnnouncements);

router.post("/:announcementId/dismiss", dismissAnnouncement);

export default router;


=== routes\authRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import {
  authRateLimiter,
  emailVerificationLimiter,
  passwordResetLimiter,
  passwordResetVerifyLimiter,
} from "../middleware/security.js";
import { validators } from "../middleware/validate.js";
import {
  register,
  login,
  verifyEmail,
  resendConfirmationCode,
  changeEmail,
  getCompanies,
} from "../controllers/authController.js";
import {
  forgotPassword,
  verifyResetCode,
  resetPassword,
  checkResetToken,
} from "../controllers/passwordResetController.js";

const router = express.Router();


router.post("/register", authRateLimiter, validators.register, register);
router.post("/login", authRateLimiter, validators.login, login);


router.post(
  "/verify-email",
  auth,
  emailVerificationLimiter,
  validators.verifyEmail,
  verifyEmail,
);
router.post(
  "/resend-code",
  auth,
  emailVerificationLimiter,
  resendConfirmationCode,
);
router.put("/change-email", auth, validators.changeEmail, changeEmail);


router.post(
  "/forgot-password",
  passwordResetLimiter,
  validators.forgotPassword,
  forgotPassword,
);
router.post(
  "/verify-reset-code",
  passwordResetVerifyLimiter,
  validators.verifyResetCode,
  verifyResetCode,
);
router.post(
  "/reset-password",
  passwordResetVerifyLimiter,
  validators.resetPassword,
  resetPassword,
);
router.get("/check-reset-token/:token", checkResetToken);


router.get("/companies", getCompanies);

export default router;


=== routes\candidateAnemRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { authRole } from "../middleware/roles.js";
import Admin from "../models/Admin.js";


import {
  getCandidateAnemStatus,
  markAnemInfoSeen,
  declineCandidateAnem,
  resetCandidateAnemDecline,
  submitCandidateAnemId,
  startCandidateRegistration,
  saveCandidateRegistrationStep,
  submitCandidateRegistration,
  getCandidateRegistrationForm,
  
  getCandidateAnemDemandes,
  getCandidateDemandeDetails,
  getCandidatePendingAnemIds,
  assignCandidateDemande,
  markCandidateDemandeInProgress,
  getCandidateAnemPdfData,
  approveCandidateAnemId,
  rejectCandidateAnemId,
  markCandidateRegistered,
  markCandidateAnemFailed,
  addCandidateAnemAdminNote,
  getCandidateAnemStats,
  getCandidateAnemNewCount,
} from "../controllers/candidateAnemController.js";

const router = express.Router();



router.get("/status", auth, authRole(["candidat"]), getCandidateAnemStatus);
router.post("/info-seen", auth, authRole(["candidat"]), markAnemInfoSeen);
router.post("/decline", auth, authRole(["candidat"]), declineCandidateAnem);
router.post(
  "/reset-decline",
  auth,
  authRole(["candidat"]),
  resetCandidateAnemDecline,
);


router.post("/submit-id", auth, authRole(["candidat"]), submitCandidateAnemId);


router.post(
  "/start-registration",
  auth,
  authRole(["candidat"]),
  startCandidateRegistration,
);
router.post(
  "/save-step",
  auth,
  authRole(["candidat"]),
  saveCandidateRegistrationStep,
);
router.post(
  "/submit-registration",
  auth,
  authRole(["candidat"]),
  submitCandidateRegistration,
);
router.get(
  "/registration-form",
  auth,
  authRole(["candidat"]),
  getCandidateRegistrationForm,
);



const requireCandidateAnemPermission = async (req, res, next) => {
  try {
    const admin = await Admin.findOne({ userId: req.user.id });

    if (!admin) {
      return res.status(403).json({ msg: "Admin introuvable" });
    }

    if (admin.status !== "active") {
      return res.status(403).json({ msg: "Compte admin suspendu" });
    }

    const hasPermission =
      admin.label === "super_admin" ||
      admin.permissions.validateRecruiters ||
      admin.permissions.validateCompanies;

    if (!hasPermission) {
      return res.status(403).json({
        msg: "Permission requise pour gÃ©rer les demandes ANEM candidats",
        code: "PERMISSION_DENIED",
      });
    }

    req.admin = admin;
    next();
  } catch (err) {
    res.status(500).json({ msg: err.message });
  }
};


router.get(
  "/admin/stats",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  getCandidateAnemStats,
);

router.get(
  "/admin/demandes/count",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  getCandidateAnemNewCount,
);


router.get(
  "/admin/demandes",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  getCandidateAnemDemandes,
);

router.get(
  "/admin/demandes/:demandeId",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  getCandidateDemandeDetails,
);


router.get(
  "/admin/pending-ids",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  getCandidatePendingAnemIds,
);


router.post(
  "/admin/demandes/:demandeId/assign",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  assignCandidateDemande,
);


router.post(
  "/admin/demandes/:demandeId/in-progress",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  markCandidateDemandeInProgress,
);


router.get(
  "/admin/demandes/:demandeId/pdf-data",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  getCandidateAnemPdfData,
);


router.post(
  "/admin/demandes/:demandeId/approve-id",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  approveCandidateAnemId,
);

router.post(
  "/admin/demandes/:demandeId/reject-id",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  rejectCandidateAnemId,
);


router.post(
  "/admin/demandes/:demandeId/register",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  markCandidateRegistered,
);

router.post(
  "/admin/demandes/:demandeId/fail",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  markCandidateAnemFailed,
);


router.post(
  "/admin/demandes/:demandeId/note",
  auth,
  authRole(["admin"]),
  requireCandidateAnemPermission,
  addCandidateAnemAdminNote,
);

export default router;


=== routes\candidateRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { authRole } from "../middleware/roles.js";
import { requireEmailVerification } from "../middleware/requireEmailVerification.js";
import { uploadRateLimiter } from "../middleware/security.js";
import { validators } from "../middleware/validate.js";
import {
  uploadCV,
  uploadImage,
  uploadAttachments,
  handleMulterError,
} from "../config/multer.js";

import {
  updateProfile,
  uploadProfilePicture,
  uploadCandidateCV,
  deleteCV,
  applyToOffer,
  updateAccount,
  getProfile,
  addToFavorites,
  removeFromFavorites,
  getFavorites,
  addSkill,
  updateSkill,
  deleteSkill,
  addExperience,
  updateExperience,
  deleteExperience,
  addEducation,
  updateEducation,
  deleteEducation,
  getCandidateStats,
  getActivityTimeline,
  getRecommendedOffers,
} from "../controllers/candidateController.js";

import {
  getSkillDetails,
  submitSkillFeedback,
} from "../controllers/skillController.js";

import {
  getMyApplications,
  getApplicationDetail,
  withdrawApplication,
  cancelApplication,
  checkApplicationStatus,
} from "../controllers/candidateApplicationController.js";

import {
  getCandidateInterviews,
  acceptInterview,
  declineInterview,
  proposeAlternativeDate,
} from "../controllers/interviewController.js";

import {
  getCandidateConversations,
  getConversationMessages,
  sendMessageAsCandidate,
} from "../controllers/conversationController.js";

const router = express.Router();

router.use(auth, authRole(["candidat"]));


router.get("/profil", getProfile);
router.put("/profil", validators.updateProfile, updateProfile);
router.put("/compte", updateAccount);
router.get("/stats", getCandidateStats);
router.get("/activity", getActivityTimeline);


router.post(
  "/upload-photo",
  uploadRateLimiter,
  uploadImage.single("photo"),
  handleMulterError,
  uploadProfilePicture,
);
router.post(
  "/upload-cv",
  uploadRateLimiter,
  uploadCV.single("cv"),
  handleMulterError,
  uploadCandidateCV,
);
router.delete("/delete-cv/:cvId", validators.mongoId("cvId"), deleteCV);


router.post("/profil/skills", validators.addSkill, addSkill);
router.put(
  "/profil/skills/:skillId",
  validators.mongoId("skillId"),
  updateSkill,
);
router.delete(
  "/profil/skills/:skillId",
  validators.mongoId("skillId"),
  deleteSkill,
);

router.get(
  "/profil/skills/:skillId/details",
  validators.mongoId("skillId"),
  getSkillDetails,
);
router.post(
  "/profil/skills/:skillId/feedback",
  validators.mongoId("skillId"),
  submitSkillFeedback,
);


router.post("/profil/experiences", validators.addExperience, addExperience);
router.put(
  "/profil/experiences/:experienceId",
  validators.mongoId("experienceId"),
  updateExperience,
);
router.delete(
  "/profil/experiences/:experienceId",
  validators.mongoId("experienceId"),
  deleteExperience,
);


router.post("/profil/education", validators.addEducation, addEducation);
router.put(
  "/profil/education/:educationId",
  validators.mongoId("educationId"),
  updateEducation,
);
router.delete(
  "/profil/education/:educationId",
  validators.mongoId("educationId"),
  deleteEducation,
);


router.get("/favorites", getFavorites);
router.post(
  "/favorites/:offerId",
  validators.mongoId("offerId"),
  addToFavorites,
);
router.delete(
  "/favorites/:offerId",
  validators.mongoId("offerId"),
  removeFromFavorites,
);


router.get("/recommended-offers", getRecommendedOffers);


router.post(
  "/postuler",
  requireEmailVerification,
  validators.applyToOffer,
  applyToOffer,
);
router.get(
  "/applications/check/:offerId",
  validators.mongoId("offerId"),
  checkApplicationStatus,
);
router.get("/applications", validators.pagination, getMyApplications);
router.get(
  "/applications/:applicationId",
  validators.mongoId("applicationId"),
  getApplicationDetail,
);
router.delete(
  "/applications/:applicationId",
  validators.mongoId("applicationId"),
  withdrawApplication,
);
router.delete(
  "/applications/:applicationId/cancel",
  validators.mongoId("applicationId"),
  cancelApplication,
);


router.get("/interviews", getCandidateInterviews);
router.put(
  "/interviews/:interviewId/accept",
  validators.mongoId("interviewId"),
  acceptInterview,
);
router.put(
  "/interviews/:interviewId/decline",
  validators.mongoId("interviewId"),
  declineInterview,
);
router.put(
  "/interviews/:interviewId/propose-date",
  validators.mongoId("interviewId"),
  proposeAlternativeDate,
);


router.get("/conversations", getCandidateConversations);
router.get(
  "/conversations/:conversationId",
  validators.mongoId("conversationId"),
  getConversationMessages,
);
router.post(
  "/conversations/:conversationId/messages",
  validators.mongoId("conversationId"),
  uploadAttachments.array("attachments", 3),
  handleMulterError,
  sendMessageAsCandidate,
);

export default router;


=== routes\notificationRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import {
  getMyNotifications,
  getUnreadCount,
  markAsRead,
} from "../controllers/notificationController.js";

const router = express.Router();

router.use(auth);

router.get("/", getMyNotifications);
router.get("/unread-count", getUnreadCount);
router.put("/:id/read", markAsRead);

export default router;


=== routes\offerRoutes.js ===
import express from "express";
import {
  getAllActiveOffers,
  getOfferDetails,
} from "../controllers/offerController.js";

const router = express.Router();

router.get("/", getAllActiveOffers);

router.get("/:id", getOfferDetails);

export default router;


=== routes\recruiterRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { optionalAuth } from "../middleware/optionalAuth.js";
import { authRole } from "../middleware/roles.js";
import { requireEmailVerification } from "../middleware/requireEmailVerification.js";

import { uploadImage, uploadAttachments } from "../config/multer.js";


import {
  getRecruiterById,
  createOffer,
  getMyOffers,
  updateOffer,
  deactivateOffer,
  updateRecruiterProfile,
  updateCompanyDetails,
  getRecruiterDashboard,
  getRecruiterProfileEndpoint,
  getCompanyTeam,
  getOfferStats,
  submitValidationResponse,
  getCandidateFullProfile,
  getMyOffersWithStats,
  getRecruiterOfferDetails,
} from "../controllers/recruiterController.js";


import {
  getOfferApplications, 
  
  markAsSeen,
  updateRecruiterStatus,
  toggleStarred,
  updateNotes,
  getAllApplicationsAdvanced,
  markAllOfferApplicationsAsSeen,
} from "../controllers/recruiterApplicationController.js";

import {
  proposeInterview,
  getRecruiterInterviews,
  acceptAlternativeDate,
  rescheduleByRecruiter,
  cancelInterviewByRecruiter,
  completeInterview,
  getRecruiterInterviewsGrouped,
} from "../controllers/interviewController.js";

import {
  getRecruiterConversations,
  openConversation,
  sendMessageAsRecruiter,
  getRecruiterConversationMessages,
} from "../controllers/conversationController.js";

const router = express.Router();


router.get("/public/:id", optionalAuth, getRecruiterById);


router.use(auth, authRole(["recruteur"]));


router.get("/profile", getRecruiterProfileEndpoint);
router.put("/profile", updateRecruiterProfile);
router.get("/candidates/:candidateId", getCandidateFullProfile);
router.get("/dashboard", getRecruiterDashboard);

router.post(
  "/validation-response",
  uploadAttachments.array("documents", 5),
  submitValidationResponse,
);

router.post("/offers", requireEmailVerification, createOffer);
router.get("/my-offers", getMyOffers);
router.get("/offers/:id", getRecruiterOfferDetails);
router.put("/offers/:id", updateOffer);
router.put("/offers/:id/deactivate", deactivateOffer);
router.get("/offers/:offerId/stats", getOfferStats);

router.put("/company", updateCompanyDetails);
router.get("/company/team", getCompanyTeam);


router.get("/offers/:offerId/applications", getOfferApplications); 

router.put("/applications/:applicationId/seen", markAsSeen);
router.put("/applications/:applicationId/status", updateRecruiterStatus); 
router.put("/applications/:applicationId/star", toggleStarred);
router.put("/applications/:applicationId/notes", updateNotes);


router.get("/interviews", getRecruiterInterviews);
router.post("/applications/:applicationId/interviews", proposeInterview);
router.put(
  "/interviews/:interviewId/accept-alternative",
  acceptAlternativeDate,
);
router.put("/interviews/:interviewId/reschedule", rescheduleByRecruiter);
router.put("/interviews/:interviewId/cancel", cancelInterviewByRecruiter);
router.put("/interviews/:interviewId/complete", completeInterview);


router.get("/conversations", getRecruiterConversations);
router.post("/applications/:applicationId/conversation", openConversation);
router.post(
  "/conversations/:conversationId/messages",
  uploadAttachments.array("attachments", 3),
  sendMessageAsRecruiter,
);


router.get("/my-offers-stats", getMyOffersWithStats);


router.put("/offers/:offerId/mark-all-seen", markAllOfferApplicationsAsSeen);


router.get("/applications/advanced", getAllApplicationsAdvanced);


router.get("/conversations/:conversationId", getRecruiterConversationMessages);



router.get("/interviews/grouped", getRecruiterInterviewsGrouped);

export default router;


=== routes\skillRoutes.js ===
import express from "express";
import {
  getSkills,
  getSkillProposalStatus,
  suggestSkills,
} from "../controllers/skillController.js";
import auth from "../middleware/auth.js";

const router = express.Router();

router.get("/", auth, getSkills);
router.get("/suggest", auth, suggestSkills);
router.get("/proposal-status", auth, getSkillProposalStatus);

export default router;


=== routes\supportRoutes.js ===
import express from "express";
import auth from "../middleware/auth.js";
import { validators } from "../middleware/validate.js";
import { uploadRateLimiter } from "../middleware/security.js";
import * as supportController from "../controllers/supportController.js";
import { uploadAttachments, handleMulterError } from "../config/multer.js";

const router = express.Router();

router.use(auth);

router.post(
  "/tickets",
  uploadRateLimiter,
  uploadAttachments.array("attachments", 5),
  handleMulterError,
  validators.createTicket,
  supportController.createTicket,
);

router.get("/tickets", supportController.getMyTickets);

router.get(
  "/tickets/:ticketId",
  validators.mongoId("ticketId"),
  supportController.getTicketDetails,
);

router.post(
  "/tickets/:ticketId/reply",
  uploadRateLimiter,
  uploadAttachments.array("attachments", 3),
  handleMulterError,
  validators.mongoId("ticketId"),
  validators.replyToTicket,
  supportController.replyToTicket,
);

export default router;


=== services\emailService.js ===
import nodemailer from "nodemailer";
import SystemSettings from "../models/SystemSettings.js";


const createTransporter = () => {
  const host = process.env.SMTP_HOST;
  const port = parseInt(process.env.SMTP_PORT) || 587;
  const user = process.env.SMTP_USER;
  const pass = process.env.SMTP_PASS;

  
  if (!host || !user || !pass) {
    console.error("âŒ SMTP Configuration missing:", {
      host: !!host,
      port,
      user: !!user,
      pass: !!pass,
    });
    throw new Error(
      "SMTP configuration incomplete. Check environment variables.",
    );
  }

  console.log("ðŸ“§ Creating SMTP transporter with config:", {
    host,
    port,
    user,
    secure: port === 465,
  });

  return nodemailer.createTransport({
    host,
    port,
    secure: port === 465, 
    auth: {
      user,
      pass,
    },
    
    connectionTimeout: 10000,
    greetingTimeout: 10000,
    socketTimeout: 10000,
  });
};


const templates = {
  verificationCode: (code, userName) => ({
    subject: "Confirmez votre adresse email",
    html: `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: #4F46E5; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }
          .content { background: #f9fafb; padding: 30px; border-radius: 0 0 8px 8px; }
          .code { font-size: 32px; font-weight: bold; color: #4F46E5; text-align: center; letter-spacing: 8px; padding: 20px; background: white; border-radius: 8px; margin: 20px 0; }
          .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
          .warning { color: #dc2626; font-size: 14px; margin-top: 15px; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>VÃ©rification de votre email</h1>
          </div>
          <div class="content">
            <p>Bonjour${userName ? ` ${userName}` : ""},</p>
            <p>Merci de vous Ãªtre inscrit ! Voici votre code de vÃ©rification :</p>
            <div class="code">${code}</div>
            <p>Ce code expire dans <strong>15 minutes</strong>.</p>
            <p class="warning">Si vous n'avez pas demandÃ© ce code, ignorez cet email.</p>
          </div>
          <div class="footer">
            <p>Â© ${new Date().getFullYear()} Plateforme de Recrutement</p>
          </div>
        </div>
      </body>
      </html>
    `,
    text: `Bonjour${userName ? ` ${userName}` : ""},\n\nVotre code de vÃ©rification est : ${code}\n\nCe code expire dans 15 minutes.\n\nSi vous n'avez pas demandÃ© ce code, ignorez cet email.`,
  }),

  welcomeEmail: (userName) => ({
    subject: "Bienvenue sur notre plateforme !",
    html: `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: #10b981; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }
          .content { background: #f9fafb; padding: 30px; border-radius: 0 0 8px 8px; }
          .button { display: inline-block; background: #4F46E5; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; margin-top: 15px; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>ðŸŽ‰ Email vÃ©rifiÃ© avec succÃ¨s !</h1>
          </div>
          <div class="content">
            <p>Bonjour ${userName || ""},</p>
            <p>Votre adresse email a Ã©tÃ© vÃ©rifiÃ©e avec succÃ¨s. Votre compte est maintenant pleinement actif !</p>
            <p>Vous pouvez maintenant :</p>
            <ul>
              <li>ComplÃ©ter votre profil</li>
              <li>TÃ©lÃ©charger votre CV</li>
              <li>Postuler aux offres d'emploi</li>
            </ul>
            <p>Bonne recherche d'emploi !</p>
          </div>
        </div>
      </body>
      </html>
    `,
    text: `Bonjour ${userName || ""},\n\nVotre adresse email a Ã©tÃ© vÃ©rifiÃ©e avec succÃ¨s. Votre compte est maintenant pleinement actif !\n\nBonne recherche d'emploi !`,
  }),
  passwordReset: (code, userName) => ({
    subject: "RÃ©initialisation de votre mot de passe",
    html: `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: #dc2626; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }
          .content { background: #f9fafb; padding: 30px; border-radius: 0 0 8px 8px; }
          .code { font-size: 32px; font-weight: bold; color: #dc2626; text-align: center; letter-spacing: 8px; padding: 20px; background: white; border-radius: 8px; margin: 20px 0; border: 2px dashed #dc2626; }
          .footer { text-align: center; margin-top: 20px; color: #666; font-size: 12px; }
          .warning { background: #fef2f2; border: 1px solid #fecaca; color: #991b1b; padding: 15px; border-radius: 8px; margin-top: 20px; }
          .info { background: #eff6ff; border: 1px solid #bfdbfe; color: #1e40af; padding: 12px; border-radius: 6px; margin-top: 15px; font-size: 14px; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>ðŸ” RÃ©initialisation du mot de passe</h1>
          </div>
          <div class="content">
            <p>Bonjour${userName ? ` ${userName}` : ""},</p>
            <p>Vous avez demandÃ© la rÃ©initialisation de votre mot de passe. Voici votre code de vÃ©rification :</p>
            <div class="code">${code}</div>
            <div class="info">
              <strong>â±ï¸ Ce code expire dans 20 minutes.</strong><br>
              Vous avez droit Ã  3 tentatives pour entrer le code correct.
            </div>
            <div class="warning">
              <strong>âš ï¸ Attention :</strong><br>
              Si vous n'avez pas demandÃ© cette rÃ©initialisation, ignorez cet email et votre mot de passe restera inchangÃ©.<br><br>
              Si vous pensez que quelqu'un essaie d'accÃ©der Ã  votre compte, nous vous recommandons de sÃ©curiser votre email.
            </div>
          </div>
          <div class="footer">
            <p>Â© ${new Date().getFullYear()} Plateforme de Recrutement</p>
            <p>Cet email a Ã©tÃ© envoyÃ© suite Ã  une demande de rÃ©initialisation de mot de passe.</p>
          </div>
        </div>
      </body>
      </html>
    `,
    text: `Bonjour${userName ? ` ${userName}` : ""},\n\nVous avez demandÃ© la rÃ©initialisation de votre mot de passe.\n\nVotre code de vÃ©rification est : ${code}\n\nCe code expire dans 20 minutes.\nVous avez droit Ã  3 tentatives pour entrer le code correct.\n\nSi vous n'avez pas demandÃ© cette rÃ©initialisation, ignorez cet email.\n\nPlateforme de Recrutement`,
  }),

  passwordResetSuccess: (userName) => ({
    subject: "Votre mot de passe a Ã©tÃ© modifiÃ©",
    html: `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: #10b981; color: white; padding: 20px; text-align: center; border-radius: 8px 8px 0 0; }
          .content { background: #f9fafb; padding: 30px; border-radius: 0 0 8px 8px; }
          .warning { background: #fef2f2; border: 1px solid #fecaca; color: #991b1b; padding: 15px; border-radius: 8px; margin-top: 20px; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>âœ… Mot de passe modifiÃ©</h1>
          </div>
          <div class="content">
            <p>Bonjour${userName ? ` ${userName}` : ""},</p>
            <p>Votre mot de passe a Ã©tÃ© modifiÃ© avec succÃ¨s le <strong>${new Date().toLocaleString("fr-FR", { dateStyle: "long", timeStyle: "short" })}</strong>.</p>
            <p>Vous pouvez maintenant vous connecter avec votre nouveau mot de passe.</p>
            <div class="warning">
              <strong>âš ï¸ Ce n'Ã©tait pas vous ?</strong><br>
              Si vous n'avez pas effectuÃ© cette modification, contactez immÃ©diatement notre support et sÃ©curisez votre compte email.
            </div>
          </div>
        </div>
      </body>
      </html>
    `,
    text: `Bonjour${userName ? ` ${userName}` : ""},\n\nVotre mot de passe a Ã©tÃ© modifiÃ© avec succÃ¨s.\n\nSi vous n'avez pas effectuÃ© cette modification, contactez immÃ©diatement notre support.`,
  }),
};


export const sendEmail = async (to, templateName, templateData = {}) => {
  try {
    const mode = await SystemSettings.getSetting(
      "email_verification_mode",
      "development",
    );

    console.log(`ðŸ“§ Email mode: ${mode}`);
    console.log(`ðŸ“§ Sending to: ${to}`);
    console.log(`ðŸ“§ Template: ${templateName}`);

    if (mode === "development") {
      const template = templates[templateName]?.(
        templateData.code,
        templateData.userName,
      );
      console.log(`\nðŸ“§ [DEV MODE] Email Ã  ${to}:`);
      console.log(`   Sujet: ${template?.subject}`);
      if (templateData.code) {
        console.log(`   Code: ${templateData.code}`);
      }
      console.log("");
      return { success: true, mode: "development" };
    }

    
    console.log(`ðŸ“§ SMTP Config Check:`, {
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      user: process.env.SMTP_USER,
      passExists: !!process.env.SMTP_PASS,
    });

    const transporter = createTransporter();

    
    console.log("ðŸ“§ Verifying SMTP connection...");
    await transporter.verify();
    console.log("ðŸ“§ SMTP connection verified successfully");

    const template = templates[templateName]?.(
      templateData.code,
      templateData.userName,
    );

    if (!template) {
      throw new Error(`Template "${templateName}" not found`);
    }

    const fromEmail = process.env.SMTP_FROM || process.env.SMTP_USER;

    const mailOptions = {
      from: `"Plateforme Recrutement" <${fromEmail}>`,
      to,
      subject: template.subject,
      html: template.html,
      text: template.text,
    };

    console.log("ðŸ“§ Sending email with options:", {
      from: mailOptions.from,
      to: mailOptions.to,
      subject: mailOptions.subject,
    });

    const result = await transporter.sendMail(mailOptions);

    console.log(`âœ… Email envoyÃ© Ã  ${to}: ${result.messageId}`);
    return { success: true, messageId: result.messageId, mode: "smtp" };
  } catch (error) {
    console.error(`âŒ Erreur envoi email Ã  ${to}:`, error);
    console.error("Error details:", {
      message: error.message,
      code: error.code,
      command: error.command,
    });
    throw error;
  }
};

export const sendPasswordResetEmail = async (email, code, userName = null) => {
  return sendEmail(email, "passwordReset", { code, userName });
};

export const sendPasswordResetSuccessEmail = async (email, userName = null) => {
  return sendEmail(email, "passwordResetSuccess", { userName });
};


export const sendVerificationEmail = async (email, code, userName = null) => {
  return sendEmail(email, "verificationCode", { code, userName });
};

export const sendWelcomeEmail = async (email, userName = null) => {
  return sendEmail(email, "welcomeEmail", { userName });
};


export const verifySmtpConnection = async () => {
  try {
    console.log("ðŸ” Checking SMTP environment variables...");
    console.log({
      SMTP_HOST: process.env.SMTP_HOST,
      SMTP_PORT: process.env.SMTP_PORT,
      SMTP_USER: process.env.SMTP_USER,
      SMTP_PASS: process.env.SMTP_PASS ? "****" : "NOT SET",
    });

    if (
      !process.env.SMTP_HOST ||
      !process.env.SMTP_USER ||
      !process.env.SMTP_PASS
    ) {
      console.error("âŒ SMTP environment variables not set");
      return false;
    }

    const transporter = createTransporter();
    await transporter.verify();
    console.log("âœ… SMTP connection verified");
    return true;
  } catch (error) {
    console.error("âŒ SMTP connection failed:", error.message);
    return false;
  }
};

export default {
  sendEmail,
  sendVerificationEmail,
  sendWelcomeEmail,
  sendPasswordResetEmail,
  sendPasswordResetSuccessEmail,
  verifySmtpConnection,
};


=== startup\seedAdmin.js ===
import bcrypt from "bcryptjs";
import User from "../models/User.js";
import Admin from "../models/Admin.js";

export const seedAdmin = async () => {
  try {
    const exist = await User.findOne({ role: "admin" });
    if (exist) {
      console.log("ðŸ‘‘ Admin dÃ©jÃ  existant.");
      return;
    }

    const hash = await bcrypt.hash("admin", 10);

    const user = await User.create({
      nom: "Super Admin",
      email: "admin@recrutement.com",
      motDePasse: hash,
      role: "admin",
      emailVerified: true,
      accountStatus: "active",
    });

    await Admin.create({
      userId: user._id,
      label: "super_admin",
      status: "active",
      permissions: {
        createAdmin: true,
        deleteAdmin: true,
        editAdminPermissions: true,
        assignAdminLabels: true,
        validateOffers: true,
        validateRecruiters: true,
        validateCompanies: true,
        banUsers: true,
        suspendUsers: true,
        proposeCandidates: true,
        manageAnnouncements: true,
        sendNotifications: true,
        handleSupportTickets: true,
        viewStats: true,
        viewLogs: true,
      },
    });

    console.log("âœ… Super Admin crÃ©Ã© avec toutes les permissions");
  } catch (err) {
    console.error("âŒ Erreur crÃ©ation admin:", err.message);
  }
};


=== startup\setupFolders.js ===
import fs from "fs";

export default function setupFolders() {
  const folders = [
    "uploads",
    "uploads/cv",
    "uploads/images",
    "uploads/attachments",
    "uploads/documents",
  ];

  folders.forEach((dir) => {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
      console.log(`ðŸ“ Dossier crÃ©Ã© : ${dir}`);
    }
  });
}


=== utils\profileCompletion.js ===
export const calculateProfileCompletion = (candidate, user) => {
  const checks = {
    nom: !!user?.nom,
    telephone: !!candidate?.telephone,
    residence: !!candidate?.residence?.wilaya,

    bio: !!candidate?.bio,
    dateOfBirth: !!candidate?.dateOfBirth,
    gender: !!candidate?.gender,
    profilePicture: !!candidate?.profilePicture,

    desiredPosition: !!candidate?.desiredPosition,
    cv: candidate?.cvs?.length > 0,
    skills: candidate?.skills?.length > 0,
    experiences: candidate?.experiences?.length > 0,
    education: candidate?.education?.length > 0,
  };

  const completed = Object.values(checks).filter(Boolean).length;
  const total = Object.keys(checks).length;

  const minimumRequiredForApplication = {
    telephone: !!candidate?.telephone,
    residence: !!candidate?.residence?.wilaya,
    cv: candidate?.cvs?.length > 0,
    skills: candidate?.skills?.length > 0,
  };

  const canApply = Object.values(minimumRequiredForApplication).every(Boolean);
  const missingForApplication = Object.entries(minimumRequiredForApplication)
    .filter(([_, v]) => !v)
    .map(([k]) => {
      const labels = {
        telephone: "NumÃ©ro de tÃ©lÃ©phone",
        residence: "Localisation (wilaya)",
        cv: "CV",
        skills: "Au moins une compÃ©tence",
      };
      return labels[k] || k;
    });

  return {
    percentage: Math.round((completed / total) * 100),
    missing: Object.entries(checks)
      .filter(([_, v]) => !v)
      .map(([k]) => k),
    isComplete: completed === total,
    canApply,
    missingForApplication,
  };
};


=== utils\statusMapping.js ===
export const RECRUITER_TO_CANDIDATE_STATUS = {
  nouvelle: "envoyee",
  consultee: "en_cours",
  preselection: "en_cours",
  en_discussion: "en_cours",
  entretien_planifie: "en_cours",
  entretien_termine: "en_cours",
  retenue: "retenue",
  refusee: "non_retenue",
};

export const mapRecruiterToCandidate = (recruiterStatus) => {
  return RECRUITER_TO_CANDIDATE_STATUS[recruiterStatus] || "en_cours";
};


export const NOTIFY_CANDIDATE_STATUSES = ["retenue", "refusee"];


export const TERMINAL_STATUSES = {
  candidate: ["retenue", "non_retenue", "retiree"],
  recruiter: ["retenue", "refusee"],
};
